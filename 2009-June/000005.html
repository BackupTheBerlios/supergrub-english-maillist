<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [sgd-en] r4 - castillonroy/dev_grub/stage2
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/supergrub-english/2009-June/index.html" >
   <LINK REL="made" HREF="mailto:supergrub-english%40lists.berlios.de?Subject=Re%3A%20%5Bsgd-en%5D%20r4%20-%20castillonroy/dev_grub/stage2&In-Reply-To=%3C200906021721.n52HLl1n018711%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000004.html">
   <LINK REL="Next"  HREF="000006.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[sgd-en] r4 - castillonroy/dev_grub/stage2</H1>
    <B>adrian15 at mail.berlios.de</B> 
    <A HREF="mailto:supergrub-english%40lists.berlios.de?Subject=Re%3A%20%5Bsgd-en%5D%20r4%20-%20castillonroy/dev_grub/stage2&In-Reply-To=%3C200906021721.n52HLl1n018711%40sheep.berlios.de%3E"
       TITLE="[sgd-en] r4 - castillonroy/dev_grub/stage2">adrian15 at mail.berlios.de
       </A><BR>
    <I>Tue Jun  2 19:21:47 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000004.html">[sgd-en] Mailing Liat
</A></li>
        <LI>Next message: <A HREF="000006.html">[sgd-en] which SCM to use?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5">[ date ]</a>
              <a href="thread.html#5">[ thread ]</a>
              <a href="subject.html#5">[ subject ]</a>
              <a href="author.html#5">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: adrian15
Date: 2009-06-02 19:21:33 +0200 (Tue, 02 Jun 2009)
New Revision: 4

Removed:
   castillonroy/dev_grub/stage2/builtins.c.orig
   castillonroy/dev_grub/stage2/disk_io.c.orig
   castillonroy/dev_grub/stage2/filesys.h.orig
   castillonroy/dev_grub/stage2/fsys_ext2fs.c.orig
   castillonroy/dev_grub/stage2/fsys_fat.c.orig
   castillonroy/dev_grub/stage2/rootnoverify_different_drive_error_fix.diff
   castillonroy/dev_grub/stage2/shared.h.orig
   castillonroy/dev_grub/stage2/stage2.c.orig
Log:
Delete unnecessary files

Deleted: castillonroy/dev_grub/stage2/builtins.c.orig
===================================================================
--- castillonroy/dev_grub/stage2/builtins.c.orig	2009-06-01 19:30:15 UTC (rev 3)
+++ castillonroy/dev_grub/stage2/builtins.c.orig	2009-06-02 17:21:33 UTC (rev 4)
@@ -1,6465 +0,0 @@
-/* builtins.c - the GRUB builtin commands */
-/*
- *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 1999,2000,2001,2002,2003,2004  Free Software Foundation, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-/* Include stdio.h before shared.h, because we can't define
-   WITHOUT_LIBC_STUBS here.  */
-#ifdef GRUB_UTIL
-# include &lt;stdio.h&gt;
-#endif
-
-#include &lt;shared.h&gt;
-#include &lt;filesys.h&gt;
-#include &lt;term.h&gt;
-
-#ifdef SUPPORT_NETBOOT
-# define GRUB	1
-# include &lt;etherboot.h&gt;
-#endif
-
-#ifdef SUPPORT_SERIAL
-# include &lt;serial.h&gt;
-# include &lt;terminfo.h&gt;
-#endif
-
-#ifdef GRUB_UTIL
-# include &lt;device.h&gt;
-#else /* ! GRUB_UTIL */
-# include &lt;apic.h&gt;
-# include &lt;smp-imps.h&gt;
-#endif /* ! GRUB_UTIL */
-
-#ifdef USE_MD5_PASSWORDS
-# include &lt;md5.h&gt;
-#endif
-
-#define PART_TYPE_NUMBER 18
-#define PART_DESCRIPTION_MAXIMUM 44
-
-/* Prototypes for allowing straightfoward calling of builtins functions
-   inside other functions.  */
-static int configfile_func (char *arg, int flags);
-static int real_root_func (char *arg, int flags);
-static int set_func (char *arg, int flags);
-
-
-struct partition_type
-{
-  int id;
-  char *name;
-};
-
-struct partition_type partition_type_table[PART_TYPE_NUMBER] =
-{
-
-
-{ 1 ,  &quot;FAT12&quot;}, // 1
-{ 6 , &quot;FAT16&quot;},  // 2
-{ 7 , &quot;HPFS/NTFS&quot;}, // 3
-{ 11 , &quot;W95 FAT32&quot;},// 4
-{ 12 , &quot;W95 FAT32 (LBA)&quot;},// 5
-{ 14 , &quot;W95 FAT16 (LBA)&quot;}, // 6
-{ 15 , &quot;W95 Ext'd (LBA)&quot;}, // 7
-{27 , &quot;Hidden W95 FAT32&quot;}, // 8
-{28 , &quot;Hidden W95 FAT32&quot;}, // 9
-{99 , &quot;GNU HURD or Sys&quot;}, // 10
-{129 , &quot;Minix / old Lin&quot;}, // 11
-{130 , &quot;SWAP&quot;}, // 12
-{131 , &quot;Linux&quot;}, // 13
-{134 , &quot;NTFS volume set&quot;}, //14
-{135 , &quot;NTFS volume set&quot;}, //15
-{136 , &quot;Linux plaintext&quot;},//16
-{142 , &quot;Linux LVM&quot;}, //17
-{191 , &quot;Solaris&quot;}  //18
-
-};
-
-
-
-
-
-
-
-int partition_string_set (int *part_type, char *string) {
-	int count;
-	for (count=0;count&lt;(PART_TYPE_NUMBER-1);count++) {
-		if (*(part_type)==partition_type_table[count].id) 
-		{
-			grub_sprintf(string,&quot;%s&quot;,partition_type_table[count].name);
-			return 0;
-		}
-	}
-	return 1;
-}
-
-void set_partition_type (char *temp_string_ptr, int *type) {
-
-		open_device(); 
-		errnum = ERR_NONE; // We do not want that partition error makes memmove work bad
-		grub_sprintf (temp_string_ptr,&quot;%s&quot;, fsys_table[fsys_type].name);
-	if (fsys_type == NUM_FSYS) // We go to a fixed partition type table
-	  {
-	    if (partition_string_set (type, temp_string_ptr)) {grub_sprintf(temp_string_ptr,&quot;Unknown&quot;);}
-	  } 
-}
-
-
-void set_partition_os (char *temp_string_ptr, int *type) {
-	int read_char_number = 0;
-	char read_char;
-
-		open_device(); 
-		errnum = ERR_NONE; // We do not want that partition error makes memmove work bad
-
-
-		set_partition_type (temp_string_ptr,type);
-		if (!(grub_strcmp(temp_string_ptr,&quot;fat&quot;)) || (!(grub_strcmp(temp_string_ptr,&quot;HPFS/NTFS&quot;)))) {
-			grub_sprintf(temp_string_ptr,&quot;WINDOWS&quot;);
-		} else {
-		*temp_string_ptr=0;
-		// Distro name code
-		if (grub_open(&quot;/etc/issue&quot;)) {
-			errnum = ERR_NONE; // We do not want that partition error makes memmove work bad
-			while ((grub_read(&amp;read_char, 1)) &amp;&amp; (grub_strlen(temp_string_ptr) &lt; (PART_DESCRIPTION_MAXIMUM-1) ))	{
-			  errnum = ERR_NONE; // We do not want that partition error makes memmove work bad
-			if ((isspace (read_char) || (read_char &gt;= ' ' &amp;&amp; read_char &lt;= '~')) &amp;&amp; (read_char != 10)) {
-			  grub_sprintf(temp_string_ptr,&quot;%s%c&quot;,temp_string_ptr,read_char);
-			}
-			  read_char_number++;
-			}
-			grub_close();
-		} else {
-		errnum = ERR_NONE; // Force to open a new file
-		if (grub_open(&quot;/grub/stage1&quot;)) {
-		  grub_close(); 
-		  errnum = ERR_NONE;
-		  grub_sprintf(temp_string_ptr,&quot;%s&quot;,&quot;/BOOT&quot;);
-		}}
-		}
-
-errnum = ERR_NONE; // Ignore any error. There should not be any.	
-
-	    
-
-}
-
-
-void add_choose_title (void) {  
-  // Choose title
-  add_title (&amp;menu_array[menu_level], &quot;$(choose_title)&quot;);
-  add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;pause Nothing to do&quot;);
-  close_title ((char *) MENU_BUF, &amp;menu_array[menu_level]);
-
-  // Back title
-
-  add_title (&amp;menu_array[menu_level], &quot;&lt;---- BACK  (Error 6 is OK)&quot;);
-  add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;adhocerror&quot;);
-  close_title ((char *) MENU_BUF, &amp;menu_array[menu_level]);
-
-
-} 
-
-
-void add_part_title (void) {
-  add_title (&amp;menu_array[menu_level], &quot;N IDE  SCSI GRUB    HURD  TYPE     SIZE   OS&quot;);
-  add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;pause Nothing to do&quot;);
-  close_title ((char *) MENU_BUF, &amp;menu_array[menu_level]);
-}
-
-
-void add_part_instructions (int *type, int part, unsigned long *len) {
-  	char part_type_str_buffer[15];
-  	char os_type_str_buffer[50];
-  	char *part_type_str_ptr=part_type_str_buffer;
-	
-	char human_number_buffer[8];
-	char *human_number_buffer_ptr=human_number_buffer;
-	unsigned long int len_kb=(unsigned long int)(*len)/2;
-	
-	human_number(human_number_buffer_ptr, &amp;len_kb);
-
-	int bsd_part = (part &gt;&gt; 8) &amp; 0xFF;
-	int pc_slice = part &gt;&gt; 16;
-
-	
-
-
-	set_partition_type (part_type_str_ptr,type);	
-	set_partition_os (os_type_str_buffer,type);	
-
-
-
-	if (bsd_part == 0xFF)
-		{
-		add_title (&amp;menu_array[menu_level], &quot;%d hd%c%d sd%c%d (hd%d,%d) hd%ds%d  %s  %s %s&quot;,pc_slice+1,'a' + current_drive - 0x80,pc_slice+1,'a' + current_drive - 0x80,pc_slice+1,current_drive - 0x80,pc_slice,current_drive - 0x80,pc_slice+1,part_type_str_ptr,human_number_buffer,os_type_str_buffer);
-			
- 
-		add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_device=(hd%d,%d)&quot;,current_drive - 0x80,pc_slice);
-		}
-		else {
-		add_title (&amp;menu_array[menu_level], &quot;%d hd%c%d sd%c%d (hd%d,%d,%c) hd%ds%d  %s  %s %s&quot;,pc_slice+1,'a' + current_drive - 0x80,pc_slice+1,'a' + current_drive - 0x80,pc_slice+1,current_drive - 0x80,pc_slice,bsd_part + 'a',current_drive - 0x80,pc_slice+1,part_type_str_ptr,human_number_buffer,os_type_str_buffer);
-
-		add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_device=(hd%d,%d,%c)&quot;,current_drive - 0x80,pc_slice,bsd_part + 'a');
-
-			}
-			// Common instructions to partitions and slices
-		add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_hurd_hd=hd%d&quot;,current_drive - 0x80);
-		add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_hd=hd%d&quot;,current_drive - 0x80);
-		add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_linux_letter=%c&quot;,'a'+current_drive - 0x80);
-		add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_lide_hd=hd%c&quot;,'a' + current_drive - 0x80);
-		add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_lscsi_hd=sd%c&quot;,'a' + current_drive - 0x80);
-
-		add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_part=($(out_hurd_hd),%d)&quot;,pc_slice);
-		add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_lide_part=$(out_lide_hd)%d&quot;,(pc_slice+1));
-		add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_lscsi_part=$(out_lscsi_hd)%d&quot;,(pc_slice+1));
-		add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_hurd_part=$(out_hurd_hd)s%d&quot;,pc_slice+1);
-		add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_linux_part=$(out_linux_letter)%d&quot;,(pc_slice+1));
-		add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_part_n=%d&quot;,pc_slice);
-		add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_linux_end=%c%d&quot;,'a' + current_drive - 0x80, pc_slice + 1);
-}
-
-
-void add_part_printf (int *type, int part, unsigned long *len) {
-  	char part_type_str_buffer[15];
-  	char os_type_str_buffer[50];
-  	char *part_type_str_ptr=part_type_str_buffer;
-	
-	char human_number_buffer[8];
-	char *human_number_buffer_ptr=human_number_buffer;
-	unsigned long int len_kb=(unsigned long int)(*len)/2;
-	
-	human_number(human_number_buffer_ptr, &amp;len_kb);
-
-	int bsd_part = (part &gt;&gt; 8) &amp; 0xFF;
-	int pc_slice = part &gt;&gt; 16;
-
-	
-
-
-	set_partition_type (part_type_str_ptr,type);	
-	set_partition_os (os_type_str_buffer,type);	
-
-
-
-	if (bsd_part == 0xFF)
-		{
-		grub_printf(&quot;%d (hd%d,%d) %s  %s %s\n&quot;,pc_slice+1,current_drive - 0x80,pc_slice,part_type_str_ptr,human_number_buffer,os_type_str_buffer);
-
-		}
-		else {
-		grub_printf(&quot;%d (hd%d,%d,%c) %s  %s %s\n&quot;,pc_slice+1,current_drive - 0x80,pc_slice,bsd_part + 'a',part_type_str_ptr,human_number_buffer,os_type_str_buffer);
-
-			}
-			// Common instructions to partitions and slices
-}
-
-
-
-
-
-// Warning Grub logical. 0 means success
-//
-int there_is_a_hard_disk (void) {
-	int i,disk_no,j;
-// Check if there's any hard disk before doing anything  - Begin 
-		  for (i = 1;i &lt; 2; i++) { for (j = 0; j &lt; 16; j++) {
-			  struct geometry geom;
-			  disk_no = (i * 0x80) + j;
-			  if (! get_diskinfo (disk_no, &amp;geom))
-			  return 0;
-		  }   }
-return 1; //No hard disk found
-
-}
-
-
-/* The type of kernel loaded.  */
-kernel_t kernel_type;
-/* The boot device.  */
-static int bootdev;
-/* True when the debug mode is turned on, and false
-   when it is turned off.  */
-int debug = 0;
-/* The default entry.  */
-int default_entry = 0;
-/* The fallback entry.  */
-int fallback_entryno;
-int fallback_entries[MAX_FALLBACK_ENTRIES];
-/* The number of current entry.  */
-int current_entryno;
-/* graphics file */
-char graphics_file[64];
-/* The address for Multiboot command-line buffer.  */
-static char *mb_cmdline;
-/* The password.  */
-char *password;
-/* The password type.  */
-password_t password_type;
-/* The flag for indicating that the user is authoritative.  */
-int auth = 0;
-/* The timeout.  */
-int grub_timeout = -1;
-/* Whether to show the menu or not.  */
-int show_menu = 1;
-/* The BIOS drive map.  */
-static unsigned short bios_drive_map[DRIVE_MAP_SIZE + 1];
-
-int real_map_func (unsigned long to, unsigned long from) {
-int i;
-  /* Search for an empty slot in BIOS_DRIVE_MAP.  */
-  for (i = 0; i &lt; DRIVE_MAP_SIZE; i++)
-    {
-      /* Perhaps the user wants to override the map.  */
-      if ((bios_drive_map[i] &amp; 0xff) == from)
-	break;
-      
-      if (! bios_drive_map[i])
-	break;
-    }
-
-  if (i == DRIVE_MAP_SIZE)
-    {
-      errnum = ERR_WONT_FIT;
-      return 1;
-    }
-
-  if (to == from)
-    /* If TO is equal to FROM, delete the entry.  */
-    grub_memmove ((char *) &amp;bios_drive_map[i], (char *) &amp;bios_drive_map[i + 1],
-		  sizeof (unsigned short) * (DRIVE_MAP_SIZE - i));
-  else
-    bios_drive_map[i] = from | (to &lt;&lt; 8);
-  
-  return 0;
-
-
-}
-
-
-
-
-/* Initialize the data for builtins.  */
-void
-init_builtins (void)
-{
-  kernel_type = KERNEL_TYPE_NONE;
-  /* BSD and chainloading evil hacks!  */
-  bootdev = set_bootdev (0);
-  mb_cmdline = (char *) MB_CMDLINE_BUF;
-}
-
-/* Initialize the data for the configuration file.  */
-void
-init_config (void)
-{
-  default_entry = 0;
-  password = 0;
-  fallback_entryno = -1;
-  fallback_entries[0] = -1;
-  grub_timeout = -1;
-}
-
-void
-configfile_end (void)
-{
-  #ifdef GRUB_UTIL
-  /* Force to load the configuration file.  */
-  use_config_file = 1;
-  #endif
-
-  /* Make sure that the user will not be authoritative.  */
-  auth = 0;
-  
-  /* Restart cmain.  */
-  grub_longjmp (restart_env, 0);
-
-}
-
-/* Check a password for correctness.  Returns 0 if password was
-   correct, and a value != 0 for error, similarly to strcmp. */
-int
-check_password (char *entered, char* expected, password_t type)
-{
-  switch (type)
-    {
-    case PASSWORD_PLAIN:
-      return strcmp (entered, expected);
-
-#ifdef USE_MD5_PASSWORDS
-    case PASSWORD_MD5:
-      return check_md5_password (entered, expected);
-#endif
-    default: 
-      /* unsupported password type: be secure */
-      return 1;
-    }
-}
-
-/* Print which sector is read when loading a file.  */
-static void
-disk_read_print_func (int sector, int offset, int length)
-{
-  grub_printf (&quot;[%d,%d,%d]&quot;, sector, offset, length);
-}
-
-/* adhocerror */
-static int
-adhocerror_func (char *arg, int flags)
-{
-
-if (menu_level&gt;0) 
-  {	special_menu=0; // Restore special menu to a normal one
-	// Go down a level
-	menu_level--;
-	return (errnum = ERR_BAD_VERSION);
-  }
-else 
-  {
-     errnum = ERR_BAD_ARGUMENT; return 1;
-  }
-    
-}
-
-static struct builtin builtin_adhocerror =
-{
-  &quot;adhocerror&quot;,
-  adhocerror_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;adhocerror&quot;,
-  &quot;Generates an ad hoc error for coming back from special configfiles.&quot;
-};
-
-
-/* back */
-static int
-back_func (char *arg, int flags)
-{
-
-if (menu_level&gt;0) 
-  {	special_menu=0; // Restore special menu to a normal one
-	// Go down a level
-	menu_level--;
-	return 0;
-  }
-else 
-  {
-     errnum = ERR_BAD_ARGUMENT; return 1;
-  }
-}
-
-static struct builtin builtin_back =
-{
-  &quot;back&quot;,
-  back_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;back FILE&quot;,
-  &quot;Comes back to previously loaded menu.&quot;
-};
-
-void check_int13_handler (int modify_saved_drive) {
-      /* Check if we should set the int13 handler.  */
-      if (bios_drive_map[0] != 0)
-	{
-	  int i;
-	  if (modify_saved_drive) {
-	  	/* Search for SAVED_DRIVE.  */
-	  	for (i = 0; i &lt; DRIVE_MAP_SIZE; i++)
-	    	{
-	      	if (! bios_drive_map[i])
-			break;
-		      else if ((bios_drive_map[i] &amp; 0xFF) == saved_drive)
-			{
-		  	/* Exchage SAVED_DRIVE with the mapped drive.  */
-		  	saved_drive = (bios_drive_map[i] &gt;&gt; 8) &amp; 0xFF;
-		  	break;
-			}
-	    	}
-	  }
-	  /* Set the handler. This is somewhat dangerous.  */
-	  set_int13_handler (bios_drive_map);
-	}
-
-}
-
-/* boot */
-static int
-boot_func (char *arg, int flags)
-{
-  /* Clear the int15 handler if we can boot the kernel successfully.
-     This assumes that the boot code never fails only if KERNEL_TYPE is
-     not KERNEL_TYPE_NONE. Is this assumption is bad?  */
-  if (kernel_type != KERNEL_TYPE_NONE)
-    unset_int15_handler ();
-
-#ifdef SUPPORT_NETBOOT
-  /* Shut down the networking.  */
-  cleanup_net ();
-#endif
-  
-  switch (kernel_type)
-    {
-    case KERNEL_TYPE_FREEBSD:
-    case KERNEL_TYPE_NETBSD:
-      /* *BSD */
-      bsd_boot (kernel_type, bootdev, (char *) mbi.cmdline);
-      break;
-
-    case KERNEL_TYPE_LINUX:
-      /* Linux */
-      linux_boot ();
-      break;
-
-    case KERNEL_TYPE_BIG_LINUX:
-      /* Big Linux */
-      big_linux_boot ();
-      break;
-
-    case KERNEL_TYPE_CHAINLOADER:
-      /* Chainloader */
-
-      /* Check if we should set the int13 handler.  */
-      check_int13_handler(1); // 1 means that we want the function to modify the saved drive
-      
-      gateA20 (0);
-      boot_drive = saved_drive;
-      chain_stage1 (0, BOOTSEC_LOCATION, boot_part_addr);
-      break;
-
-    case KERNEL_TYPE_MULTIBOOT:
-      /* Multiboot */
-      multi_boot ((int) entry_addr, (int) &amp;mbi);
-      break;
-
-    default:
-      errnum = ERR_BOOT_COMMAND;
-      return 1;
-    }
-
-  return 0;
-}
-
-static struct builtin builtin_boot =
-{
-  &quot;boot&quot;,
-  boot_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;boot&quot;,
-  &quot;Boot the OS/chain-loader which has been loaded.&quot;
-};
-
-
-/* call */
-static int
-call_func (char *arg, int flags)
-{
-
-
-// NEXT CODE IS EQUIVALENT TO CONFIGFILE command
-
-  char *new_config = config_file;
-
-  /* Check if the file ARG is present.  */
-  if (! grub_open (arg))
-    return 1;
-
-  grub_close ();
-
-if(add_menu ()) return 1;
-close_menu ((char *) MENU_BUF, &amp;menu_array[menu_level]);
-
-  // Copy ARG to CONFIG_FILE.  
-  while ((*new_config++ = *arg++) != 0)
-    ;
-
-// menu_array config_file value has to be updated when loading a new file
-      memmove(menu_array[menu_level].config_file,	// TO
-      config_file,					// FROM
-      128);						//SIZE
-
-
-  configfile_end();
-  /* Never reach here.  */
-  return 0;
-}
-
-static struct builtin builtin_call =
-{
-  &quot;call&quot;,
-  call_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;call FILE&quot;,
-  &quot;Load FILE as the configuration file and return to current execution when back command is called.&quot;
-};
-
-
-/* cat */
-static int
-cat_func (char *arg, int flags)
-{
-
-
-if (cat_is_on) {
-int temporal_count_lines;
-  char c;
-
-temporal_count_lines=count_lines; // Fetch value of count_lines
-count_lines=0; // Force cat to count lines even when called from inside a menu
-
-  if (! grub_open (arg))
-    return 1;
-
-  while (grub_read (&amp;c, 1))
-    {
-      /* Because running &quot;cat&quot; with a binary file can confuse the terminal,
-	 print only some characters as they are.  */
-      //if (isspace (c) || (c &gt;= ' ' &amp;&amp; c &lt;= '~'))
-	grub_putchar (c);
-      //else
-	//grub_putchar ('?');
-    }
-  
-  grub_close ();
-count_lines=temporal_count_lines; // Restore value of count_lines
-}
-  return 0;
-}
-
-static struct builtin builtin_cat =
-{
-  &quot;cat&quot;,
-  cat_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;cat FILE&quot;,
-  &quot;Print the contents of the file FILE.&quot;
-};
-/* catis [on|off] */
-static int
-catis_func (char *arg, int flags)
-{
-  /* If ARG is empty, toggle the flag.  */
-  if (! *arg)
-    cat_is_on = ! cat_is_on;
-  else if (grub_memcmp (arg, &quot;on&quot;, 2) == 0)
-    cat_is_on = 1;
-  else if (grub_memcmp (arg, &quot;off&quot;, 3) == 0)
-    cat_is_on = 0;
-  else
-    {
-      errnum = ERR_BAD_ARGUMENT;
-      return 1;
-    }
-
-  //grub_printf (&quot; Internal pager is now %s\n&quot;, cat_is_on ? &quot;on&quot; : &quot;off&quot;); // We do not want to cat anything at all.
-  return 0;
-}
-
-static struct builtin builtin_catis =
-{
-  &quot;catis&quot;,
-  catis_func,
-  BUILTIN_CMDLINE | BUILTIN_MENU,
-  &quot;catis [FLAG]&quot;,
-  &quot;Toggle cat output mode with no argument. If FLAG is given and its value&quot;
-  &quot; is `on', turn on the mode. If FLAG is `off', turn off the mode.&quot;
-};
-
-/* chainloader */
-static int
-chainloader_func (char *arg, int flags)
-{
-  int force = 0;
-  char *file = arg;
-
-  /* If the option `--force' is specified?  */
-  if (substring (&quot;--force&quot;, arg) &lt;= 0)
-    {
-      force = 1;
-      file = skip_to (0, arg);
-    }
-
-  /* Open the file.  */
-  if (! grub_open (file))
-    {
-      kernel_type = KERNEL_TYPE_NONE;
-      return 1;
-    }
-
-  /* Read the first block.  */
-  if (grub_read ((char *) BOOTSEC_LOCATION, SECTOR_SIZE) != SECTOR_SIZE)
-    {
-      grub_close ();
-      kernel_type = KERNEL_TYPE_NONE;
-
-      /* This below happens, if a file whose size is less than 512 bytes
-	 is loaded.  */
-      if (errnum == ERR_NONE)
-	errnum = ERR_EXEC_FORMAT;
-      
-      return 1;
-    }
-
-  /* If not loading it forcibly, check for the signature.  */
-  if (! force
-      &amp;&amp; (*((unsigned short *) (BOOTSEC_LOCATION + BOOTSEC_SIG_OFFSET))
-	  != BOOTSEC_SIGNATURE))
-    {
-      grub_close ();
-      errnum = ERR_EXEC_FORMAT;
-      kernel_type = KERNEL_TYPE_NONE;
-      return 1;
-    }
-
-  grub_close ();
-  kernel_type = KERNEL_TYPE_CHAINLOADER;
-
-  /* XXX: Windows evil hack. For now, only the first five letters are
-     checked.  */
-  if (IS_PC_SLICE_TYPE_FAT (current_slice)
-      &amp;&amp; ! grub_memcmp ((char *) BOOTSEC_LOCATION + BOOTSEC_BPB_SYSTEM_ID,
-			&quot;MSWIN&quot;, 5))
-    *((unsigned long *) (BOOTSEC_LOCATION + BOOTSEC_BPB_HIDDEN_SECTORS))
-      = part_start;
-
-  errnum = ERR_NONE;
-  
-  return 0;
-}
-
-static struct builtin builtin_chainloader =
-{
-  &quot;chainloader&quot;,
-  chainloader_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;chainloader [--force] FILE&quot;,
-  &quot;Load the chain-loader FILE. If --force is specified, then load it&quot;
-  &quot; forcibly, whether the boot loader signature is present or not.&quot;
-};
-
-// let's comment cmp_func - adrian15 - it is not very useful
-/* This function could be used to debug new filesystem code. Put a file
-   in the new filesystem and the same file in a well-tested filesystem.
-   Then, run &quot;cmp&quot; with the files. If no output is obtained, probably
-   the code is good, otherwise investigate what's wrong...  */
-/* cmp FILE1 FILE2 
-static int
-cmp_func (char *arg, int flags)
-{
-  // The filenames.  
-  char *file1, *file2;
-  // The addresses.  
-  char *addr1, *addr2;
-  int i;
-  // The size of the file.  
-  int size;
-
-  // Get the filenames from ARG.  
-  file1 = arg;
-  file2 = skip_to (0, arg);
-  if (! *file1 || ! *file2)
-    {
-      errnum = ERR_BAD_ARGUMENT;
-      return 1;
-    }
-
-  // Terminate the filenames for convenience.  
-  nul_terminate (file1);
-  nul_terminate (file2);
-
-  // Read the whole data from FILE1.  
-  addr1 = (char *) RAW_ADDR (0x100000);
-  if (! grub_open (file1))
-    return 1;
-  
-  // Get the size.  
-  size = filemax;
-  if (grub_read (addr1, -1) != size)
-    {
-      grub_close ();
-      return 1;
-    }
-  
-  grub_close ();
-
-  // Read the whole data from FILE2.  
-  addr2 = addr1 + size;
-  if (! grub_open (file2))
-    return 1;
-
-  // Check if the size of FILE2 is equal to the one of FILE2.  
-  if (size != filemax)
-    {
-      grub_printf (&quot;Differ in size: 0x%x [%s], 0x%x [%s]\n&quot;,
-		   size, file1, filemax, file2);
-      grub_close ();
-      return 0;
-    }
-  
-  if (! grub_read (addr2, -1))
-    {
-      grub_close ();
-      return 1;
-    }
-  
-  grub_close ();
-
-  // Now compare ADDR1 with ADDR2.  
-  for (i = 0; i &lt; size; i++)
-    {
-      if (addr1[i] != addr2[i])
-	grub_printf (&quot;Differ at the offset %d: 0x%x [%s], 0x%x [%s]\n&quot;,
-		     i, (unsigned) addr1[i], file1,
-		     (unsigned) addr2[i], file2);
-    }
-  
-  return 0;
-}
-
-static struct builtin builtin_cmp =
-{
-  &quot;cmp&quot;,
-  cmp_func,
-  BUILTIN_CMDLINE,
-  &quot;cmp FILE1 FILE2&quot;,
-  &quot;Compare the file FILE1 with the FILE2 and inform the different values&quot;
-  &quot; if any.&quot;
-};
-*/
-
-/* color */
-/* Set new colors used for the menu interface. Support two methods to
-   specify a color name: a direct integer representation and a symbolic
-   color name. An example of the latter is &quot;blink-light-gray/blue&quot;.  */
-static int
-color_func (char *arg, int flags)
-{
-  char *normal;
-  char *highlight;
-  int new_normal_color;
-  int new_highlight_color;
-  static char *color_list[16] =
-  {
-    &quot;black&quot;,
-    &quot;blue&quot;,
-    &quot;green&quot;,
-    &quot;cyan&quot;,
-    &quot;red&quot;,
-    &quot;magenta&quot;,
-    &quot;brown&quot;,
-    &quot;light-gray&quot;,
-    &quot;dark-gray&quot;,
-    &quot;light-blue&quot;,
-    &quot;light-green&quot;,
-    &quot;light-cyan&quot;,
-    &quot;light-red&quot;,
-    &quot;light-magenta&quot;,
-    &quot;yellow&quot;,
-    &quot;white&quot;
-  };
-
-  auto int color_number (char *str);
-  
-  /* Convert the color name STR into the magical number.  */
-  auto int color_number (char *str)
-    {
-      char *ptr;
-      int i;
-      int color = 0;
-      
-      /* Find the separator.  */
-      for (ptr = str; *ptr &amp;&amp; *ptr != '/'; ptr++)
-	;
-
-      /* If not found, return -1.  */
-      if (! *ptr)
-	return -1;
-
-      /* Terminate the string STR.  */
-      *ptr++ = 0;
-
-      /* If STR contains the prefix &quot;blink-&quot;, then set the `blink' bit
-	 in COLOR.  */
-      if (substring (&quot;blink-&quot;, str) &lt;= 0)
-	{
-	  color = 0x80;
-	  str += 6;
-	}
-      
-      /* Search for the color name.  */
-      for (i = 0; i &lt; 16; i++)
-	if (grub_strcmp (color_list[i], str) == 0)
-	  {
-	    color |= i;
-	    break;
-	  }
-
-      if (i == 16)
-	return -1;
-
-      str = ptr;
-      nul_terminate (str);
-
-      /* Search for the color name.  */      
-      for (i = 0; i &lt; 8; i++)
-	if (grub_strcmp (color_list[i], str) == 0)
-	  {
-	    color |= i &lt;&lt; 4;
-	    break;
-	  }
-
-      if (i == 8)
-	return -1;
-
-      return color;
-    }
-      
-  normal = arg;
-  highlight = skip_to (0, arg);
-
-  new_normal_color = color_number (normal);
-  if (new_normal_color &lt; 0 &amp;&amp; ! safe_parse_maxint (&amp;normal, &amp;new_normal_color))
-    return 1;
-  
-  /* The second argument is optional, so set highlight_color
-     to inverted NORMAL_COLOR.  */
-  if (! *highlight)
-    new_highlight_color = ((new_normal_color &gt;&gt; 4)
-			   | ((new_normal_color &amp; 0xf) &lt;&lt; 4));
-  else
-    {
-      new_highlight_color = color_number (highlight);
-      if (new_highlight_color &lt; 0
-	  &amp;&amp; ! safe_parse_maxint (&amp;highlight, &amp;new_highlight_color))
-	return 1;
-    }
-
-  if (current_term-&gt;setcolor)
-    current_term-&gt;setcolor (new_normal_color, new_highlight_color);
-  
-  return 0;
-}
-
-static struct builtin builtin_color =
-{
-  &quot;color&quot;,
-  color_func,
-  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
-  &quot;color NORMAL [HIGHLIGHT]&quot;,
-  &quot;Change the menu colors. The color NORMAL is used for most&quot;
-  &quot; lines in the menu, and the color HIGHLIGHT is used to highlight the&quot;
-  &quot; line where the cursor points. If you omit HIGHLIGHT, then the&quot;
-  &quot; inverted color of NORMAL is used for the highlighted line.&quot;
-  &quot; The format of a color is \&quot;FG/BG\&quot;. FG and BG are symbolic color names.&quot;
-  &quot; A symbolic color name must be one of these: black, blue, green,&quot;
-  &quot; cyan, red, magenta, brown, light-gray, dark-gray, light-blue,&quot;
-  &quot; light-green, light-cyan, light-red, light-magenta, yellow and white.&quot;
-  &quot; But only the first eight names can be used for BG. You can prefix&quot;
-  &quot; \&quot;blink-\&quot; to FG if you want a blinking foreground color.&quot;
-};
-
-
-/* configfile */
-static int
-configfile_func (char *arg, int flags)
-{
-  char *new_config = config_file;
-
-  /* Check if the file ARG is present.  */
-  if (! grub_open (arg))
-    return 1;
-
-  grub_close ();
-  
-  /* Copy ARG to CONFIG_FILE.  */
-  while ((*new_config++ = *arg++) != 0)
-    ;
-
-// menu_array config_file value has to be updated when loading a new file
-      memmove(menu_array[menu_level].config_file,	// TO
-      config_file,					// FROM
-      128);						//SIZE
-
-
-  configfile_end();
-
-  /* Never reach here.  */
-  return 0;
-}
-
-static struct builtin builtin_configfile =
-{
-  &quot;configfile&quot;,
-  configfile_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;configfile FILE&quot;,
-  &quot;Load FILE as the configuration file.&quot;
-};
-
-
-
-
-/* default */
-static int
-default_func (char *arg, int flags)
-{
-#ifndef SUPPORT_DISKLESS
-  if (grub_strcmp (arg, &quot;saved&quot;) == 0)
-    {
-      default_entry = saved_entryno;
-      return 0;
-    }
-#endif /* SUPPORT_DISKLESS */
-  
-  if (! safe_parse_maxint (&amp;arg, &amp;default_entry))
-    return 1;
-
-  return 0;
-}
-
-static struct builtin builtin_default =
-{
-  &quot;default&quot;,
-  default_func,
-  BUILTIN_MENU,
-#if 0
-  &quot;default [NUM | `saved']&quot;,
-  &quot;Set the default entry to entry number NUM (if not specified, it is&quot;
-  &quot; 0, the first entry) or the entry number saved by savedefault.&quot;
-#endif
-};
-
-
-#ifdef GRUB_UTIL
-/* device */
-static int
-device_func (char *arg, int flags)
-{
-  char *drive = arg;
-  char *device;
-
-  /* Get the drive number from DRIVE.  */
-  if (! set_device (drive))
-    return 1;
-
-  /* Get the device argument.  */
-  device = skip_to (0, drive);
-  
-  /* Terminate DEVICE.  */
-  nul_terminate (device);
-
-  if (! *device || ! check_device (device))
-    {
-      errnum = ERR_FILE_NOT_FOUND;
-      return 1;
-    }
-
-  assign_device_name (current_drive, device);
-  
-  return 0;
-}
-
-static struct builtin builtin_device =
-{
-  &quot;device&quot;,
-  device_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;device DRIVE DEVICE&quot;,
-  &quot;Specify DEVICE as the actual drive for a BIOS drive DRIVE. This command&quot;
-  &quot; can be used only in the grub shell.&quot;
-};
-#endif /* GRUB_UTIL */
-
-
-
-/* displayapm  // Removed displayapm because SGD does not need it.
-static int
-displayapm_func (char *arg, int flags)
-{
-  if (mbi.flags &amp; MB_INFO_APM_TABLE)
-    {
-      grub_printf (&quot;APM BIOS information:\n&quot;
-		   &quot; Version:          0x%x\n&quot;
-		   &quot; 32-bit CS:        0x%x\n&quot;
-		   &quot; Offset:           0x%x\n&quot;
-		   &quot; 16-bit CS:        0x%x\n&quot;
-		   &quot; 16-bit DS:        0x%x\n&quot;
-		   &quot; 32-bit CS length: 0x%x\n&quot;
-		   &quot; 16-bit CS length: 0x%x\n&quot;
-		   &quot; 16-bit DS length: 0x%x\n&quot;,
-		   (unsigned) apm_bios_info.version,
-		   (unsigned) apm_bios_info.cseg,
-		   apm_bios_info.offset,
-		   (unsigned) apm_bios_info.cseg_16,
-		   (unsigned) apm_bios_info.dseg_16,
-		   (unsigned) apm_bios_info.cseg_len,
-		   (unsigned) apm_bios_info.cseg_16_len,
-		   (unsigned) apm_bios_info.dseg_16_len);
-    }
-  else
-    {
-      grub_printf (&quot;No APM BIOS found or probe failed\n&quot;);
-    }
-
-  return 0;
-}
-
-static struct builtin builtin_displayapm =
-{
-  &quot;displayapm&quot;,
-  displayapm_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;displayapm&quot;,
-  &quot;Display APM BIOS information.&quot;
-};
-*/
-
-/* displaymem // Display mem removed. We do not need it in SGD
-static int
-displaymem_func (char *arg, int flags)
-{
-  if (get_eisamemsize () != -1)
-    grub_printf (&quot; EISA Memory BIOS Interface is present\n&quot;);
-  if (get_mmap_entry ((void *) SCRATCHADDR, 0) != 0
-      || *((int *) SCRATCHADDR) != 0)
-    grub_printf (&quot; Address Map BIOS Interface is present\n&quot;);
-
-  grub_printf (&quot; Lower memory: %uK, &quot;
-	       &quot;Upper memory (to first chipset hole): %uK\n&quot;,
-	       mbi.mem_lower, mbi.mem_upper);
-
-  if (mbi.flags &amp; MB_INFO_MEM_MAP)
-    {
-      struct AddrRangeDesc *map = (struct AddrRangeDesc *) mbi.mmap_addr;
-      int end_addr = mbi.mmap_addr + mbi.mmap_length;
-
-      grub_printf (&quot; [Address Range Descriptor entries &quot;
-		   &quot;immediately follow (values are 64-bit)]\n&quot;);
-      while (end_addr &gt; (int) map)
-	{
-	  char *str;
-
-	  if (map-&gt;Type == MB_ARD_MEMORY)
-	    str = &quot;Usable RAM&quot;;
-	  else
-	    str = &quot;Reserved&quot;;
-	  grub_printf (&quot;   %s:  Base Address:  0x%x X 4GB + 0x%x,\n&quot;
-		       &quot;      Length:   0x%x X 4GB + 0x%x bytes\n&quot;,
-		       str,
-		       (unsigned long) (map-&gt;BaseAddr &gt;&gt; 32),
-		       (unsigned long) (map-&gt;BaseAddr &amp; 0xFFFFFFFF),
-		       (unsigned long) (map-&gt;Length &gt;&gt; 32),
-		       (unsigned long) (map-&gt;Length &amp; 0xFFFFFFFF));
-
-	  map = ((struct AddrRangeDesc *) (((int) map) + 4 + map-&gt;size));
-	}
-    }
-
-  return 0;
-}
-
-static struct builtin builtin_displaymem =
-{
-  &quot;displaymem&quot;,
-  displaymem_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;displaymem&quot;,
-  &quot;Display what GRUB thinks the system address space map of the&quot;
-  &quot; machine is, including all regions of physical RAM installed.&quot;
-};
-*/
-
-
-/* notzero */
-
-static int
-notzero_func (char *arg, int flags)
-{
-
-/* Place to put variables - Begin */
-int current_size_read, notzero;
-/* Auxiliar variables - Begin */
-char *read_and_write_buffer = (char *) RAW_ADDR (0x100000);
-int source_sector_number;
-
-/* Auxiliar variables - End */
-/* Parse variables - Begin */
-char *source_device, *auxiliar_char_pointer;
-int source_offset, size_to_dd;
-/* Parse variables - End */
-/* Place to put variables - End */
-
-
-/* Parse arguments - Begin */
-/* Parse source device */
-source_device = arg;
-arg = skip_to (0,arg);
-nul_terminate(source_device);
-
-/* Parse source offset */
-auxiliar_char_pointer = arg;
-arg = skip_to (0,arg);
-if ( ! safe_parse_maxint (&amp;auxiliar_char_pointer, &amp;source_offset) ) return 1;
-/* Parse size */
-auxiliar_char_pointer = arg;
-arg = skip_to (0,arg);
-if ( ! safe_parse_maxint (&amp;auxiliar_char_pointer, &amp;size_to_dd) ) return 1;
-/* Parse arguments - End */
-/* Main algorithm - Begin */
-
-source_sector_number = (int)((source_offset) / SECTOR_SIZE );
-
-		if (! set_device (source_device)
-				    || ! open_partition ()
-				    || ! devread (source_sector_number,0,size_to_dd,read_and_write_buffer))
-		return 0 ; // Simulate goto ddfail;
-/* Read from source - End */
-	
-notzero = 0; // Let's suppose everyone of them is 0.
-current_size_read = 0;
-while ( (current_size_read &lt; size_to_dd) &amp;&amp; (! notzero) ) {
-  if (read_and_write_buffer[current_size_read]) notzero = 1;
-  current_size_read++;
-} // End of while
-
-if (notzero) return 0 ; else {
-     errnum = ERR_FILE_NOT_FOUND;
-     return 1;
-}
-
-return 0; //Everything is OK
-
-}
-
-static struct builtin builtin_notzero =
-{
-  &quot;notzero&quot;,
-  notzero_func,
-  BUILTIN_CMDLINE,
-  &quot;notzero PARTITION PARTITION_BEGIN_OFFSET SIZE&quot;,
-  &quot;Tell me if SIZE bytes\n&quot;
-  &quot;FROM: PARTITION beginning at PARTITION_BEGIN_OFFSET\n&quot;
-  &quot;are not all zeroes. If all of them are zeroes give an error.\n&quot;
-};
-
-
-/* dddd */
-
-static int
-dddd_func (char *arg, int flags)
-{
-
-/* Place to put variables - Begin */
-int current_size_read = 0;
-/* Auxiliar variables - Begin */
-char *read_and_write_buffer = (char *) RAW_ADDR (0x100000);
-int source_sector_number, destination_size_to_read,destination_sector_number, actual_destination_offset;
-
-/* Auxiliar variables - End */
-/* Parse variables - Begin */
-char *source_device, *destination_device, *auxiliar_char_pointer;
-int source_offset, destination_offset, size_to_dd;
-/* Parse variables - End */
-/* Place to put variables - End */
-
-	auto int destination_read_the_hard_disk_sector(void);
-
-	auto int destination_read_the_hard_disk_sector(void)
-	{
-		if (! set_device (destination_device)
-				    || ! open_partition ()
-				    || ! devread (destination_sector_number,0,SECTOR_SIZE,read_and_write_buffer))
-		return 0 ; // Simulate goto ddfail;
-			
-		return 1; // Do not do the goto ddfail;
-	}
-
-
-
-/* Parse arguments - Begin */
-/* Parse source device */
-source_device = arg;
-arg = skip_to (0,arg);
-nul_terminate(source_device);
-
-/* Parse destination device */
-destination_device = arg;
-arg = skip_to (0,arg);
-nul_terminate(destination_device);
-
-/* Parse source offset */
-auxiliar_char_pointer = arg;
-arg = skip_to (0,arg);
-if ( ! safe_parse_maxint (&amp;auxiliar_char_pointer, &amp;source_offset) ) return 1;
-/* Parse destination offset */
-auxiliar_char_pointer = arg;
-arg = skip_to (0,arg);
-if ( ! safe_parse_maxint (&amp;auxiliar_char_pointer, &amp;destination_offset) ) return 1;
-/* Parse size */
-auxiliar_char_pointer = arg;
-arg = skip_to (0,arg);
-if ( ! safe_parse_maxint (&amp;auxiliar_char_pointer, &amp;size_to_dd) ) return 1;
-/* Parse arguments - End */
-/* Main algorithm - Begin */
-/* Prepare data - Begin */
-current_size_read = 0;
-/* Prepare data - End */
-
-/* Main While - Begin */
-
-  //  Calculate actual_destination_offset
-  if (destination_offset &lt; SECTOR_SIZE)  actual_destination_offset = destination_offset ;
-  else	actual_destination_offset = destination_offset % SECTOR_SIZE;
-while ( current_size_read &lt; size_to_dd ) {
-  
-  destination_sector_number = (int)((destination_offset + current_size_read) / SECTOR_SIZE ); // Let's hope that / works the same way as trunc
-  
-  
-  /* Case :0 : 1st part of the sector without changes. 2nd part from the file. 3rd part without changes. */
- if (size_to_dd &lt; SECTOR_SIZE) {
-	if (!(destination_read_the_hard_disk_sector())) return 1;	
-	destination_size_to_read=size_to_dd;
-	auxiliar_char_pointer=read_and_write_buffer+actual_destination_offset;
-  } else
-  {
-/* Case : 1 : 1st part of the sector without changes. 2nd part read from the file */
-  if ((current_size_read==0) &amp;&amp; (actual_destination_offset)) {
-	  if (!(destination_read_the_hard_disk_sector())) return 1;	
-	  destination_size_to_read=SECTOR_SIZE - actual_destination_offset;
-	  auxiliar_char_pointer=read_and_write_buffer+actual_destination_offset;	
-	  /* Case 2: 1st part of the sector read from the file. 2nd part without changes. */
-  } else {
-	  auxiliar_char_pointer=read_and_write_buffer;
-	  if ((current_size_read + SECTOR_SIZE)&gt;size_to_dd) {
-		  if (!(destination_read_the_hard_disk_sector())) return 1;	
-		  /* Let's contemplate the case destination offset: 0 and size_to_dd &lt; SECTOR_SIZE */
-		  if (!(actual_destination_offset)) destination_size_to_read = size_to_dd;
-		  else destination_size_to_read=actual_destination_offset;
-		  /* Case 3: All the sector read from the file */
-	  } else {
-		  /* NO NEED TO READ THE HARD DISK SECTOR FIRST */
-		  destination_size_to_read=SECTOR_SIZE;
-	  }
-  }
-  }
-
-/* Read from source - Begin */
-
-
-source_sector_number = (int)((source_offset + current_size_read) / SECTOR_SIZE );
-
-		if (! set_device (source_device)
-				    || ! open_partition ()
-				    || ! devread (source_sector_number,0,destination_size_to_read,read_and_write_buffer))
-		return 0 ; // Simulate goto ddfail;
-/* Read from source - End */
-	
-/* Write to device - Begin */
-	if ( ! set_device (destination_device)
-		|| ! open_partition ()
-		|| ! devwrite (destination_sector_number,1,read_and_write_buffer))
-		return 0; // ERROR
-/* Write to device - End */
-
-current_size_read += destination_size_to_read;
-} // End of while
-/* Main While - End */
-
-return 0; //Everything is OK
-
-}
-
-static struct builtin builtin_dddd =
-{
-  &quot;dddd&quot;,
-  dddd_func,
-  BUILTIN_CMDLINE,
-  &quot;dddd SOURCE_DEVICE DESTINATION_DEVICE SOURCE_OFFSET DESTINATION_OFFSET SIZE&quot;,
-  &quot;Copy SIZE bytes\n&quot;
-  &quot;FROM: SOURCE_DEVICE beginning at SOURCE_OFFSET\n&quot;
-  &quot;TO: DESTINATION_DEVICE beginning at DESTINATION_OFFSET.\n&quot;
-};
-
-/* dd */
-static int
-dd_func (char *arg, int flags)
-{
-
-	
-/* Place to put variables - Begin */
-int current_size_read = 0;
-/* Auxiliar variables - Begin */
-int device_sector_number, size_to_read, actual_device_offset;
-char *read_and_write_buffer = (char *) RAW_ADDR (0x100000);
-
-int file_drive,	file_partition, file_sector;
-struct geometry file_geom;
-/* Auxiliar variables - End */
-/* Parse variables - Begin */
-char *source_filename, *destination_device, *auxiliar_char_pointer;
-int file_offset, device_offset, size_to_dd;
-/* Parse variables - End */
-/* Place to put variables - End */
-
-	auto void restore_file_values(void);
-	auto void backup_file_values(void);
-	auto int read_the_hard_disk_sector(void);
- 
-	
-	auto void restore_file_values(void)
-	{
-		current_drive = file_drive ;
-		current_partition = file_partition;
-		buf_geom = file_geom;
-		part_start = file_sector;
-	}
-
-	auto void backup_file_values(void)
-	{
-		file_drive = current_drive;
-		file_partition = current_partition;
-		file_geom = buf_geom;
-		file_sector = part_start;
-	}
-
-	auto int read_the_hard_disk_sector(void)
-	{
-		/* Save READ FILE variables - Begin*/ 
-		backup_file_values();
-		/* Save READ FILE variables - End */	
-		if (! set_device (destination_device)
-				    || ! open_partition ()
-				    || ! devread (device_sector_number,0,SECTOR_SIZE,read_and_write_buffer))
-		return 0 ; // Simulate goto ddfail;
-			
-		/* Restore READ FILE variables - Begin*/
-		restore_file_values();
-		/* Restore READ FILE variables - End */
-		return 1; // Do not do the goto ddfail;
-	}
-	
-	
-int is_open = 0;
-
-/* Parse arguments - Begin */
-/* Parse filename */
-source_filename = arg;
-arg = skip_to (0,arg);
-nul_terminate(source_filename);
-
-/* Parse device */
-destination_device = arg;
-arg = skip_to (0,arg);
-nul_terminate(destination_device);
-/* Parse file offset */
-auxiliar_char_pointer = arg;
-arg = skip_to (0,arg);
-if ( ! safe_parse_maxint (&amp;auxiliar_char_pointer, &amp;file_offset) ) return 1;
-/* Parse device offset */
-auxiliar_char_pointer = arg;
-arg = skip_to (0,arg);
-if ( ! safe_parse_maxint (&amp;auxiliar_char_pointer, &amp;device_offset) ) return 1;
-/* Parse size */
-auxiliar_char_pointer = arg;
-arg = skip_to (0,arg);
-if ( ! safe_parse_maxint (&amp;auxiliar_char_pointer, &amp;size_to_dd) ) return 1;
-/* Parse arguments - End */
-/* Main algorithm - Begin */
-/* Prepare data - Begin */
-current_size_read = 0;
-/* Prepare data - End */
-is_open = grub_open (source_filename);
-/* Main While - Begin */
-
-  //  Calculate actual_device_offset
-  if (device_offset &lt; SECTOR_SIZE)  actual_device_offset = device_offset ;
-  else	actual_device_offset = device_offset % SECTOR_SIZE;
-while ( current_size_read &lt; size_to_dd ) {
-  grub_seek (file_offset+current_size_read);
-  device_sector_number = (int)((device_offset + current_size_read) / SECTOR_SIZE ); // Let's hope that / works the same way as trunc
-  
-  
-  /* Case :0 : 1st part of the sector without changes. 2nd part from the file. 3rd part without changes. */
- if (size_to_dd &lt; SECTOR_SIZE) {
-	if (!(read_the_hard_disk_sector())) goto ddfail;	
-	size_to_read=size_to_dd;
-	auxiliar_char_pointer=read_and_write_buffer+actual_device_offset;
-  } else
-  {
-/* Case : 1 : 1st part of the sector without changes. 2nd part read from the file */
-  if ((current_size_read==0) &amp;&amp; (actual_device_offset)) {
-	  if (!(read_the_hard_disk_sector())) goto ddfail;	
-	  size_to_read=SECTOR_SIZE - actual_device_offset;
-	  auxiliar_char_pointer=read_and_write_buffer+actual_device_offset;	
-	  /* Case 2: 1st part of the sector read from the file. 2nd part without changes. */
-  } else {
-	  auxiliar_char_pointer=read_and_write_buffer;
-	  if ((current_size_read + SECTOR_SIZE)&gt;size_to_dd) {
-		  if (!(read_the_hard_disk_sector())) goto ddfail;	
-		  /* Let's contemplate the case device offset: 0 and size_to_dd &lt; SECTOR_SIZE */
-		  if (!(actual_device_offset)) size_to_read = size_to_dd;
-		  else size_to_read=actual_device_offset;
-		  /* Case 3: All the sector read from the file */
-	  } else {
-		  /* NO NEED TO READ THE HARD DISK SECTOR FIRST */
-		  size_to_read=SECTOR_SIZE;
-	  }
-  }
-  }
-
-/* Read from file - Begin */
-
-if ( (! grub_read (auxiliar_char_pointer,size_to_read)==size_to_read)
-	|| (!is_open)) goto ddfail;
-/* Read from file - End */
-	  /* Save READ FILE variables - Begin*/
-	backup_file_values();
-	  /* Save READ FILE variables - End */	
-/* Write to device - Begin */
-	if ( ! set_device (destination_device)
-		|| ! open_partition ()
-		|| ! devwrite (device_sector_number,1,read_and_write_buffer))
-		goto ddfail;
-	  /* Restore READ FILE variables - Begin*/
-	restore_file_values();
-	  /* Restore READ FILE variables - End */
-/* Write to device - End */
-
-current_size_read += size_to_read;
-} // End of while
-/* Main While - End */
-  /* If there's an error: */
-
-
-
- ddfail:
-  if (is_open)
-    grub_close ();
-  
-  disk_read_hook = 0;
-  
-#ifndef NO_DECOMPRESSION
-  no_decompression = 0;
-#endif
-
-  return errnum;
-
-
-
-}
-
-static struct builtin builtin_dd =
-{
-  &quot;dd&quot;,
-  dd_func,
-  BUILTIN_CMDLINE,
-  &quot;dd SOURCE_FILE DESTINATION_DEVICE FILE_OFFSET DEVICE_OFFSET SIZE&quot;,
-  &quot;Copy SIZE bytes\n&quot;
-  &quot;FROM: SOURCE_FILE beginning at FILE_OFFSET\n&quot;
-  &quot;TO: DESTINATION_DEVICE beginning at DEVICE_OFFSET.\n&quot;
-};
-
-
-/* dump FROM TO */
-#ifdef GRUB_UTIL
-static int
-dump_func (char *arg, int flags)
-{
-  char *from, *to;
-  FILE *fp;
-  char c;
-  
-  from = arg;
-  to = skip_to (0, arg);
-  if (! *from || ! *to)
-    {
-      errnum = ERR_BAD_ARGUMENT;
-      return 1;
-    }
-
-  nul_terminate (from);
-  nul_terminate (to);
-  
-  if (! grub_open (from))
-    return 1;
-
-  fp = fopen (to, &quot;w&quot;);
-  if (! fp)
-    {
-      errnum = ERR_WRITE;
-      return 1;
-    }
-
-  while (grub_read (&amp;c, 1))
-    if (fputc (c, fp) == EOF)
-      {
-	errnum = ERR_WRITE;
-	fclose (fp);
-	return 1;
-      }
-
-  if (fclose (fp) == EOF)
-    {
-      errnum = ERR_WRITE;
-      return 1;
-    }
-
-  grub_close ();
-  return 0;
-}
-
-static struct builtin builtin_dump =
-  {
-    &quot;dump&quot;,
-    dump_func,
-    BUILTIN_CMDLINE,
-    &quot;dump FROM TO&quot;,
-    &quot;Dump the contents of the file FROM to the file TO. FROM must be&quot;
-    &quot; a GRUB file and TO must be an OS file.&quot;
-  };
-#endif /* GRUB_UTIL */
-
-
-static char embed_info[32];
-/* embed */
-/* Embed a Stage 1.5 in the first cylinder after MBR or in the
-   bootloader block in a FFS.  */
-static int
-embed_func (char *arg, int flags)
-{
-  char *stage1_5;
-  char *device;
-  char *stage1_5_buffer = (char *) RAW_ADDR (0x100000);
-  int len, size;
-  int sector;
-  
-  stage1_5 = arg;
-  device = skip_to (0, stage1_5);
-
-  /* Open a Stage 1.5.  */
-  if (! grub_open (stage1_5))
-    return 1;
-
-  /* Read the whole of the Stage 1.5.  */
-  len = grub_read (stage1_5_buffer, -1);
-  grub_close ();
-  
-  if (errnum)
-    return 1;
-  
-  size = (len + SECTOR_SIZE - 1) / SECTOR_SIZE;
-  
-  /* Get the device where the Stage 1.5 will be embedded.  */
-  set_device (device);
-  if (errnum)
-    return 1;
-
-  if (current_partition == 0xFFFFFF)
-    {
-      /* Embed it after the MBR.  */
-      
-      char mbr[SECTOR_SIZE];
-      char ezbios_check[2*SECTOR_SIZE];
-      int i;
-      
-      /* Open the partition.  */
-      if (! open_partition ())
-	return 1;
-
-      /* No floppy has MBR.  */
-      if (! (current_drive &amp; 0x80))
-	{
-	  errnum = ERR_DEV_VALUES;
-	  return 1;
-	}
-      
-      /* Read the MBR of CURRENT_DRIVE.  */
-      if (! rawread (current_drive, PC_MBR_SECTOR, 0, SECTOR_SIZE, mbr))
-	return 1;
-      
-      /* Sanity check.  */
-      if (! PC_MBR_CHECK_SIG (mbr))
-	{
-	  errnum = ERR_BAD_PART_TABLE;
-	  return 1;
-	}
-
-      /* Check if the disk can store the Stage 1.5.  */
-      for (i = 0; i &lt; 4; i++)
-	if (PC_SLICE_TYPE (mbr, i) &amp;&amp; PC_SLICE_START (mbr, i) - 1 &lt; size)
-	  {
-	    errnum = ERR_NO_DISK_SPACE;
-	    return 1;
-	  }
-      
-      /* Check for EZ-BIOS signature. It should be in the third
-       * sector, but due to remapping it can appear in the second, so
-       * load and check both.  
-       */
-      if (! rawread (current_drive, 1, 0, 2 * SECTOR_SIZE, ezbios_check))
-	return 1;
-
-      if (! memcmp (ezbios_check + 3, &quot;AERMH&quot;, 5)
-	  || ! memcmp (ezbios_check + 512 + 3, &quot;AERMH&quot;, 5))
-	{
-	  /* The space after the MBR is used by EZ-BIOS which we must 
-	   * not overwrite.
-	   */
-	  errnum = ERR_NO_DISK_SPACE;
-	  return 1;
-	}
-
-      sector = 1;
-    }
-  else
-    {
-      /* Embed it in the bootloader block in the filesystem.  */
-      int start_sector;
-      
-      /* Open the partition.  */
-      if (! open_device ())
-	return 1;
-
-      /* Check if the current slice supports embedding.  */
-      if (fsys_table[fsys_type].embed_func == 0
-	  || ! fsys_table[fsys_type].embed_func (&amp;start_sector, size))
-	{
-	  errnum = ERR_DEV_VALUES;
-	  return 1;
-	}
-
-      sector = part_start + start_sector;
-    }
-
-  /* Clear the cache.  */
-  buf_track = -1;
-
-  /* Now perform the embedding.  */
-  if (! devwrite (sector - part_start, size, stage1_5_buffer))
-    return 1;
-  
-  grub_printf (&quot; %d sectors are embedded.\n&quot;, size);
-  grub_sprintf (embed_info, &quot;%d+%d&quot;, sector - part_start, size);
-  return 0;
-}
-
-static struct builtin builtin_embed =
-{
-  &quot;embed&quot;,
-  embed_func,
-  BUILTIN_CMDLINE,
-  &quot;embed STAGE1_5 DEVICE&quot;,
-  &quot;Embed the Stage 1.5 STAGE1_5 in the sectors after MBR if DEVICE&quot;
-  &quot; is a drive, or in the \&quot;bootloader\&quot; area if DEVICE is a FFS partition.&quot;
-  &quot; Print the number of sectors which STAGE1_5 occupies if successful.&quot;
-};
-
-
-/* fallback */
-static int
-fallback_func (char *arg, int flags)
-{
-  int i = 0;
-
-  while (*arg)
-    {
-      int entry;
-      int j;
-      
-      if (! safe_parse_maxint (&amp;arg, &amp;entry))
-	return 1;
-
-      /* Remove duplications to prevent infinite looping.  */
-      for (j = 0; j &lt; i; j++)
-	if (entry == fallback_entries[j])
-	  break;
-      if (j != i)
-	continue;
-      
-      fallback_entries[i++] = entry;
-      if (i == MAX_FALLBACK_ENTRIES)
-	break;
-      
-      arg = skip_to (0, arg);
-    }
-
-  if (i &lt; MAX_FALLBACK_ENTRIES)
-    fallback_entries[i] = -1;
-
-  fallback_entryno = (i == 0) ? -1 : 0;
-  
-  return 0;
-}
-
-static struct builtin builtin_fallback =
-{
-  &quot;fallback&quot;,
-  fallback_func,
-  BUILTIN_MENU,
-#if 0
-  &quot;fallback NUM...&quot;,
-  &quot;Go into unattended boot mode: if the default boot entry has any&quot;
-  &quot; errors, instead of waiting for the user to do anything, it&quot;
-  &quot; immediately starts over using the NUM entry (same numbering as the&quot;
-  &quot; `default' command). This obviously won't help if the machine&quot;
-  &quot; was rebooted by a kernel that GRUB loaded.&quot;
-#endif
-};
-
-/* fexists */
-static int
-fexists_func (char *arg, int flags)
-{
-  
-  if (! grub_open (arg))
-    return 1;
-
-  grub_close ();
-  return 0;
-}
-
-static struct builtin builtin_fexists =
-{
-  &quot;fexists&quot;,
-  fexists_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;fexists FILE&quot;,
-  &quot;Gives an error if FILE does not exists for grub.&quot;
-  &quot;Exists successfully if the file exists.&quot;
-  &quot;It is useful when used in conjunction with default and fallback commands.&quot;
-};
-
-
-/* find */
-/* Search for the filename ARG in all of partitions.  */
-static int
-find_func (char *arg, int flags)
-{
-  char *filename = arg;
-  unsigned long drive;
-  unsigned long tmp_drive = saved_drive;
-  unsigned long tmp_partition = saved_partition;
-  int got_file = 0;
-  
-  /* Floppies.  */
-  for (drive = 0; drive &lt; 8; drive++)
-    {
-      current_drive = drive;
-      current_partition = 0xFFFFFF;
-      
-      if (open_device ())
-	{
-	  saved_drive = current_drive;
-	  saved_partition = current_partition;
-	  if (grub_open (filename))
-	    {
-	      grub_close ();
-	      grub_printf (&quot; (fd%d)\n&quot;, drive);
-	      got_file = 1;
-	    }
-	}
-
-      errnum = ERR_NONE;
-    }
-
-  /* Hard disks.  */
-  for (drive = 0x80; drive &lt; 0x90; drive++)
-    {
-      unsigned long part = 0xFFFFFF;
-      unsigned long start, len, offset, ext_offset;
-      int type, entry;
-      char buf[SECTOR_SIZE];
-
-      current_drive = drive;
-      while (next_partition (drive, 0xFFFFFF, &amp;part, &amp;type,
-			     &amp;start, &amp;len, &amp;offset, &amp;entry,
-			     &amp;ext_offset, buf))
-	{
-	  if (type != PC_SLICE_TYPE_NONE
-	      &amp;&amp; ! IS_PC_SLICE_TYPE_BSD (type)
-	      &amp;&amp; ! IS_PC_SLICE_TYPE_EXTENDED (type))
-	    {
-	      current_partition = part;
-	      if (open_device ())
-		{
-		  saved_drive = current_drive;
-		  saved_partition = current_partition;
-		  if (grub_open (filename))
-		    {
-		      int bsd_part = (part &gt;&gt; 8) &amp; 0xFF;
-		      int pc_slice = part &gt;&gt; 16;
-		      
-		      grub_close ();
-		      
-		      if (bsd_part == 0xFF)
-			grub_printf (&quot; (hd%d,%d)\n&quot;,
-				     drive - 0x80, pc_slice);
-		      else
-			grub_printf (&quot; (hd%d,%d,%c)\n&quot;,
-				     drive - 0x80, pc_slice, bsd_part + 'a');
-
-		      got_file = 1;
-		    }
-		}
-	    }
-
-	  /* We want to ignore any error here.  */
-	  errnum = ERR_NONE;
-	}
-
-      /* next_partition always sets ERRNUM in the last call, so clear
-	 it.  */
-      errnum = ERR_NONE;
-    }
-
-  saved_drive = tmp_drive;
-  saved_partition = tmp_partition;
-
-  if (got_file)
-    {
-      errnum = ERR_NONE;
-      return 0;
-    }
-
-  errnum = ERR_FILE_NOT_FOUND;
-  return 1;
-}
-
-static struct builtin builtin_find =
-{
-  &quot;find&quot;,
-  find_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;find FILENAME&quot;,
-  &quot;Search for the filename FILENAME in all of partitions and print the list of&quot;
-  &quot; the devices which contain the file.&quot;
-};
-
-
-/* selectpart */
-/* Choose partitions from a hard disk with a menu */
-static int
-selectpart_func (char *arg, int flags)
-{
-
-
-  unsigned long tmp_drive = saved_drive;
-  unsigned long tmp_partition = saved_partition;
-
-
-special_menu = 1; // Force not to read the menu
-
-
-if(add_menu ()) return 1;
-
-
-
-// NEW CODE - BEGIN
-// Add main title
-
-add_choose_title ();
-
-add_part_title ();
-
-set_device (arg); // Saves in current_drive the hard disk
-
-
-      unsigned long part = 0xFFFFFF;
-      unsigned long start, len, offset, ext_offset;
-      int type, entry;
-      char buf[SECTOR_SIZE];
-
-
-
-      while (next_partition (current_drive, 0xFFFFFF, &amp;part, &amp;type,
-			     &amp;start, &amp;len, &amp;offset, &amp;entry,
-			     &amp;ext_offset, buf))
-	{
-
-
-
-	  if (type != PC_SLICE_TYPE_NONE
-	      &amp;&amp; ! IS_PC_SLICE_TYPE_BSD (type)
-	      &amp;&amp; ! IS_PC_SLICE_TYPE_EXTENDED (type))
-	    {
-
-	      current_partition = part;
-		  saved_drive = current_drive;
-		  saved_partition = current_partition;
-
-			
-		
-			add_part_instructions (&amp;type, part, &amp;len);
-			
-			add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;back&quot;);
-			// Close title
-			close_title ((char *) MENU_BUF, &amp;menu_array[menu_level]);
-		
-	    }
-
-	  // We want to ignore any error here.  
-	  errnum = ERR_NONE;
-
-	}
-errnum = ERR_NONE; // We do not want that partition error makes memmove work bad
-close_menu ((char *) MENU_BUF, &amp;menu_array[menu_level]);
-// NEW CODE - END
-
-// Define the new menu - End 
-  saved_drive = tmp_drive;
-  saved_partition = tmp_partition;
-
-
-  configfile_end();
-  // Never reach here.  
-  return 0;
-}
-
-static struct builtin builtin_selectpart =
-{
-  &quot;selectpart&quot;,
-  selectpart_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;selectpart&quot;,
-  &quot;Choose partitions from a hard disk with a menu.&quot;
-};
-
-
-/* selectfile */
-/* Choose partitions from the ones where a file is found with a menu.*/
-static int
-selectfile_func (char *arg, int flags)
-{
-char *filename=arg;
-  unsigned long tmp_drive = saved_drive;
-  unsigned long tmp_partition = saved_partition;
-int got_file = 0;
-int file_entry = 0; // Given a file from the selectfile prompt this variable says in how many partition it has been found
-int drive; // Aux variables
-
-if (there_is_a_hard_disk ()) { errnum = ERR_FILE_NOT_FOUND; return 1; }
-
-
-special_menu = 1; // Force not to read the menu
-
-
-if(add_menu ()) return 1;
-
-
-// NEW CODE - BEGIN
-// Add main title
-add_choose_title ();
-
-add_part_title ();
-
-
-
-while (*arg) {
-
-      filename=arg;
-      arg = skip_to (0,arg); // Iterate over filenames
-      nul_terminate (filename);
-
-      file_entry = 0; // Let's reset file entry
-
-
-
-	buf_drive = GRUB_INVALID_DRIVE; // This line makes possible do the find loop for more than one file
-
-
-
-  for (drive = 0x80; drive &lt; 0x90; drive++) {
-
-      unsigned long part = 0xFFFFFF;
-      unsigned long start, len, offset, ext_offset;
-      int type, entry;
-      char buf[SECTOR_SIZE];
-	current_drive = drive;
-      while (next_partition (current_drive, 0xFFFFFF, &amp;part, &amp;type,
-			     &amp;start, &amp;len, &amp;offset, &amp;entry,
-			     &amp;ext_offset, buf))
-	{
-
-	  if (type != PC_SLICE_TYPE_NONE
-	      &amp;&amp; ! IS_PC_SLICE_TYPE_BSD (type)
-	      &amp;&amp; ! IS_PC_SLICE_TYPE_EXTENDED (type))
-	    {
-
-
-
-	     current_partition = part;
-
-	      if (open_device ())
-		{
-		  saved_drive = current_drive;
-		  saved_partition = current_partition;
-
-		  if (grub_open (filename)) {
-
-			got_file=1;
-			grub_close ();
-			if (file_entry==0) {
-			/* If a first entry has been found put its title */
-			        add_title (&amp;menu_array[menu_level], &quot;vvvvvvvvvv      Select a %s file:       vvvvvvvvvv&quot;,filename);
-				add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;pause vvvvvvvvvv Select below vvvvvvvvv  &quot;);
-				close_title ((char *) MENU_BUF, &amp;menu_array[menu_level]);	
-			}
-			add_part_instructions (&amp;type, part, &amp;len);
-			// File instruction
-			add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_file=%s&quot;,filename);
-
-			add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;back&quot;);
-			// Close title
-			close_title ((char *) MENU_BUF, &amp;menu_array[menu_level]);
-			file_entry++; // We increment the file entry count
-		  }
-		
-	       }
-
-	  // We want to ignore any error here.  
-	  errnum = ERR_NONE;
-
-	  }
-	}
-      /* next_partition always sets ERRNUM in the last call, so clear
-	 it.  */
-      errnum = ERR_NONE;
-
-	} // Hard disks
-errnum = ERR_NONE; // We do not want that partition error makes memmove work bad
-
-
-
-
-
-} // while filename
-
-  if (!got_file)
-    {
-	back_func(&quot;&quot;,1);
-	errnum = ERR_FILE_NOT_FOUND;
-  	return 1;
-    }
-
-
-close_menu ((char *) MENU_BUF, &amp;menu_array[menu_level]);
-// NEW CODE - END
-
-// Define the new menu - End 
-  saved_drive = tmp_drive;
-  saved_partition = tmp_partition;
-
-
-  configfile_end();
-  // Never reach here.  
-  return 0;
-}
-
-static struct builtin builtin_selectfile =
-{
-  &quot;selectfile&quot;,
-  selectfile_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;selectfile&quot;,
-  &quot;Choose partitions from the ones where a file is found with a menu.&quot;
-};
-
-
-
-
-
-
-
-
-
-
-
-
-/* findf */
-/* Search for the filename ARG in all of partitions.  */
-static int
-findf_func (char *arg, int flags)
-{
-  char *filename = arg;
-  unsigned long drive;
-  unsigned long tmp_drive = saved_drive;
-  unsigned long tmp_partition = saved_partition;
-  int got_file = 0;
-
-while ((*arg) &amp;&amp; (!got_file)) {
-
-      filename=arg;
-      arg = skip_to (0,arg); // Iterate over filenames
-      nul_terminate (filename);
-
-	buf_drive = GRUB_INVALID_DRIVE; // This line makes possible do the find loop for more than one file
-
-
-  /* Hard disks.  */
-  for (drive = 0x80; drive &lt; 0x90; drive++)
-    {
-      unsigned long part = 0xFFFFFF;
-      unsigned long start, len, offset, ext_offset;
-      int type, entry;
-      char buf[SECTOR_SIZE];
-      char device_found[14]; // A device should fit into 14 space
-      current_drive = drive;
-      while (next_partition (drive, 0xFFFFFF, &amp;part, &amp;type,
-			     &amp;start, &amp;len, &amp;offset, &amp;entry,
-			     &amp;ext_offset, buf))
-	{
-	  if (type != PC_SLICE_TYPE_NONE
-	      &amp;&amp; ! IS_PC_SLICE_TYPE_BSD (type)
-	      &amp;&amp; ! IS_PC_SLICE_TYPE_EXTENDED (type))
-	    {
-	      current_partition = part;
-	      if (open_device ())
-		{
-		  saved_drive = current_drive;
-		  saved_partition = current_partition;
-		  if (grub_open (filename))
-		    {
-		      int bsd_part = (part &gt;&gt; 8) &amp; 0xFF;
-		      int pc_slice = part &gt;&gt; 16;
-		      
-		      grub_close ();
-			grub_sprintf (device_found,&quot;out_hd=hd%d&quot;,drive - 0x80);
-			set_func(device_found,1);
-			grub_sprintf (device_found,&quot;out_part=(hd%d,%d)&quot;,drive - 0x80, pc_slice);
-			set_func(device_found,1);
-			grub_sprintf (device_found,&quot;out_part_n=%d&quot;,pc_slice);
-			set_func(device_found,1);
-			grub_sprintf (device_found,&quot;out_linux_end=%c%d&quot;,'a' + drive - 0x80, pc_slice + 1);
-		        set_func(device_found,1);
-			grub_sprintf (device_found,&quot;out_linux_letter=%c&quot;,'a' + drive - 0x80);
-		        set_func(device_found,1);
-			grub_sprintf (device_found,&quot;out_linux_number=%d&quot;, pc_slice + 1);
-		        set_func(device_found,1);
-			grub_sprintf (device_found,&quot;out_linux_number=%d&quot;, pc_slice + 1);
-		        set_func(device_found,1);
-			grub_sprintf (device_found,&quot;out_file=%s&quot;, filename);
-		        set_func(device_found,1);
-
-		      if (bsd_part == 0xFF) {
-			grub_sprintf (device_found,&quot;out_device=(hd%d,%d)&quot;,
-				     drive - 0x80, pc_slice);
-			}
-		      else
-			{
-			grub_sprintf (device_found,&quot;out_slice=%c&quot;,bsd_part + 'a');
-			set_func(device_found,1);
-			grub_sprintf (device_found,&quot;out_device=(hd%d,%d,%c)&quot;,
-				     drive - 0x80, pc_slice, bsd_part + 'a');
-			}
-		      set_func(device_found,1);
-		      got_file = 1;
-		    }
-		}
-	    }
-	if (got_file) break;
-	  /* We want to ignore any error here.  */
-	  errnum = ERR_NONE;
-	}
-	if (got_file) break;
-      /* next_partition always sets ERRNUM in the last call, so clear
-	 it.  */
-      errnum = ERR_NONE;
-    }
-
-
-
-
-
-
-} // while filename
-
-
-
-
-  saved_drive = tmp_drive;
-  saved_partition = tmp_partition;
-
-  if (got_file)
-    {
-      
-      errnum = ERR_NONE;
-      return 0;
-    }
-
-  errnum = ERR_FILE_NOT_FOUND;
-  return 1;
-}
-
-static struct builtin builtin_findf =
-{
-  &quot;findf&quot;,
-  findf_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;findf FILENAME&quot;,
-  &quot;Search for the filename FILENAME in all of partitions (only hard disks) and save&quot;
-  &quot;into out_hd, out_part, out_slice and out_device variables the drive of the FILENAME&quot;
-  
-};
-
-/* graphics */
-static int
-sgdgfxmenu_func (char *arg, int flags)
-{
-  memmove(graphics_file, arg, sizeof graphics_file - 1);
-  graphics_file[sizeof graphics_file - 1] = 0;
-
-  return 0;
-}
-
-static struct builtin builtin_sgdgfxmenu =
-{
-  &quot;sgdgfxmenu&quot;,
-  sgdgfxmenu_func,
-  BUILTIN_MENU | BUILTIN_HELP_LIST,
-  &quot;sgdgfxmenu FILE&quot;,
-  &quot;Use the graphical menu from FILE.&quot;
-};
-
-/* graphics */
-static int
-sgdgfxmenuoff_func (char *arg, int flags)
-{
-  graphics_file[0] = 0;
-  return 0;
-}
-
-static struct builtin builtin_sgdgfxmenuoff =
-{
-  &quot;sgdgfxmenuoff&quot;,
-  sgdgfxmenuoff_func,
-  BUILTIN_MENU | BUILTIN_HELP_LIST,
-  &quot;sgdgfxmenuoff&quot;,
-  &quot;Turn off the graphical menu.&quot;
-};
-
-
-/* geometry */
-static int
-geometry_func (char *arg, int flags)
-{
-  struct geometry geom;
-  char *msg;
-  char *device = arg;
-#ifdef GRUB_UTIL
-  char *ptr;
-#endif
-
-  /* Get the device number.  */
-  set_device (device);
-  if (errnum)
-    return 1;
-
-  /* Check for the geometry.  */
-  if (get_diskinfo (current_drive, &amp;geom))
-    {
-      errnum = ERR_NO_DISK;
-      return 1;
-    }
-
-  /* Attempt to read the first sector, because some BIOSes turns out not
-     to support LBA even though they set the bit 0 in the support
-     bitmap, only after reading something actually.  */
-  if (biosdisk (BIOSDISK_READ, current_drive, &amp;geom, 0, 1, SCRATCHSEG))
-    {
-      errnum = ERR_READ;
-      return 1;
-    }
-
-#ifdef GRUB_UTIL
-  ptr = skip_to (0, device);
-  if (*ptr)
-    {
-      char *cylinder, *head, *sector, *total_sector;
-      int num_cylinder, num_head, num_sector, num_total_sector;
-
-      cylinder = ptr;
-      head = skip_to (0, cylinder);
-      sector = skip_to (0, head);
-      total_sector = skip_to (0, sector);
-      if (! safe_parse_maxint (&amp;cylinder, &amp;num_cylinder)
-	  || ! safe_parse_maxint (&amp;head, &amp;num_head)
-	  || ! safe_parse_maxint (&amp;sector, &amp;num_sector))
-	return 1;
-
-      disks[current_drive].cylinders = num_cylinder;
-      disks[current_drive].heads = num_head;
-      disks[current_drive].sectors = num_sector;
-
-      if (safe_parse_maxint (&amp;total_sector, &amp;num_total_sector))
-	disks[current_drive].total_sectors = num_total_sector;
-      else
-	disks[current_drive].total_sectors
-	  = num_cylinder * num_head * num_sector;
-      errnum = 0;
-
-      geom = disks[current_drive];
-      buf_drive = -1;
-    }
-#endif /* GRUB_UTIL */
-
-#ifdef GRUB_UTIL
-  msg = device_map[current_drive];
-#else
-  if (geom.flags &amp; BIOSDISK_FLAG_LBA_EXTENSION)
-    msg = &quot;LBA&quot;;
-  else
-    msg = &quot;CHS&quot;;
-#endif
-
-  grub_printf (&quot;drive 0x%x: C/H/S = %d/%d/%d, &quot;
-	       &quot;The number of sectors = %d, %s\n&quot;,
-	       current_drive,
-	       geom.cylinders, geom.heads, geom.sectors,
-	       geom.total_sectors, msg);
-  real_open_partition (1);
-
-  return 0;
-}
-
-static struct builtin builtin_geometry =
-{
-  &quot;geometry&quot;,
-  geometry_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;geometry DRIVE [CYLINDER HEAD SECTOR [TOTAL_SECTOR]]&quot;,
-  &quot;Print the information for a drive DRIVE. In the grub shell, you can&quot;
-  &quot; set the geometry of the drive arbitrarily. The number of the cylinders,&quot;
-  &quot; the one of the heads, the one of the sectors and the one of the total&quot;
-  &quot; sectors are set to CYLINDER, HEAD, SECTOR and TOTAL_SECTOR,&quot;
-  &quot; respectively. If you omit TOTAL_SECTOR, then it will be calculated based&quot;
-  &quot; on the C/H/S values automatically.&quot;
-};
-
-/* halt */
-static int
-halt_func (char *arg, int flags)
-{
-  int no_apm;
-
-  no_apm = (grub_memcmp (arg, &quot;--no-apm&quot;, 8) == 0);
-  grub_halt (no_apm);
-  
-  /* Never reach here.  */
-  return 1;
-}
-
-static struct builtin builtin_halt =
-{
-  &quot;halt&quot;,
-  halt_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;halt [--no-apm]&quot;,
-  &quot;Halt your system. If APM is avaiable on it, turn off the power using&quot;
-  &quot; the APM BIOS, unless you specify the option `--no-apm'.&quot;
-};
-
-
-/* help */
-#define MAX_SHORT_DOC_LEN	39
-#define MAX_LONG_DOC_LEN	66
-
-static int
-help_func (char *arg, int flags)
-{
-  int all = 0;
-  
-  if (grub_memcmp (arg, &quot;--all&quot;, sizeof (&quot;--all&quot;) - 1) == 0)
-    {
-      all = 1;
-      arg = skip_to (0, arg);
-    }
-  
-  if (! *arg)
-    {
-      /* Invoked with no argument. Print the list of the short docs.  */
-      struct builtin **builtin;
-      int left = 1;
-
-      for (builtin = builtin_table; *builtin != 0; builtin++)
-	{
-	  int len;
-	  int i;
-
-	  /* If this cannot be used in the command-line interface,
-	     skip this.  */
-	  if (! ((*builtin)-&gt;flags &amp; BUILTIN_CMDLINE))
-	    continue;
-	  
-	  /* If this doesn't need to be listed automatically and &quot;--all&quot;
-	     is not specified, skip this.  */
-	  if (! all &amp;&amp; ! ((*builtin)-&gt;flags &amp; BUILTIN_HELP_LIST))
-	    continue;
-
-	  len = grub_strlen ((*builtin)-&gt;short_doc);
-	  /* If the length of SHORT_DOC is too long, truncate it.  */
-	  if (len &gt; MAX_SHORT_DOC_LEN - 1)
-	    len = MAX_SHORT_DOC_LEN - 1;
-
-	  for (i = 0; i &lt; len; i++)
-	    grub_putchar ((*builtin)-&gt;short_doc[i]);
-
-	  for (; i &lt; MAX_SHORT_DOC_LEN; i++)
-	    grub_putchar (' ');
-
-	  if (! left)
-	    grub_putchar ('\n');
-
-	  left = ! left;
-	}
-
-      /* If the last entry was at the left column, no newline was printed
-	 at the end.  */
-      if (! left)
-	grub_putchar ('\n');
-    }
-  else
-    {
-      /* Invoked with one or more patterns.  */
-      do
-	{
-	  struct builtin **builtin;
-	  char *next_arg;
-
-	  /* Get the next argument.  */
-	  next_arg = skip_to (0, arg);
-
-	  /* Terminate ARG.  */
-	  nul_terminate (arg);
-
-	  for (builtin = builtin_table; *builtin; builtin++)
-	    {
-	      /* Skip this if this is only for the configuration file.  */
-	      if (! ((*builtin)-&gt;flags &amp; BUILTIN_CMDLINE))
-		continue;
-
-	      if (substring (arg, (*builtin)-&gt;name) &lt; 1)
-		{
-		  char *doc = (*builtin)-&gt;long_doc;
-
-		  /* At first, print the name and the short doc.  */
-		  grub_printf (&quot;%s: %s\n&quot;,
-			       (*builtin)-&gt;name, (*builtin)-&gt;short_doc);
-
-		  /* Print the long doc.  */
-		  while (*doc)
-		    {
-		      int len = grub_strlen (doc);
-		      int i;
-
-		      /* If LEN is too long, fold DOC.  */
-		      if (len &gt; MAX_LONG_DOC_LEN)
-			{
-			  /* Fold this line at the position of a space.  */
-			  for (len = MAX_LONG_DOC_LEN; len &gt; 0; len--)
-			    if (doc[len - 1] == ' ')
-			      break;
-			}
-
-		      grub_printf (&quot;    &quot;);
-		      for (i = 0; i &lt; len; i++)
-			grub_putchar (*doc++);
-		      grub_putchar ('\n');
-		    }
-		}
-	    }
-
-	  arg = next_arg;
-	}
-      while (*arg);
-    }
-
-  return 0;
-}
-
-static struct builtin builtin_help =
-{
-  &quot;help&quot;,
-  help_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;help [--all] [PATTERN ...]&quot;,
-  &quot;Display helpful information about builtin commands. Not all commands&quot;
-  &quot; aren't shown without the option `--all'.&quot;
-};
-
-
-/* hide */
-static int
-hide_func (char *arg, int flags)
-{
-  if (! set_device (arg))
-    return 1;
-
-  if (! set_partition_hidden_flag (1))
-    return 1;
-
-  return 0;
-}
-
-static struct builtin builtin_hide =
-{
-  &quot;hide&quot;,
-  hide_func,
-  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
-  &quot;hide PARTITION&quot;,
-  &quot;Hide PARTITION by setting the \&quot;hidden\&quot; bit in&quot;
-  &quot; its partition type code.&quot;
-};
-
-
-/* initrd */
-static int
-initrd_func (char *arg, int flags)
-{
-  switch (kernel_type)
-    {
-    case KERNEL_TYPE_LINUX:
-    case KERNEL_TYPE_BIG_LINUX:
-      if (! load_initrd (arg))
-	return 1;
-      break;
-
-    default:
-      errnum = ERR_NEED_LX_KERNEL;
-      return 1;
-    }
-
-  return 0;
-}
-
-static struct builtin builtin_initrd =
-{
-  &quot;initrd&quot;,
-  initrd_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;initrd FILE [ARG ...]&quot;,
-  &quot;Load an initial ramdisk FILE for a Linux format boot image and set the&quot;
-  &quot; appropriate parameters in the Linux setup area in memory.&quot;
-};
-
-
-/* install */
-static int
-install_func (char *arg, int flags)
-{
-  char *stage1_file, *dest_dev, *file, *addr;
-  char *stage1_buffer = (char *) RAW_ADDR (0x100000);
-  char *stage2_buffer = stage1_buffer + SECTOR_SIZE;
-  char *old_sect = stage2_buffer + SECTOR_SIZE;
-  char *stage2_first_buffer = old_sect + SECTOR_SIZE;
-  char *stage2_second_buffer = stage2_first_buffer + SECTOR_SIZE;
-  /* XXX: Probably SECTOR_SIZE is reasonable.  */
-  char *config_filename = stage2_second_buffer + SECTOR_SIZE;
-  char *dummy = config_filename + SECTOR_SIZE;
-  int new_drive = GRUB_INVALID_DRIVE;
-  int dest_drive, dest_partition, dest_sector;
-  int src_drive, src_partition, src_part_start;
-  int i;
-  struct geometry dest_geom, src_geom;
-  int saved_sector;
-  int stage2_first_sector, stage2_second_sector;
-  char *ptr;
-  int installaddr, installlist;
-  /* Point to the location of the name of a configuration file in Stage 2.  */
-  char *config_file_location;
-  /* If FILE is a Stage 1.5?  */
-  int is_stage1_5 = 0;
-  /* Must call grub_close?  */
-  int is_open = 0;
-  /* If LBA is forced?  */
-  int is_force_lba = 0;
-  /* If drive embedding is forced?  */
-  int is_force_embed = 0;
-  /* Was the last sector full? */
-  int last_length = SECTOR_SIZE;
-  
-#ifdef GRUB_UTIL
-  /* If the Stage 2 is in a partition mounted by an OS, this will store
-     the filename under the OS.  */
-  char *stage2_os_file = 0;
-#endif /* GRUB_UTIL */
-  
-  auto void disk_read_savesect_func (int sector, int offset, int length);
-  auto void disk_read_blocklist_func (int sector, int offset, int length);
-  
-  /* Save the first sector of Stage2 in STAGE2_SECT.  */
-  auto void disk_read_savesect_func (int sector, int offset, int length)
-    {
-      if (debug)
-	printf (&quot;[%d]&quot;, sector);
-
-      /* ReiserFS has files which sometimes contain data not aligned
-         on sector boundaries.  Returning an error is better than
-         silently failing. */
-      if (offset != 0 || length != SECTOR_SIZE)
-	errnum = ERR_UNALIGNED;
-
-      saved_sector = sector;
-    }
-
-  /* Write SECTOR to INSTALLLIST, and update INSTALLADDR and
-     INSTALLSECT.  */
-  auto void disk_read_blocklist_func (int sector, int offset, int length)
-    {
-      if (debug)
-	printf(&quot;[%d]&quot;, sector);
-
-      if (offset != 0 || last_length != SECTOR_SIZE)
-	{
-	  /* We found a non-sector-aligned data block. */
-	  errnum = ERR_UNALIGNED;
-	  return;
-	}
-
-      last_length = length;
-
-      if (*((unsigned long *) (installlist - 4))
-	  + *((unsigned short *) installlist) != sector
-	  || installlist == (int) stage2_first_buffer + SECTOR_SIZE + 4)
-	{
-	  installlist -= 8;
-
-	  if (*((unsigned long *) (installlist - 8)))
-	    errnum = ERR_WONT_FIT;
-	  else
-	    {
-	      *((unsigned short *) (installlist + 2)) = (installaddr &gt;&gt; 4);
-	      *((unsigned long *) (installlist - 4)) = sector;
-	    }
-	}
-
-      *((unsigned short *) installlist) += 1;
-      installaddr += 512;
-    }
-
-  /* First, check the GNU-style long option.  */
-  while (1)
-    {
-      if (grub_memcmp (&quot;--force-embed&quot;, arg, sizeof (&quot;--force-embed&quot;) - 1) == 0)
-	{
-	  is_force_embed = 1;
-	  arg = skip_to (0, arg);
-	}
-      else if (grub_memcmp (&quot;--force-lba&quot;, arg, sizeof (&quot;--force-lba&quot;) - 1) == 0)
-	{
-	  is_force_lba = 1;
-	  arg = skip_to (0, arg);
-	}
-#ifdef GRUB_UTIL
-      else if (grub_memcmp (&quot;--stage2=&quot;, arg, sizeof (&quot;--stage2=&quot;) - 1) == 0)
-	{
-	  stage2_os_file = arg + sizeof (&quot;--stage2=&quot;) - 1;
-	  arg = skip_to (0, arg);
-	  nul_terminate (stage2_os_file);
-	}
-#endif /* GRUB_UTIL */
-      else
-	break;
-    }
-  
-  stage1_file = arg;
-  dest_dev = skip_to (0, stage1_file);
-  if (*dest_dev == 'd')
-    {
-      new_drive = 0;
-      dest_dev = skip_to (0, dest_dev);
-    }
-  file = skip_to (0, dest_dev);
-  addr = skip_to (0, file);
-
-  /* Get the installation address.  */
-  if (! safe_parse_maxint (&amp;addr, &amp;installaddr))
-    {
-      /* ADDR is not specified.  */
-      installaddr = 0;
-      ptr = addr;
-      errnum = 0;
-    }
-  else
-    ptr = skip_to (0, addr);
-
-#ifndef NO_DECOMPRESSION
-  /* Do not decompress Stage 1 or Stage 2.  */
-  no_decompression = 1;
-#endif
-
-  /* Read Stage 1.  */
-  is_open = grub_open (stage1_file);
-  if (! is_open
-      || ! grub_read (stage1_buffer, SECTOR_SIZE) == SECTOR_SIZE)
-    goto fail;
-
-  /* Read the old sector from DEST_DEV.  */
-  if (! set_device (dest_dev)
-      || ! open_partition ()
-      || ! devread (0, 0, SECTOR_SIZE, old_sect))
-    goto fail;
-
-  /* Store the information for the destination device.  */
-  dest_drive = current_drive;
-  dest_partition = current_partition;
-  dest_geom = buf_geom;
-  dest_sector = part_start;
-
-  /* Copy the possible DOS BPB, 59 bytes at byte offset 3.  */
-  grub_memmove (stage1_buffer + BOOTSEC_BPB_OFFSET,
-		old_sect + BOOTSEC_BPB_OFFSET,
-		BOOTSEC_BPB_LENGTH);
-
-  /* If for a hard disk, copy the possible MBR/extended part table.  */
-  if (dest_drive &amp; 0x80)
-    grub_memmove (stage1_buffer + STAGE1_WINDOWS_NT_MAGIC,
-		  old_sect + STAGE1_WINDOWS_NT_MAGIC,
-		  STAGE1_PARTEND - STAGE1_WINDOWS_NT_MAGIC);
-
-  /* Check for the version and the signature of Stage 1.  */
-  if (*((short *)(stage1_buffer + STAGE1_VER_MAJ_OFFS)) != COMPAT_VERSION
-      || (*((unsigned short *) (stage1_buffer + BOOTSEC_SIG_OFFSET))
-	  != BOOTSEC_SIGNATURE))
-    {
-      errnum = ERR_BAD_VERSION;
-      goto fail;
-    }
-
-  /* This below is not true any longer. But should we leave this alone?  */
-  
-  /* If DEST_DRIVE is a floppy, Stage 2 must have the iteration probe
-     routine.  */
-  if (! (dest_drive &amp; 0x80)
-      &amp;&amp; (*((unsigned char *) (stage1_buffer + BOOTSEC_PART_OFFSET)) == 0x80
-	  || stage1_buffer[BOOTSEC_PART_OFFSET] == 0))
-    {
-      errnum = ERR_BAD_VERSION;
-      goto fail;
-    }
-
-  grub_close ();
-  
-  /* Open Stage 2.  */
-  is_open = grub_open (file);
-  if (! is_open)
-    goto fail;
-
-  src_drive = current_drive;
-  src_partition = current_partition;
-  src_part_start = part_start;
-  src_geom = buf_geom;
-  
-  if (! new_drive)
-    new_drive = src_drive;
-  else if (src_drive != dest_drive)
-    grub_printf (&quot;Warning: the option `d' was not used, but the Stage 1 will&quot;
-		 &quot; be installed on a\ndifferent drive than the drive where&quot;
-		 &quot; the Stage 2 resides.\n&quot;);
-
-  /* Set the boot drive.  */
-  *((unsigned char *) (stage1_buffer + STAGE1_BOOT_DRIVE)) = new_drive;
-
-  /* Set the &quot;force LBA&quot; flag.  */
-  *((unsigned char *) (stage1_buffer + STAGE1_FORCE_LBA)) = is_force_lba;
-
-  /* If DEST_DRIVE is a hard disk, enable the workaround, which is
-     for buggy BIOSes which don't pass boot drive correctly. Instead,
-     they pass 0x00 or 0x01 even when booted from 0x80.  */
-  if (dest_drive &amp; BIOS_FLAG_FIXED_DISK)
-    {
-      if ( *((unsigned char *) (stage1_buffer + STAGE1_BOOT_DRIVE_CHECK)) == 0xeb )
-        /* For present version 0.97:  Replace the jmp (2 bytes) with double nop's.  */
-        *((unsigned short *) (stage1_buffer + STAGE1_BOOT_DRIVE_CHECK))
-          = 0x9090;
-      else if ( *((unsigned char *) (stage1_buffer + STAGE1_BOOT_DRIVE_CHECK)) == 0x80 )
-        {   
-          /* For previous versions 0.94-96:  Set the &quot;boot-drive-mask&quot;.
-             This is the old workaround for buggy BIOSes which do not pass boot drive correctly.
-             The technique was to use 'or dl,0x80', hence testing for 0x80, i.e. or-instruction.
-             REM: the old STAGE1_BOOT_DRIVE_MASK equals STAGE1_BOOT_DRIVE_CHECK + 2.  */
-          *((unsigned char *) (stage1_buffer + STAGE1_BOOT_DRIVE_CHECK + 2))
-            = (dest_drive &amp; BIOS_FLAG_FIXED_DISK);
-        }
-//      else
-//        {
-          /* The boot sector is thus older than version 0.94.
-             Changing 'goto fail' to a &quot;do nothing&quot; could even make 0.92 and 0.93
-             acceptable for the purpose of rescuing their installations.  */
-//	  goto fail;
-//	}
-//	Let's accept 0.92 and 0.93 for rescuing their installations! - adrian15	
-
-
-    }
-
-  /* Read the first sector of Stage 2.  */
-  disk_read_hook = disk_read_savesect_func;
-  if (grub_read (stage2_first_buffer, SECTOR_SIZE) != SECTOR_SIZE)
-    goto fail;
-
-  stage2_first_sector = saved_sector;
-  
-  /* Read the second sector of Stage 2.  */
-  if (grub_read (stage2_second_buffer, SECTOR_SIZE) != SECTOR_SIZE)
-    goto fail;
-
-  stage2_second_sector = saved_sector;
-  
-  /* Check for the version of Stage 2.  */
-  if (*((short *) (stage2_second_buffer + STAGE2_VER_MAJ_OFFS))
-      != COMPAT_VERSION)
-    {
-      errnum = ERR_BAD_VERSION;
-      goto fail;
-    }
-
-  /* Check for the Stage 2 id.  */
-  if (stage2_second_buffer[STAGE2_STAGE2_ID] != STAGE2_ID_STAGE2)
-    is_stage1_5 = 1;
-
-  /* If INSTALLADDR is not specified explicitly in the command-line,
-     determine it by the Stage 2 id.  */
-  if (! installaddr)
-    {
-      if (! is_stage1_5)
-	/* Stage 2.  */
-	installaddr = 0x8000;
-      else
-	/* Stage 1.5.  */
-	installaddr = 0x2000;
-    }
-
-  *((unsigned long *) (stage1_buffer + STAGE1_STAGE2_SECTOR))
-    = stage2_first_sector;
-  *((unsigned short *) (stage1_buffer + STAGE1_STAGE2_ADDRESS))
-    = installaddr;
-  *((unsigned short *) (stage1_buffer + STAGE1_STAGE2_SEGMENT))
-    = installaddr &gt;&gt; 4;
-
-  i = (int) stage2_first_buffer + SECTOR_SIZE - 4;
-  while (*((unsigned long *) i))
-    {
-      if (i &lt; (int) stage2_first_buffer
-	  || (*((int *) (i - 4)) &amp; 0x80000000)
-	  || *((unsigned short *) i) &gt;= 0xA00
-	  || *((short *) (i + 2)) == 0)
-	{
-	  errnum = ERR_BAD_VERSION;
-	  goto fail;
-	}
-
-      *((int *) i) = 0;
-      *((int *) (i - 4)) = 0;
-      i -= 8;
-    }
-
-  installlist = (int) stage2_first_buffer + SECTOR_SIZE + 4;
-  installaddr += SECTOR_SIZE;
-  
-  /* Read the whole of Stage2 except for the first sector.  */
-  grub_seek (SECTOR_SIZE);
-
-  disk_read_hook = disk_read_blocklist_func;
-  if (! grub_read (dummy, -1))
-    goto fail;
-  
-  disk_read_hook = 0;
-  
-  /* Find a string for the configuration filename.  */
-  config_file_location = stage2_second_buffer + STAGE2_VER_STR_OFFS;
-  while (*(config_file_location++))
-    ;
-
-  /* Set the &quot;force LBA&quot; flag for Stage2.  */
-  *((unsigned char *) (stage2_second_buffer + STAGE2_FORCE_LBA))
-    = is_force_lba;
-  
-  if (*ptr == 'p')
-    {
-      *((long *) (stage2_second_buffer + STAGE2_INSTALLPART))
-	= src_partition;
-      if (is_stage1_5)
-	{
-	  /* Reset the device information in FILE if it is a Stage 1.5.  */
-	  unsigned long device = 0xFFFFFFFF;
-
-	  grub_memmove (config_file_location, (char *) &amp;device,
-			sizeof (device));
-	}
-
-      ptr = skip_to (0, ptr);
-    }
-
-  if (*ptr)
-    {
-      grub_strcpy (config_filename, ptr);
-      nul_terminate (config_filename);
-	
-      if (! is_stage1_5)
-	/* If it is a Stage 2, just copy PTR to CONFIG_FILE_LOCATION.  */
-	grub_strcpy (config_file_location, ptr);
-      else
-	{
-	  char *real_config;
-	  unsigned long device;
-
-	  /* Translate the external device syntax to the internal device
-	     syntax.  */
-	  if (! (real_config = set_device (ptr)))
-	    {
-	      /* The Stage 2 PTR does not contain the device name, so
-		 use the root device instead.  */
-	      errnum = ERR_NONE;
-	      current_drive = saved_drive;
-	      current_partition = saved_partition;
-	      real_config = ptr;
-	    }
-	  
-	  if ( (current_drive == src_drive) &amp;&amp; (! is_force_embed ) )
-	    {
-	      /* If the drive where the Stage 2 resides is the same as
-		 the one where the Stage 1.5 resides, do not embed the
-		 drive number.  */
-	      current_drive = GRUB_INVALID_DRIVE;
-	    }
-
-	  device = (current_drive &lt;&lt; 24) | current_partition;
-	  grub_memmove (config_file_location, (char *) &amp;device,
-			sizeof (device));
-	  grub_strcpy (config_file_location + sizeof (device),
-		       real_config);
-	}
-
-      /* If a Stage 1.5 is used, then we need to modify the Stage2.  */
-      if (is_stage1_5)
-	{
-	  char *real_config_filename = skip_to (0, ptr);
-	  
-	  is_open = grub_open (config_filename);
-	  if (! is_open)
-	    goto fail;
-
-	  /* Skip the first sector.  */
-	  grub_seek (SECTOR_SIZE);
-	  
-	  disk_read_hook = disk_read_savesect_func;
-	  if (grub_read (stage2_buffer, SECTOR_SIZE) != SECTOR_SIZE)
-	    goto fail;
-	  
-	  disk_read_hook = 0;
-	  grub_close ();
-	  is_open = 0;
-	  
-	  /* Sanity check.  */
-	  if (*(stage2_buffer + STAGE2_STAGE2_ID) != STAGE2_ID_STAGE2)
-	    {
-	      errnum = ERR_BAD_VERSION;
-	      goto fail;
-	    }
-
-	  /* Set the &quot;force LBA&quot; flag for Stage2.  */
-	  *(stage2_buffer + STAGE2_FORCE_LBA) = is_force_lba;
-
-	  /* If REAL_CONFIG_FILENAME is specified, copy it to the Stage2.  */
-	  if (*real_config_filename)
-	    {
-	      /* Specified */
-	      char *location;
-	      
-	      /* Find a string for the configuration filename.  */
-	      location = stage2_buffer + STAGE2_VER_STR_OFFS;
-	      while (*(location++))
-		;
-	      
-	      /* Copy the name.  */
-	      grub_strcpy (location, real_config_filename);
-	    }
-	  
-	  /* Write it to the disk.  */
-	  buf_track = -1;
-
-#ifdef GRUB_UTIL
-	  /* In the grub shell, access the Stage 2 via the OS filesystem
-	     service, if possible.  */
-	  if (stage2_os_file)
-	    {
-	      FILE *fp;
-
-	      fp = fopen (stage2_os_file, &quot;r+&quot;);
-	      if (! fp)
-		{
-		  errnum = ERR_FILE_NOT_FOUND;
-		  goto fail;
-		}
-
-	      if (fseek (fp, SECTOR_SIZE, SEEK_SET) != 0)
-		{
-		  fclose (fp);
-		  errnum = ERR_BAD_VERSION;
-		  goto fail;
-		}
-
-	      if (fwrite (stage2_buffer, 1, SECTOR_SIZE, fp)
-		  != SECTOR_SIZE)
-		{
-		  fclose (fp);
-		  errnum = ERR_WRITE;
-		  goto fail;
-		}
-
-	      fclose (fp);
-	    }
-	  else
-#endif /* GRUB_UTIL */
-	    {
-	      if (! devwrite (saved_sector - part_start, 1, stage2_buffer))
-		goto fail;
-	    }
-	}
-    }
-
-  /* Clear the cache.  */
-  buf_track = -1;
-
-  /* Write the modified sectors of Stage2 to the disk.  */
-#ifdef GRUB_UTIL
-  if (! is_stage1_5 &amp;&amp; stage2_os_file)
-    {
-      FILE *fp;
-
-      fp = fopen (stage2_os_file, &quot;r+&quot;);
-      if (! fp)
-	{
-	  errnum = ERR_FILE_NOT_FOUND;
-	  goto fail;
-	}
-
-      if (fwrite (stage2_first_buffer, 1, SECTOR_SIZE, fp) != SECTOR_SIZE)
-	{
-	  fclose (fp);
-	  errnum = ERR_WRITE;
-	  goto fail;
-	}
-
-      if (fwrite (stage2_second_buffer, 1, SECTOR_SIZE, fp) != SECTOR_SIZE)
-	{
-	  fclose (fp);
-	  errnum = ERR_WRITE;
-	  goto fail;
-	}
-
-      fclose (fp);
-    }
-  else
-#endif /* GRUB_UTIL */
-    {
-      /* The first.  */
-      current_drive = src_drive;
-      current_partition = src_partition;
-
-      if (! open_partition ())
-	goto fail;
-
-      if (! devwrite (stage2_first_sector - src_part_start, 1,
-		      stage2_first_buffer))
-	goto fail;
-
-      if (! devwrite (stage2_second_sector - src_part_start, 1,
-		      stage2_second_buffer))
-	goto fail;
-    }
-  
-  /* Write the modified sector of Stage 1 to the disk.  */
-  current_drive = dest_drive;
-  current_partition = dest_partition;
-  if (! open_partition ())
-    goto fail;
-
-  devwrite (0, 1, stage1_buffer);
-
- fail:
-  if (is_open)
-    grub_close ();
-  
-  disk_read_hook = 0;
-  
-#ifndef NO_DECOMPRESSION
-  no_decompression = 0;
-#endif
-
-  return errnum;
-}
-
-static struct builtin builtin_install =
-{
-  &quot;install&quot;,
-  install_func,
-  BUILTIN_CMDLINE,
-  &quot;install [--stage2=STAGE2_FILE] [--force-lba] [--force-embed] STAGE1 [d] DEVICE STAGE2 [ADDR] [p] [CONFIG_FILE] [REAL_CONFIG_FILE]&quot;,
-  &quot;Install STAGE1 on DEVICE, and install a blocklist for loading STAGE2&quot;
-  &quot; as a Stage 2. If the option `d' is present, the Stage 1 will always&quot;
-  &quot; look for the disk where STAGE2 was installed, rather than using&quot;
-  &quot; the booting drive. The Stage 2 will be loaded at address ADDR, which&quot;
-  &quot; will be determined automatically if you don't specify it. If&quot;
-  &quot; the option `p' or CONFIG_FILE is present, then the first block&quot;
-  &quot; of Stage 2 is patched with new values of the partition and name&quot;
-  &quot; of the configuration file used by the true Stage 2 (for a Stage 1.5,&quot;
-  &quot; this is the name of the true Stage 2) at boot time. If STAGE2 is a Stage&quot;
-  &quot; 1.5 and REAL_CONFIG_FILE is present, then the Stage 2 CONFIG_FILE is&quot;
-  &quot; patched with the configuration filename REAL_CONFIG_FILE.&quot;
-  &quot; If the option `--force-lba' is specified, disable some sanity checks&quot;
-  &quot; for LBA mode. If the option `--stage2' is specified, rewrite the Stage&quot;
-  &quot; If the option `--force-embed' is specified, force the drive embedding even&quot;
-  &quot; if root and setup drives are different.&quot;
-  &quot; 2 via your OS's filesystem instead of the raw device.&quot;
-};
-
-
-
-
-/* kernel */
-static int
-kernel_func (char *arg, int flags)
-{
-  int len;
-  kernel_t suggested_type = KERNEL_TYPE_NONE;
-  unsigned long load_flags = 0;
-
-#ifndef AUTO_LINUX_MEM_OPT
-  load_flags |= KERNEL_LOAD_NO_MEM_OPTION;
-#endif
-
-  /* Deal with GNU-style long options.  */
-  while (1)
-    {
-      /* If the option `--type=TYPE' is specified, convert the string to
-	 a kernel type.  */
-      if (grub_memcmp (arg, &quot;--type=&quot;, 7) == 0)
-	{
-	  arg += 7;
-	  
-	  if (grub_memcmp (arg, &quot;netbsd&quot;, 6) == 0)
-	    suggested_type = KERNEL_TYPE_NETBSD;
-	  else if (grub_memcmp (arg, &quot;freebsd&quot;, 7) == 0)
-	    suggested_type = KERNEL_TYPE_FREEBSD;
-	  else if (grub_memcmp (arg, &quot;openbsd&quot;, 7) == 0)
-	    /* XXX: For now, OpenBSD is identical to NetBSD, from GRUB's
-	       point of view.  */
-	    suggested_type = KERNEL_TYPE_NETBSD;
-	  else if (grub_memcmp (arg, &quot;linux&quot;, 5) == 0)
-	    suggested_type = KERNEL_TYPE_LINUX;
-	  else if (grub_memcmp (arg, &quot;biglinux&quot;, 8) == 0)
-	    suggested_type = KERNEL_TYPE_BIG_LINUX;
-	  else if (grub_memcmp (arg, &quot;multiboot&quot;, 9) == 0)
-	    suggested_type = KERNEL_TYPE_MULTIBOOT;
-	  else
-	    {
-	      errnum = ERR_BAD_ARGUMENT;
-	      return 1;
-	    }
-	}
-      /* If the `--no-mem-option' is specified, don't pass a Linux's mem
-	 option automatically. If the kernel is another type, this flag
-	 has no effect.  */
-      else if (grub_memcmp (arg, &quot;--no-mem-option&quot;, 15) == 0)
-	load_flags |= KERNEL_LOAD_NO_MEM_OPTION;
-      else
-	break;
-
-      /* Try the next.  */
-      arg = skip_to (0, arg);
-    }
-      
-  len = grub_strlen (arg);
-
-  /* Reset MB_CMDLINE.  */
-  mb_cmdline = (char *) MB_CMDLINE_BUF;
-  if (len + 1 &gt; MB_CMDLINE_BUFLEN)
-    {
-      errnum = ERR_WONT_FIT;
-      return 1;
-    }
-
-  /* Copy the command-line to MB_CMDLINE.  */
-  grub_memmove (mb_cmdline, arg, len + 1);
-  kernel_type = load_image (arg, mb_cmdline, suggested_type, load_flags);
-  if (kernel_type == KERNEL_TYPE_NONE)
-    return 1;
-
-  mb_cmdline += len + 1;
-  return 0;
-}
-
-static struct builtin builtin_kernel =
-{
-  &quot;kernel&quot;,
-  kernel_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;kernel [--no-mem-option] [--type=TYPE] FILE [ARG ...]&quot;,
-  &quot;Attempt to load the primary boot image from FILE. The rest of the&quot;
-  &quot; line is passed verbatim as the \&quot;kernel command line\&quot;.  Any modules&quot;
-  &quot; must be reloaded after using this command. The option --type is used&quot;
-  &quot; to suggest what type of kernel to be loaded. TYPE must be either of&quot;
-  &quot; \&quot;netbsd\&quot;, \&quot;freebsd\&quot;, \&quot;openbsd\&quot;, \&quot;linux\&quot;, \&quot;biglinux\&quot; and&quot;
-  &quot; \&quot;multiboot\&quot;. The option --no-mem-option tells GRUB not to pass a&quot;
-  &quot; Linux's mem option automatically.&quot;
-};
-
-
-/* lock // Removed lock command because in SGD we do not need it.
-static int
-lock_func (char *arg, int flags)
-{
-  if (! auth &amp;&amp; password)
-    {
-      errnum = ERR_PRIVILEGED;
-      return 1;
-    }
-
-  return 0;
-}
-
-static struct builtin builtin_lock =
-{
-  &quot;lock&quot;,
-  lock_func,
-  BUILTIN_CMDLINE,
-  &quot;lock&quot;,
-  &quot;Break a command execution unless the user is authenticated.&quot;
-};
-*/
-
-/* makeactive */
-static int
-makeactive_func (char *arg, int flags)
-{
-  if (! make_saved_active ())
-    return 1;
-
-  return 0;
-}
-
-static struct builtin builtin_makeactive =
-{
-  &quot;makeactive&quot;,
-  makeactive_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;makeactive&quot;,
-  &quot;Set the active partition on the root disk to GRUB's root device.&quot;
-  &quot; This command is limited to _primary_ PC partitions on a hard disk.&quot;
-};
-
-
-
-
-
-
-/* map */
-/* Map FROM_DRIVE to TO_DRIVE.  */
-static int
-map_func (char *arg, int flags)
-{
-  char *to_drive;
-  char *from_drive;
-  unsigned long to, from;
-  
-  to_drive = arg;
-  from_drive = skip_to (0, arg);
-
-  /* Get the drive number for TO_DRIVE.  */
-  set_device (to_drive);
-  if (errnum)
-    return 1;
-  to = current_drive;
-
-  /* Get the drive number for FROM_DRIVE.  */
-  set_device (from_drive);
-  if (errnum)
-    return 1;
-  from = current_drive;
-
-return (real_map_func(to,from));
-
-}
-
-static struct builtin builtin_map =
-{
-  &quot;map&quot;,
-  map_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;map TO_DRIVE FROM_DRIVE&quot;,
-  &quot;Map the drive FROM_DRIVE to the drive TO_DRIVE. This is necessary&quot;
-  &quot; when you chain-load some operating systems, such as DOS, if such an&quot;
-  &quot; OS resides at a non-first drive.&quot;
-};
-
-
-#ifdef USE_MD5_PASSWORDS
-/* md5crypt */
-static int
-md5crypt_func (char *arg, int flags)
-{
-  char crypted[36];
-  char key[32];
-  unsigned int seed;
-  int i;
-  const char *const seedchars =
-    &quot;./0123456789ABCDEFGHIJKLMNOPQRST&quot;
-    &quot;UVWXYZabcdefghijklmnopqrstuvwxyz&quot;;
-  
-  /* First create a salt.  */
-
-  /* The magical prefix.  */
-  grub_memset (crypted, 0, sizeof (crypted));
-  grub_memmove (crypted, &quot;$1$&quot;, 3);
-
-  /* Create the length of a salt.  */
-  seed = currticks ();
-
-  /* Generate a salt.  */
-  for (i = 0; i &lt; 8 &amp;&amp; seed; i++)
-    {
-      /* FIXME: This should be more random.  */
-      crypted[3 + i] = seedchars[seed &amp; 0x3f];
-      seed &gt;&gt;= 6;
-    }
-
-  /* A salt must be terminated with `$', if it is less than 8 chars.  */
-  crypted[3 + i] = '$';
-
-#ifdef DEBUG_MD5CRYPT
-  grub_printf (&quot;salt = %s\n&quot;, crypted);
-#endif
-  
-  /* Get a password.  */
-  grub_memset (key, 0, sizeof (key));
-  get_cmdline (&quot;Password: &quot;, key, sizeof (key) - 1, '*', 0);
-
-  /* Crypt the key.  */
-  make_md5_password (key, crypted);
-
-  grub_printf (&quot;Encrypted: %s\n&quot;, crypted);
-  return 0;
-}
-
-static struct builtin builtin_md5crypt =
-{
-  &quot;md5crypt&quot;,
-  md5crypt_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;md5crypt&quot;,
-  &quot;Generate a password in MD5 format.&quot;
-};
-#endif /* USE_MD5_PASSWORDS */
-
-
-/* modaddr */
-static int
-modaddr_func (char *arg, int flags)
-{
-  int addr;
-
-  switch (kernel_type)
-    {
-    case KERNEL_TYPE_MULTIBOOT:
-      if (safe_parse_maxint(&amp;arg, &amp;addr))
-	{
-	  set_load_addr(addr);
-	  break;
-	}
-
-      /* else fallthrough */
-
-    default:
-      errnum = ERR_NEED_MB_KERNEL;
-      return 1;
-    }
-
-  return 0;
-}
-
-static struct builtin builtin_modaddr =
-{
-  &quot;modaddr&quot;,
-  modaddr_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;modaddr ADDRESS&quot;, 
-  &quot;Set the load address for the next Multiboot module to ADDRESS&quot;
-};
-
-
-/* module */
-static int
-module_func (char *arg, int flags)
-{
-  int len = grub_strlen (arg);
-
-  switch (kernel_type)
-    {
-    case KERNEL_TYPE_MULTIBOOT:
-      if (mb_cmdline + len + 1 &gt; (char *) MB_CMDLINE_BUF + MB_CMDLINE_BUFLEN)
-	{
-	  errnum = ERR_WONT_FIT;
-	  return 1;
-	}
-      grub_memmove (mb_cmdline, arg, len + 1);
-      if (! load_module (arg, mb_cmdline))
-	return 1;
-      mb_cmdline += len + 1;
-      break;
-
-    case KERNEL_TYPE_LINUX:
-    case KERNEL_TYPE_BIG_LINUX:
-      if (! load_initrd (arg))
-	return 1;
-      break;
-
-    default:
-      errnum = ERR_NEED_MB_KERNEL;
-      return 1;
-    }
-
-  return 0;
-}
-
-static struct builtin builtin_module =
-{
-  &quot;module&quot;,
-  module_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;module FILE [ARG ...]&quot;,
-  &quot;Load a boot module FILE for a Multiboot format boot image (no&quot;
-  &quot; interpretation of the file contents is made, so users of this&quot;
-  &quot; command must know what the kernel in question expects). The&quot;
-  &quot; rest of the line is passed as the \&quot;module command line\&quot;, like&quot;
-  &quot; the `kernel' command.&quot;
-};
-
-
-/* modulenounzip */
-static int
-modulenounzip_func (char *arg, int flags)
-{
-  int ret;
-
-#ifndef NO_DECOMPRESSION
-  no_decompression = 1;
-#endif
-
-  ret = module_func (arg, flags);
-
-#ifndef NO_DECOMPRESSION
-  no_decompression = 0;
-#endif
-
-  return ret;
-}
-
-static struct builtin builtin_modulenounzip =
-{
-  &quot;modulenounzip&quot;,
-  modulenounzip_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;modulenounzip FILE [ARG ...]&quot;,
-  &quot;The same as `module', except that automatic decompression is&quot;
-  &quot; disabled.&quot;
-};
-
-
-
-/* partinfo */
-static int
-partinfo_func (char *arg, int flags)
-{
-
-save_fsys_type();
-return 0;
-}
-
-static struct builtin builtin_partinfo =
-{
-  &quot;partinfo&quot;,
-  partinfo_func,
-  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
-  &quot;partinfo&quot;,
-  &quot;Saves into AUX variable the information about the former rooted (root (hdX,Y) partition.&quot;
-};
-
-/* password 
-static int
-password_func (char *arg, int flags)
-{
-  int len;
-  password_t type = PASSWORD_PLAIN;
-
-#ifdef USE_MD5_PASSWORDS
-  if (grub_memcmp (arg, &quot;--md5&quot;, 5) == 0)
-    {
-      type = PASSWORD_MD5;
-      arg = skip_to (0, arg);
-    }
-#endif
-  if (grub_memcmp (arg, &quot;--&quot;, 2) == 0)
-    {
-      type = PASSWORD_UNSUPPORTED;
-      arg = skip_to (0, arg);
-    }
-
-  if ((flags &amp; (BUILTIN_CMDLINE | BUILTIN_SCRIPT)) != 0)
-    {
-      // Do password check! 
-      char entered[32];
-      
-      // Wipe out any previously entered password 
-      entered[0] = 0;
-      get_cmdline (&quot;Password: &quot;, entered, 31, '*', 0);
-
-      nul_terminate (arg);
-      if (check_password (entered, arg, type) != 0)
-	{
-	  errnum = ERR_PRIVILEGED;
-	  return 1;
-	}
-    }
-  else
-    {
-      len = grub_strlen (arg);
-      
-      // PASSWORD NUL NUL ... 
-      if (len + 2 &gt; PASSWORD_BUFLEN)
-	{
-	  errnum = ERR_WONT_FIT;
-	  return 1;
-	}
-      
-      // Copy the password and clear the rest of the buffer.  
-      password = (char *) PASSWORD_BUF;
-      grub_memmove (password, arg, len);
-      grub_memset (password + len, 0, PASSWORD_BUFLEN - len);
-      password_type = type;
-    }
-  return 0;
-}
-
-static struct builtin builtin_password =
-{
-  &quot;password&quot;,
-  password_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_NO_ECHO,
-  &quot;password [--md5] PASSWD [FILE]&quot;,
-  &quot;If used in the first section of a menu file, disable all&quot;
-  &quot; interactive editing control (menu entry editor and&quot;
-  &quot; command line). If the password PASSWD is entered, it loads the&quot;
-  &quot; FILE as a new config file and restarts the GRUB Stage 2. If you&quot;
-  &quot; omit the argument FILE, then GRUB just unlocks privileged&quot;
-  &quot; instructions.  You can also use it in the script section, in&quot;
-  &quot; which case it will ask for the password, before continueing.&quot;
-  &quot; The option --md5 tells GRUB that PASSWD is encrypted with&quot;
-  &quot; md5crypt.&quot;
-};
-*/
-
-/* interactive pause */
-static int
-ipause_func (char *arg, int flags)
-{
-if (cat_is_on) {
-
-  printf(&quot;%s\n&quot;, arg);
-
-  /* If ESC is returned, then abort this entry.  */
-  if (ASCII_CHAR (getkey ()) == 27)
-    return 1;
-
-}
-  return 0;
-}
-
-static struct builtin builtin_ipause =
-{
-  &quot;ipause&quot;,
-  ipause_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE,
-  &quot;ipause [MESSAGE ...]&quot;,
-  &quot;Print MESSAGE, then wait until a key is pressed.&quot;
-  &quot;(Conditioned to catis value)&quot;
-};
-
-/* pause */
-static int
-pause_func (char *arg, int flags)
-{
-  printf(&quot;%s\n&quot;, arg);
-  /* If ESC is returned, then abort this entry.  */
-  if (ASCII_CHAR (getkey ()) == 27)
-    return 1;
-  return 0;
-}
-
-static struct builtin builtin_pause =
-{
-  &quot;pause&quot;,
-  pause_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE,
-  &quot;pause [MESSAGE ...]&quot;,
-  &quot;Print MESSAGE, then wait until a key is pressed.&quot;
-};
-
-
-#ifdef GRUB_UTIL
-/* quit */
-static int
-quit_func (char *arg, int flags)
-{
-  stop ();
-  
-  /* Never reach here.  */
-  return 0;
-}
-
-static struct builtin builtin_quit =
-{
-  &quot;quit&quot;,
-  quit_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;quit&quot;,
-  &quot;Exit from the GRUB shell.&quot;
-};
-#endif /* GRUB_UTIL */
-
-
-static int
-read_func (char *arg, int flags)
-{
-  int addr;
-
-  if (! safe_parse_maxint (&amp;arg, &amp;addr))
-    return 1;
-
-  grub_printf (&quot;Address 0x%x: Value 0x%x\n&quot;,
-	       addr, *((unsigned *) RAW_ADDR (addr)));
-  return 0;
-}
-
-static struct builtin builtin_read =
-{
-  &quot;read&quot;,
-  read_func,
-  BUILTIN_CMDLINE,
-  &quot;read ADDR&quot;,
-  &quot;Read a 32-bit value from memory at address ADDR and&quot;
-  &quot; display it in hex format.&quot;
-};
-
-
-/* reboot */
-static int
-reboot_func (char *arg, int flags)
-{
-  grub_reboot ();
-
-  /* Never reach here.  */
-  return 1;
-}
-
-static struct builtin builtin_reboot =
-{
-  &quot;reboot&quot;,
-  reboot_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;reboot&quot;,
-  &quot;Reboot your system.&quot;
-};
-
-
-/* Print the root device information.  */
-static void
-print_root_device (void)
-{
-  if (saved_drive == NETWORK_DRIVE)
-    {
-      /* Network drive.  */
-      grub_printf (&quot; (nd):&quot;);
-    }
-else if ((cdrom_drive != GRUB_INVALID_DRIVE) &amp;&amp;(saved_drive==cdrom_drive)) 
-	{
-	/* cdrom drive */
-      grub_printf (&quot; (cd):&quot;);
-	}
-  else if (saved_drive &amp; 0x80)
-    {
-      /* Hard disk drive.  */
-      grub_printf (&quot; (hd%d&quot;, saved_drive - 0x80);
-      
-      if ((saved_partition &amp; 0xFF0000) != 0xFF0000)
-	grub_printf (&quot;,%d&quot;, saved_partition &gt;&gt; 16);
-
-      if ((saved_partition &amp; 0x00FF00) != 0x00FF00)
-	grub_printf (&quot;,%c&quot;, ((saved_partition &gt;&gt; 8) &amp; 0xFF) + 'a');
-
-      grub_printf (&quot;):&quot;);
-    }
-  else
-    {
-      /* Floppy disk drive.  */
-      grub_printf (&quot; (fd%d):&quot;, saved_drive);
-    }
-
-  /* Print the filesystem information.  */
-  current_partition = saved_partition;
-  current_drive = saved_drive;
-  print_fsys_type ();
-}
-
-static int
-real_root_func (char *arg, int attempt_mount)
-{
-  int hdbias = 0;
-  char *biasptr;
-  char *next;
-
-  /* If ARG is empty, just print the current root device.  */
-  if (! *arg)
-    {
-      print_root_device ();
-      return 0;
-    }
-  
-  /* Call set_device to get the drive and the partition in ARG.  */
-  next = set_device (arg);
-  if (! next)
-    return 1;
-
-  /* Ignore ERR_FSYS_MOUNT.  */
-  if (attempt_mount)
-    {
-      if (! open_device () &amp;&amp; errnum != ERR_FSYS_MOUNT)
-	return 1;
-    }
-  else
-    {
-      /* This is necessary, because the location of a partition table
-	 must be set appropriately.  */
-      if (open_partition ())
-	{
-	  saved_drive = current_drive; // Let's update saved_drive with value from open_partition - adrian15
-	  set_bootdev (0);
-	  if (errnum)
-	    return 1;
-	}
-    }
-  
-  /* Clear ERRNUM.  */
-  errnum = 0;
-  saved_partition = current_partition;
-  saved_drive = current_drive;
-
-  if (attempt_mount)
-    {
-      /* BSD and chainloading evil hacks !!  */
-      biasptr = skip_to (0, next);
-      safe_parse_maxint (&amp;biasptr, &amp;hdbias);
-      errnum = 0;
-      bootdev = set_bootdev (hdbias);
-      if (errnum)
-	return 1;
-      
-      /* Print the type of the filesystem.  */
-      print_fsys_type ();
-    }
-  
-  return 0;
-}
-
-static int
-root_func (char *arg, int flags)
-{
-  return real_root_func (arg, 1);
-}
-
-static struct builtin builtin_root =
-{
-  &quot;root&quot;,
-  root_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;root [DEVICE [HDBIAS]]&quot;,
-  &quot;Set the current \&quot;root device\&quot; to the device DEVICE, then&quot;
-  &quot; attempt to mount it to get the partition size (for passing the&quot;
-  &quot; partition descriptor in `ES:ESI', used by some chain-loaded&quot;
-  &quot; bootloaders), the BSD drive-type (for booting BSD kernels using&quot;
-  &quot; their native boot format), and correctly determine &quot;
-  &quot; the PC partition where a BSD sub-partition is located. The&quot;
-  &quot; optional HDBIAS parameter is a number to tell a BSD kernel&quot;
-  &quot; how many BIOS drive numbers are on controllers before the current&quot;
-  &quot; one. For example, if there is an IDE disk and a SCSI disk, and your&quot;
-  &quot; FreeBSD root partition is on the SCSI disk, then use a `1' for HDBIAS.&quot;
-};
-
-
-/* rootnoverify */
-static int
-rootnoverify_func (char *arg, int flags)
-{
-  return real_root_func (arg, 0);
-}
-
-static struct builtin builtin_rootnoverify =
-{
-  &quot;rootnoverify&quot;,
-  rootnoverify_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;rootnoverify [DEVICE [HDBIAS]]&quot;,
-  &quot;Similar to `root', but don't attempt to mount the partition. This&quot;
-  &quot; is useful for when an OS is outside of the area of the disk that&quot;
-  &quot; GRUB can read, but setting the correct root device is still&quot;
-  &quot; desired. Note that the items mentioned in `root' which&quot;
-  &quot; derived from attempting the mount will NOT work correctly.&quot;
-};
-
-
-/* savedefault
-static int
-savedefault_func (char *arg, int flags)
-{
-#if !defined(SUPPORT_DISKLESS) &amp;&amp; !defined(GRUB_UTIL)
-  unsigned long tmp_drive = saved_drive;
-  unsigned long tmp_partition = saved_partition;
-  char *default_file = (char *) DEFAULT_FILE_BUF;
-  char buf[10];
-  char sect[SECTOR_SIZE];
-  int entryno;
-  int sector_count = 0;
-  int saved_sectors[2];
-  int saved_offsets[2];
-  int saved_lengths[2];
-
-  // Save sector information about at most two sectors.  
-  auto void disk_read_savesect_func (int sector, int offset, int length);
-  void disk_read_savesect_func (int sector, int offset, int length)
-    {
-      if (sector_count &lt; 2)
-	{
-	  saved_sectors[sector_count] = sector;
-	  saved_offsets[sector_count] = offset;
-	  saved_lengths[sector_count] = length;
-	}
-      sector_count++;
-    }
-  
-  // This command is only useful when you boot an entry from the menu interface.  
-  if (! (flags &amp; BUILTIN_SCRIPT))
-    {
-      errnum = ERR_UNRECOGNIZED;
-      return 1;
-    }
-
-  // Determine a saved entry number.  
-  if (*arg)
-    {
-      if (grub_memcmp (arg, &quot;fallback&quot;, sizeof (&quot;fallback&quot;) - 1) == 0)
-	{
-	  int i;
-	  int index = 0;
-	  
-	  for (i = 0; i &lt; MAX_FALLBACK_ENTRIES; i++)
-	    {
-	      if (fallback_entries[i] &lt; 0)
-		break;
-	      if (fallback_entries[i] == current_entryno)
-		{
-		  index = i + 1;
-		  break;
-		}
-	    }
-	  
-	  if (index &gt;= MAX_FALLBACK_ENTRIES || fallback_entries[index] &lt; 0)
-	    {
-	      // This is the last.  
-	      errnum = ERR_BAD_ARGUMENT;
-	      return 1;
-	    }
-
-	  entryno = fallback_entries[index];
-	}
-      else if (! safe_parse_maxint (&amp;arg, &amp;entryno))
-	return 1;
-    }
-  else
-    entryno = current_entryno;
-
-  // Open the default file.  
-  saved_drive = boot_drive;
-  saved_partition = install_partition;
-  if (grub_open (default_file))
-    {
-      int len;
-      
-      disk_read_hook = disk_read_savesect_func;
-      len = grub_read (buf, sizeof (buf));
-      disk_read_hook = 0;
-      grub_close ();
-      
-      if (len != sizeof (buf))
-	{
-	  // This is too small. Do not modify the file manually, please!  
-	  errnum = ERR_READ;
-	  goto fail;
-	}
-
-      if (sector_count &gt; 2)
-	{
-	  // Is this possible?! Too fragmented!  
-	  errnum = ERR_FSYS_CORRUPT;
-	  goto fail;
-	}
-      
-      // Set up a string to be written.  
-      grub_memset (buf, '\n', sizeof (buf));
-      grub_sprintf (buf, &quot;%d&quot;, entryno);
-      
-      if (saved_lengths[0] &lt; sizeof (buf))
-	{
-	  // The file is anchored to another file and the first few bytes
-	  // are spanned in two sectors. Uggh... 
-	  if (! rawread (current_drive, saved_sectors[0], 0, SECTOR_SIZE,
-			 sect))
-	    goto fail;
-	  grub_memmove (sect + saved_offsets[0], buf, saved_lengths[0]);
-	  if (! rawwrite (current_drive, saved_sectors[0], sect))
-	    goto fail;
-
-	  if (! rawread (current_drive, saved_sectors[1], 0, SECTOR_SIZE,
-			 sect))
-	    goto fail;
-	  grub_memmove (sect + saved_offsets[1],
-			buf + saved_lengths[0],
-			sizeof (buf) - saved_lengths[0]);
-	  if (! rawwrite (current_drive, saved_sectors[1], sect))
-	    goto fail;
-	}
-      else
-	{
-	  // This is a simple case. It fits into a single sector.  
-	  if (! rawread (current_drive, saved_sectors[0], 0, SECTOR_SIZE,
-			 sect))
-	    goto fail;
-	  grub_memmove (sect + saved_offsets[0], buf, sizeof (buf));
-	  if (! rawwrite (current_drive, saved_sectors[0], sect))
-	    goto fail;
-	}
-
-      // Clear the cache.  
-      buf_track = -1;
-    }
-
- fail:
-  saved_drive = tmp_drive;
-  saved_partition = tmp_partition;
-  return errnum;
-#else 
-// ! SUPPORT_DISKLESS &amp;&amp; ! GRUB_UTIL 
-  errnum = ERR_UNRECOGNIZED;
-  return 1;
-#endif 
-// ! SUPPORT_DISKLESS &amp;&amp; ! GRUB_UTIL 
-}
-
-static struct builtin builtin_savedefault =
-{
-  &quot;savedefault&quot;,
-  savedefault_func,
-  BUILTIN_CMDLINE,
-  &quot;savedefault [NUM | `fallback']&quot;,
-  &quot;Save the current entry as the default boot entry if no argument is&quot;
-  &quot; specified. If a number is specified, this number is saved. If&quot;
-  &quot; `fallback' is used, next fallback entry is saved.&quot;
-};
-*/
-
-/* setkey */
-struct keysym
-{
-  char *unshifted_name;			/* the name in unshifted state */
-  char *shifted_name;			/* the name in shifted state */
-  unsigned char unshifted_ascii;	/* the ascii code in unshifted state */
-  unsigned char shifted_ascii;		/* the ascii code in shifted state */
-  unsigned char keycode;		/* keyboard scancode */
-};
-
-/* The table for key symbols. If the &quot;shifted&quot; member of an entry is
-   NULL, the entry does not have shifted state.  */
-static struct keysym keysym_table[] =
-{
-  {&quot;escape&quot;,		0,		0x1b,	0,	0x01},
-  {&quot;1&quot;,			&quot;exclam&quot;,	'1',	'!',	0x02},
-  {&quot;2&quot;,			&quot;at&quot;,		'2',	'@',	0x03},
-  {&quot;3&quot;,			&quot;numbersign&quot;,	'3',	'#',	0x04},
-  {&quot;4&quot;,			&quot;dollar&quot;,	'4',	'$',	0x05},
-  {&quot;5&quot;,			&quot;percent&quot;,	'5',	'%',	0x06},
-  {&quot;6&quot;,			&quot;caret&quot;,	'6',	'^',	0x07},
-  {&quot;7&quot;,			&quot;ampersand&quot;,	'7',	'&amp;',	0x08},
-  {&quot;8&quot;,			&quot;asterisk&quot;,	'8',	'*',	0x09},
-  {&quot;9&quot;,			&quot;parenleft&quot;,	'9',	'(',	0x0a},
-  {&quot;0&quot;,			&quot;parenright&quot;,	'0',	')',	0x0b},
-  {&quot;minus&quot;,		&quot;underscore&quot;,	'-',	'_',	0x0c},
-  {&quot;equal&quot;,		&quot;plus&quot;,		'=',	'+',	0x0d},
-  {&quot;backspace&quot;,		0,		'\b',	0,	0x0e},
-  {&quot;tab&quot;,		0,		'\t',	0,	0x0f},
-  {&quot;q&quot;,			&quot;Q&quot;,		'q',	'Q',	0x10},
-  {&quot;w&quot;,			&quot;W&quot;,		'w',	'W',	0x11},
-  {&quot;e&quot;,			&quot;E&quot;,		'e',	'E',	0x12},
-  {&quot;r&quot;,			&quot;R&quot;,		'r',	'R',	0x13},
-  {&quot;t&quot;,			&quot;T&quot;,		't',	'T',	0x14},
-  {&quot;y&quot;,			&quot;Y&quot;,		'y',	'Y',	0x15},
-  {&quot;u&quot;,			&quot;U&quot;,		'u',	'U',	0x16},
-  {&quot;i&quot;,			&quot;I&quot;,		'i',	'I',	0x17},
-  {&quot;o&quot;,			&quot;O&quot;,		'o',	'O',	0x18},
-  {&quot;p&quot;,			&quot;P&quot;,		'p',	'P',	0x19},
-  {&quot;bracketleft&quot;,	&quot;braceleft&quot;,	'[',	'{',	0x1a},
-  {&quot;bracketright&quot;,	&quot;braceright&quot;,	']',	'}',	0x1b},
-  {&quot;enter&quot;,		0,		'\n',	0,	0x1c},
-  {&quot;control&quot;,		0,		0,	0,	0x1d},
-  {&quot;a&quot;,			&quot;A&quot;,		'a',	'A',	0x1e},
-  {&quot;s&quot;,			&quot;S&quot;,		's',	'S',	0x1f},
-  {&quot;d&quot;,			&quot;D&quot;,		'd',	'D',	0x20},
-  {&quot;f&quot;,			&quot;F&quot;,		'f',	'F',	0x21},
-  {&quot;g&quot;,			&quot;G&quot;,		'g',	'G',	0x22},
-  {&quot;h&quot;,			&quot;H&quot;,		'h',	'H',	0x23},
-  {&quot;j&quot;,			&quot;J&quot;,		'j',	'J',	0x24},
-  {&quot;k&quot;,			&quot;K&quot;,		'k',	'K',	0x25},
-  {&quot;l&quot;,			&quot;L&quot;,		'l',	'L',	0x26},
-  {&quot;semicolon&quot;,		&quot;colon&quot;,	';',	':',	0x27},
-  {&quot;quote&quot;,		&quot;doublequote&quot;,	'\'',	'&quot;',	0x28},
-  {&quot;backquote&quot;,		&quot;tilde&quot;,	'`',	'~',	0x29},
-  {&quot;shift&quot;,		0,		0,	0,	0x2a},
-  {&quot;backslash&quot;,		&quot;bar&quot;,		'\\',	'|',	0x2b},
-  {&quot;z&quot;,			&quot;Z&quot;,		'z',	'Z',	0x2c},
-  {&quot;x&quot;,			&quot;X&quot;,		'x',	'X',	0x2d},
-  {&quot;c&quot;,			&quot;C&quot;,		'c',	'C',	0x2e},
-  {&quot;v&quot;,			&quot;V&quot;,		'v',	'V',	0x2f},
-  {&quot;b&quot;,			&quot;B&quot;,		'b',	'B',	0x30},
-  {&quot;n&quot;,			&quot;N&quot;,		'n',	'N',	0x31},
-  {&quot;m&quot;,			&quot;M&quot;,		'm',	'M',	0x32},
-  {&quot;comma&quot;,		&quot;less&quot;,		',',	'&lt;',	0x33},
-  {&quot;period&quot;,		&quot;greater&quot;,	'.',	'&gt;',	0x34},
-  {&quot;slash&quot;,		&quot;question&quot;,	'/',	'?',	0x35},
-  {&quot;alt&quot;,		0,		0,	0,	0x38},
-  {&quot;space&quot;,		0,		' ',	0,	0x39},
-  {&quot;capslock&quot;,		0,		0,	0,	0x3a},
-  {&quot;F1&quot;,		0,		0,	0,	0x3b},
-  {&quot;F2&quot;,		0,		0,	0,	0x3c},
-  {&quot;F3&quot;,		0,		0,	0,	0x3d},
-  {&quot;F4&quot;,		0,		0,	0,	0x3e},
-  {&quot;F5&quot;,		0,		0,	0,	0x3f},
-  {&quot;F6&quot;,		0,		0,	0,	0x40},
-  {&quot;F7&quot;,		0,		0,	0,	0x41},
-  {&quot;F8&quot;,		0,		0,	0,	0x42},
-  {&quot;F9&quot;,		0,		0,	0,	0x43},
-  {&quot;F10&quot;,		0,		0,	0,	0x44},
-  /* Caution: do not add NumLock here! we cannot deal with it properly.  */
-  {&quot;delete&quot;,		0,		0x7f,	0,	0x53}
-};
-
-static int
-setkey_func (char *arg, int flags)
-{
-  char *to_key, *from_key;
-  int to_code, from_code;
-  int map_in_interrupt = 0;
-  
-  auto int find_key_code (char *key);
-  auto int find_ascii_code (char *key);
-  
-  auto int find_key_code (char *key)
-    {
-      int i;
-
-      for (i = 0; i &lt; sizeof (keysym_table) / sizeof (keysym_table[0]); i++)
-	{
-	  if (keysym_table[i].unshifted_name &amp;&amp;
-	      grub_strcmp (key, keysym_table[i].unshifted_name) == 0)
-	    return keysym_table[i].keycode;
-	  else if (keysym_table[i].shifted_name &amp;&amp;
-		   grub_strcmp (key, keysym_table[i].shifted_name) == 0)
-	    return keysym_table[i].keycode;
-	}
-      
-      return 0;
-    }
-  
-  auto int find_ascii_code (char *key)
-    {
-      int i;
-      
-      for (i = 0; i &lt; sizeof (keysym_table) / sizeof (keysym_table[0]); i++)
-	{
-	  if (keysym_table[i].unshifted_name &amp;&amp;
-	      grub_strcmp (key, keysym_table[i].unshifted_name) == 0)
-	    return keysym_table[i].unshifted_ascii;
-	  else if (keysym_table[i].shifted_name &amp;&amp;
-		   grub_strcmp (key, keysym_table[i].shifted_name) == 0)
-	    return keysym_table[i].shifted_ascii;
-	}
-      
-      return 0;
-    }
-  
-  to_key = arg;
-  from_key = skip_to (0, to_key);
-
-  if (! *to_key)
-    {
-      /* If the user specifies no argument, reset the key mappings.  */
-      grub_memset (bios_key_map, 0, KEY_MAP_SIZE * sizeof (unsigned short));
-      grub_memset (ascii_key_map, 0, KEY_MAP_SIZE * sizeof (unsigned short));
-
-      return 0;
-    }
-  else if (! *from_key)
-    {
-      /* The user must specify two arguments or zero argument.  */
-      errnum = ERR_BAD_ARGUMENT;
-      return 1;
-    }
-  
-  nul_terminate (to_key);
-  nul_terminate (from_key);
-  
-  to_code = find_ascii_code (to_key);
-  from_code = find_ascii_code (from_key);
-  if (! to_code || ! from_code)
-    {
-      map_in_interrupt = 1;
-      to_code = find_key_code (to_key);
-      from_code = find_key_code (from_key);
-      if (! to_code || ! from_code)
-	{
-	  errnum = ERR_BAD_ARGUMENT;
-	  return 1;
-	}
-    }
-  
-  if (map_in_interrupt)
-    {
-      int i;
-      
-      /* Find an empty slot.  */
-      for (i = 0; i &lt; KEY_MAP_SIZE; i++)
-	{
-	  if ((bios_key_map[i] &amp; 0xff) == from_code)
-	    /* Perhaps the user wants to overwrite the map.  */
-	    break;
-	  
-	  if (! bios_key_map[i])
-	    break;
-	}
-      
-      if (i == KEY_MAP_SIZE)
-	{
-	  errnum = ERR_WONT_FIT;
-	  return 1;
-	}
-      
-      if (to_code == from_code)
-	/* If TO is equal to FROM, delete the entry.  */
-	grub_memmove ((char *) &amp;bios_key_map[i],
-		      (char *) &amp;bios_key_map[i + 1],
-		      sizeof (unsigned short) * (KEY_MAP_SIZE - i));
-      else
-	bios_key_map[i] = (to_code &lt;&lt; 8) | from_code;
-      
-      /* Ugly but should work.  */
-      unset_int15_handler ();
-      set_int15_handler ();
-    }
-  else
-    {
-      int i;
-      
-      /* Find an empty slot.  */
-      for (i = 0; i &lt; KEY_MAP_SIZE; i++)
-	{
-	  if ((ascii_key_map[i] &amp; 0xff) == from_code)
-	    /* Perhaps the user wants to overwrite the map.  */
-	    break;
-	  
-	  if (! ascii_key_map[i])
-	    break;
-	}
-      
-      if (i == KEY_MAP_SIZE)
-	{
-	  errnum = ERR_WONT_FIT;
-	  return 1;
-	}
-      
-      if (to_code == from_code)
-	/* If TO is equal to FROM, delete the entry.  */
-	grub_memmove ((char *) &amp;ascii_key_map[i],
-		      (char *) &amp;ascii_key_map[i + 1],
-		      sizeof (unsigned short) * (KEY_MAP_SIZE - i));
-      else
-	ascii_key_map[i] = (to_code &lt;&lt; 8) | from_code;
-    }
-      
-  return 0;
-}
-
-static struct builtin builtin_setkey =
-{
-  &quot;setkey&quot;,
-  setkey_func,
-  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
-  &quot;setkey [TO_KEY FROM_KEY]&quot;,
-  &quot;Change the keyboard map. The key FROM_KEY is mapped to the key TO_KEY.&quot;
-  &quot; A key must be an alphabet, a digit, or one of these: escape, exclam,&quot;
-  &quot; at, numbersign, dollar, percent, caret, ampersand, asterisk, parenleft,&quot;
-  &quot; parenright, minus, underscore, equal, plus, backspace, tab, bracketleft,&quot;
-  &quot; braceleft, bracketright, braceright, enter, control, semicolon, colon,&quot;
-  &quot; quote, doublequote, backquote, tilde, shift, backslash, bar, comma,&quot;
-  &quot; less, period, greater, slash, question, alt, space, capslock, FX (X&quot;
-  &quot; is a digit), and delete. If no argument is specified, reset key&quot;
-  &quot; mappings.&quot;
-};
-
-
-/* setup */
-static int
-setup_func (char *arg, int flags)
-{
-  /* Point to the string of the installed drive/partition.  */
-  char *install_ptr;
-  /* Point to the string of the drive/parition where the GRUB images
-     reside.  */
-  char *image_ptr;
-  unsigned long installed_drive, installed_partition;
-  unsigned long image_drive, image_partition;
-  unsigned long tmp_drive, tmp_partition;
-  char stage1[64];
-  char stage2[64];
-  char config_filename[64];
-  char real_config_filename[64];
-  char cmd_arg[256];
-  char device[16];
-  char *buffer = (char *) RAW_ADDR (0x100000);
-  int is_force_lba = 0;
-  int is_force_embed = 0;
-  int is_stage1_5_not_linked = 0;
-  char *stage2_arg = 0;
-  char *prefix = 0;
-
-  auto int check_file (char *file);
-  auto void sprint_device (int drive, int partition);
-  auto int embed_stage1_5 (char * stage1_5, int drive, int partition);
-  
-  /* Check if the file FILE exists like Autoconf.  */
-  int check_file (char *file)
-    {
-      int ret;
-      
-      grub_printf (&quot; Checking if \&quot;%s\&quot; exists... &quot;, file);
-      ret = grub_open (file);
-      if (ret)
-	{
-	  grub_close ();
-	  grub_printf (&quot;yes\n&quot;);
-	}
-      else
-	grub_printf (&quot;no\n&quot;);
-
-      return ret;
-    }
-  
-  /* Construct a device name in DEVICE.  */
-  void sprint_device (int drive, int partition)
-    {
-      grub_sprintf (device, &quot;(%cd%d&quot;,
-		    (drive &amp; 0x80) ? 'h' : 'f',
-		    drive &amp; ~0x80);
-      if ((partition &amp; 0xFF0000) != 0xFF0000)
-	{
-	  char tmp[16];
-	  grub_sprintf (tmp, &quot;,%d&quot;, (partition &gt;&gt; 16) &amp; 0xFF);
-	  grub_strncat (device, tmp, 256);
-	}
-      if ((partition &amp; 0x00FF00) != 0x00FF00)
-	{
-	  char tmp[16];
-	  grub_sprintf (tmp, &quot;,%c&quot;, 'a' + ((partition &gt;&gt; 8) &amp; 0xFF));
-	  grub_strncat (device, tmp, 256);
-	}
-      grub_strncat (device, &quot;)&quot;, 256);
-    }
-  
-  int embed_stage1_5 (char *stage1_5, int drive, int partition)
-    {
-      /* We install GRUB into the MBR, so try to embed the
-	 Stage 1.5 in the sectors right after the MBR.  */
-      sprint_device (drive, partition);
-      grub_sprintf (cmd_arg, &quot;%s %s&quot;, stage1_5, device);
-	      
-      /* Notify what will be run.  */
-      grub_printf (&quot; Running \&quot;embed %s\&quot;... &quot;, cmd_arg);
-      
-      embed_func (cmd_arg, flags);
-      if (! errnum)
-	{
-	  /* Construct the blocklist representation.  */
-	  grub_sprintf (buffer, &quot;%s%s&quot;, device, embed_info);
-	  grub_printf (&quot;succeeded\n&quot;);
-	  return 1;
-	}
-      else
-	{
-	  grub_printf (&quot;failed (this is not fatal)\n&quot;);
-	  return 0;
-	}
-    }
-	  
-  struct stage1_5_map {
-    char *fsys;
-    char *name;
-  };
-  struct stage1_5_map stage1_5_map[] =
-  {
-    {&quot;ext2fs&quot;,   &quot;/e2fs_stage1_5&quot;},
-    {&quot;fat&quot;,      &quot;/fat_stage1_5&quot;},
-    {&quot;ufs&quot;,     &quot;/ufs_stage1_5&quot;},
-    {&quot;ufs2&quot;,     &quot;/ufs2_stage1_5&quot;},
-    {&quot;ffs&quot;,      &quot;/ffs_stage1_5&quot;},
-    {&quot;iso9660&quot;,  &quot;/iso9660_stage1_5&quot;},
-    {&quot;jfs&quot;,      &quot;/jfs_stage1_5&quot;},
-    {&quot;minix&quot;,    &quot;/minix_stage1_5&quot;},
-    {&quot;reiserfs&quot;, &quot;/reiserfs_stage1_5&quot;},
-    {&quot;vstafs&quot;,   &quot;/vstafs_stage1_5&quot;},
-    {&quot;xfs&quot;,      &quot;/xfs_stage1_5&quot;}
-  };
-
-  tmp_drive = saved_drive;
-  tmp_partition = saved_partition;
-
-  /* Check if the user specifies --force-lba.  */
-  while (1)
-    {
-      if (grub_memcmp (&quot;--force-embed&quot;, arg, sizeof (&quot;--force-embed&quot;) - 1) == 0)
-	{
-	  is_force_embed = 1;
-	  arg = skip_to (0, arg);
-	}
-      else if (grub_memcmp (&quot;--force-lba&quot;, arg, sizeof (&quot;--force-lba&quot;) - 1) == 0)
-	{
-	  is_force_lba = 1;
-	  arg = skip_to (0, arg);
-	}
-      else if (grub_memcmp (&quot;--stage1_5-not-linked&quot;, arg, sizeof (&quot;--stage1_5-not-linked&quot;) - 1) == 0)
-	{
-	  is_stage1_5_not_linked = 1;
-	  arg = skip_to (0, arg);
-	}
-      else if (grub_memcmp (&quot;--prefix=&quot;, arg, sizeof (&quot;--prefix=&quot;) - 1) == 0)
-	{
-	  prefix = arg + sizeof (&quot;--prefix=&quot;) - 1;
-	  arg = skip_to (0, arg);
-	  nul_terminate (prefix);
-	}
-#ifdef GRUB_UTIL
-      else if (grub_memcmp (&quot;--stage2=&quot;, arg, sizeof (&quot;--stage2=&quot;) - 1) == 0)
-	{
-	  stage2_arg = arg;
-	  arg = skip_to (0, arg);
-	  nul_terminate (stage2_arg);
-	}
-#endif /* GRUB_UTIL */
-      else
-	break;
-    }
-  
-  install_ptr = arg;
-  image_ptr = skip_to (0, install_ptr);
-
-  /* Make sure that INSTALL_PTR is valid.  */
-  set_device (install_ptr);
-  if (errnum)
-    return 1;
-
-  installed_drive = current_drive;
-  installed_partition = current_partition;
-  
-  /* Mount the drive pointed by IMAGE_PTR.  */
-  if (*image_ptr)
-    {
-      /* If the drive/partition where the images reside is specified,
-	 get the drive and the partition.  */
-      set_device (image_ptr);
-      if (errnum)
-	return 1;
-    }
-  else
-    {
-      /* If omitted, use SAVED_PARTITION and SAVED_DRIVE.  */
-      current_drive = saved_drive;
-      current_partition = saved_partition;
-    }
-
-  image_drive = saved_drive = current_drive;
-  image_partition = saved_partition = current_partition;
-
-  /* Open it.  */
-  if (! open_device ())
-    goto fail;
-
-  /* Check if stage1 exists. If the user doesn't specify the option
-     `--prefix', attempt /boot/grub and /grub and /lib/grub.  */
-  /* NOTE: It is dangerous to run this command without `--prefix' in the
-     grub shell, since that affects `--stage2'.  */
-  if (! prefix)
-    {
-      prefix = &quot;/boot/grub&quot;;
-      grub_sprintf (stage1, &quot;%s%s&quot;, prefix, &quot;/stage1&quot;);
-      if (! check_file (stage1))
-	{
-	  errnum = ERR_NONE;
-	  prefix = &quot;/grub&quot;;
-	  grub_sprintf (stage1, &quot;%s%s&quot;, prefix, &quot;/stage1&quot;);
-	  if (! check_file (stage1))
-	    {
-	      errnum = ERR_NONE;
-	      prefix = &quot;/lib/grub/i386-pc&quot;;
-	      grub_sprintf (stage1, &quot;%s%s&quot;, prefix, &quot;/stage1&quot;);
-	      if (! check_file (stage1))
-	      goto fail;
-	    }
-	}
-    }
-  else
-    {
-      grub_sprintf (stage1, &quot;%s%s&quot;, prefix, &quot;/stage1&quot;);
-      if (! check_file (stage1))
-	goto fail;
-    }
-
-  /* The prefix was determined.  */
-  grub_sprintf (stage2, &quot;%s%s&quot;, prefix, &quot;/stage2&quot;);
-  grub_sprintf (config_filename, &quot;%s%s&quot;, prefix, &quot;/menu.lst&quot;);
-  *real_config_filename = 0;
-
-  /* Check if stage2 exists.  */
-  if (! check_file (stage2))
-    goto fail;
-
-if (! is_stage1_5_not_linked)
-
-  {
-    char *fsys = fsys_table[fsys_type].name;
-    int i;
-    int size = sizeof (stage1_5_map) / sizeof (stage1_5_map[0]);
-    
-    /* Iterate finding the same filesystem name as FSYS.  */
-    for (i = 0; i &lt; size; i++)
-      if (grub_strcmp (fsys, stage1_5_map[i].fsys) == 0)
-	{
-	  /* OK, check if the Stage 1.5 exists.  */
-	  char stage1_5[64];
-	  
-	  grub_sprintf (stage1_5, &quot;%s%s&quot;, prefix, stage1_5_map[i].name);
-	  if (check_file (stage1_5))
-	    {
-	      if (embed_stage1_5 (stage1_5, 
-				    installed_drive, installed_partition)
-		  || embed_stage1_5 (stage1_5, 
-				     image_drive, image_partition))
-		{
-		  grub_strcpy (real_config_filename, config_filename);
-		  sprint_device (image_drive, image_partition);
-		  grub_sprintf (config_filename, &quot;%s%s&quot;, device, stage2);
-		  grub_strcpy (stage2, buffer);
-		}
-	    }
-	  errnum = 0;
-	  break;
-	}
-  }
-
-  /* Construct a string that is used by the command &quot;install&quot; as its
-     arguments.  */
-  sprint_device (installed_drive, installed_partition);
-  
-#if 1
-  /* Don't embed a drive number unnecessarily.  */
-  grub_sprintf (cmd_arg, &quot;%s%s%s%s%s %s%s %s p %s %s&quot;,
-		is_force_lba? &quot;--force-lba &quot; : &quot;&quot;,
-		is_force_embed? &quot;--force-embed &quot; : &quot;&quot;,
-		stage2_arg? stage2_arg : &quot;&quot;,
-		stage2_arg? &quot; &quot; : &quot;&quot;,
-		stage1,
-		(installed_drive != image_drive) ? &quot;d &quot; : &quot;&quot;,
-		device,
-		stage2,
-		config_filename,
-		real_config_filename);
-#else /* NOT USED */
-  /* This code was used, because we belived some BIOSes had a problem
-     that they didn't pass a booting drive correctly. It turned out,
-     however, stage1 could trash a booting drive when checking LBA support,
-     because some BIOSes modified the register %dx in INT 13H, AH=48H.
-     So it becamed unclear whether GRUB should use a pre-defined booting
-     drive or not. If the problem still exists, it would be necessary to
-     switch back to this code.  */
-  grub_sprintf (cmd_arg, &quot;%s%s%s%s%s d %s %s p %s %s&quot;,
-		is_force_lba? &quot;--force-lba &quot; : &quot;&quot;,
-		is_force_embed? &quot;--force-embed &quot; : &quot;&quot;,
-		stage2_arg? stage2_arg : &quot;&quot;,
-		stage2_arg? &quot; &quot; : &quot;&quot;,
-		stage1,
-		device,
-		stage2,
-		config_filename,
-		real_config_filename);
-#endif /* NOT USED */
-  
-  /* Notify what will be run.  */
-  grub_printf (&quot; Running \&quot;install %s\&quot;... &quot;, cmd_arg);
-
-  /* Make sure that SAVED_DRIVE and SAVED_PARTITION are identical
-     with IMAGE_DRIVE and IMAGE_PARTITION, respectively.  */
-  saved_drive = image_drive;
-  saved_partition = image_partition;
-  
-  /* Run the command.  */
-  if (! install_func (cmd_arg, flags))
-    grub_printf (&quot;succeeded\nDone.\n&quot;);
-  else
-    grub_printf (&quot;failed\n&quot;);
-
- fail:
-  saved_drive = tmp_drive;
-  saved_partition = tmp_partition;
-  return errnum;
-}
-
-static struct builtin builtin_setup =
-{
-  &quot;setup&quot;,
-  setup_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;setup [--prefix=DIR] [--stage2=STAGE2_FILE] [--force-lba] [--force-embed] [--stage1_5-not-linked] INSTALL_DEVICE [IMAGE_DEVICE]&quot;,
-  &quot;Set up the installation of GRUB automatically. This command uses&quot;
-  &quot; the more flexible command \&quot;install\&quot; in the backend and installs&quot;
-  &quot; GRUB into the device INSTALL_DEVICE. If IMAGE_DEVICE is specified,&quot;
-  &quot; then find the GRUB images in the device IMAGE_DEVICE, otherwise&quot;
-  &quot; use the current \&quot;root device\&quot;, which can be set by the command&quot;
-  &quot; \&quot;root\&quot;. If you know that your BIOS should support LBA but GRUB&quot;
-  &quot; doesn't work in LBA mode, specify the option `--force-lba'.&quot;
-  &quot; If you need to use windows to chainload a &quot;
-  &quot; non-first hard disk grub partition image use the option `--force-embed'&quot;
-  &quot; If you install GRUB under the grub shell and you cannot unmount the&quot;
-  &quot; partition where GRUB images reside, specify the option `--stage2'&quot;
-  &quot; to tell GRUB the file name under your OS.&quot;
-  &quot; --stage1_5-not-linked forces stage1_5 not to be linked.&quot;
-};
-
-
-/* timeout */
-static int
-timeout_func (char *arg, int flags)
-{
-  if (! safe_parse_maxint (&amp;arg, &amp;grub_timeout))
-    return 1;
-
-  return 0;
-}
-
-static struct builtin builtin_timeout =
-{
-  &quot;timeout&quot;,
-  timeout_func,
-  BUILTIN_MENU,
-#if 0
-  &quot;timeout SEC&quot;,
-  &quot;Set a timeout, in SEC seconds, before automatically booting the&quot;
-  &quot; default entry (normally the first entry defined).&quot;
-#endif
-};
-
-
-/* title */
-static int
-title_func (char *arg, int flags)
-{
-  /* This function is not actually used at least currently.  */
-  return 0;
-}
-
-static struct builtin builtin_title =
-{
-  &quot;title&quot;,
-  title_func,
-  BUILTIN_TITLE,
-#if 0
-  &quot;title [NAME ...]&quot;,
-  &quot;Start a new boot entry, and set its name to the contents of the&quot;
-  &quot; rest of the line, starting with the first non-space character.&quot;
-#endif
-};
-
-
-/* unhide */
-static int
-unhide_func (char *arg, int flags)
-{
-  if (! set_device (arg))
-    return 1;
-
-  if (! set_partition_hidden_flag (0))
-    return 1;
-
-  return 0;
-}
-
-static struct builtin builtin_unhide =
-{
-  &quot;unhide&quot;,
-  unhide_func,
-  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
-  &quot;unhide PARTITION&quot;,
-  &quot;Unhide PARTITION by clearing the \&quot;hidden\&quot; bit in its&quot;
-  &quot; partition type code.&quot;
-};
-
-/* fdisklu */
-/* Show partitions information.*/
-static int
-fdisklu_func (char *arg, int flags)
-{
-  unsigned long tmp_drive = saved_drive;
-  unsigned long tmp_partition = saved_partition;
-
-int drive; // Aux variables
-
-if (there_is_a_hard_disk ()) { errnum = ERR_FILE_NOT_FOUND; return 1; }
-
-
-
-
-
-
-
-
-
-buf_drive = GRUB_INVALID_DRIVE; // This line makes possible do the find loop for more than one file
-
-
-
-  for (drive = 0x80; drive &lt; 0x90; drive++) {
-
-      unsigned long part = 0xFFFFFF;
-      unsigned long start, len, offset, ext_offset;
-      int type, entry;
-      char buf[SECTOR_SIZE];
-	current_drive = drive;
-      while (next_partition (current_drive, 0xFFFFFF, &amp;part, &amp;type,
-			     &amp;start, &amp;len, &amp;offset, &amp;entry,
-			     &amp;ext_offset, buf))
-	{
-
-	  if (type != PC_SLICE_TYPE_NONE
-	      &amp;&amp; ! IS_PC_SLICE_TYPE_BSD (type)
-	      &amp;&amp; ! IS_PC_SLICE_TYPE_EXTENDED (type))
-	    
-	   {
-
-
-
-	     current_partition = part;
-
-	      if (open_device ())
-		{
-		  saved_drive = current_drive;
-		  saved_partition = current_partition;
-
-			add_part_printf(&amp;type, part, &amp;len);
-
-		  }
-		
-	       }
-
-	  // We want to ignore any error here.  
-	  errnum = ERR_NONE;
-
-	  }
-	}
-      /* next_partition always sets ERRNUM in the last call, so clear
-	 it.  */
-      errnum = ERR_NONE;
-
-
-// NEW CODE - END
-
-// Define the new menu - End 
-  saved_drive = tmp_drive;
-  saved_partition = tmp_partition;
-
-
-  return 0;
-}
-
-static struct builtin builtin_fdisklu =
-{
-  &quot;fdisklu&quot;,
-  fdisklu_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;fdisklu&quot;,
-  &quot;Show partitions information.&quot;
-};
-
-/* selecthd */
-static int
-selecthd_func (char *arg, int flags)
-{
-int i,j, disk_no; // Aux variables
-unsigned long int hd_total_sectors = 0;
-char human_number_buffer[8];
-char *human_number_buffer_ptr=human_number_buffer;
-
-unsigned long tmp_current_drive = current_drive;
-unsigned long tmp_drive = saved_drive;
-unsigned long tmp_partition = saved_partition;
-
-// Check if there's any hard disk before doing anything
-if (there_is_a_hard_disk ()) { errnum = ERR_FILE_NOT_FOUND; return 1; }
-
-
-special_menu = 1; // Force not to read the menu
-
-
-if(add_menu ()) return 1;
-
-
-
-// NEW CODE - BEGIN
-// Add main title
-
-
-add_choose_title ();
-
-
-add_title (&amp;menu_array[menu_level], &quot;NATURAL  LINUX-IDE  LINUX-SCSI  GRUB      HURD   SIZE&quot;);
-add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;pause Nothing to do&quot;);
-close_title ((char *) MENU_BUF, &amp;menu_array[menu_level]);
-
-
-
-// Add title and instructions concerning hard disks
-
-		  for (i = 1;i &lt; 2; i++)
-		    {	
-		      for (j = 0; j &lt; 16; j++)
-			{
-			  struct geometry geom;
-			  disk_no = (i * 0x80) + j;
-			  if (! get_diskinfo (disk_no, &amp;geom))
-			    {
-      // Let's reset hd data on each iteration
-
-      current_drive = disk_no;
-// DEBUG - BEGIN
-  // current_drive=0x80;
-// DEBUG - END
-
-      hd_total_sectors = 0;
-
-      unsigned long part = 0xFFFFFF;
-      unsigned long start, len, offset, ext_offset;
-      int type, entry;
-      char buf[SECTOR_SIZE];
-
-
-
-      while (next_partition (current_drive, 0xFFFFFF, &amp;part, &amp;type,
-			     &amp;start, &amp;len, &amp;offset, &amp;entry,
-			     &amp;ext_offset, buf))
-	{
-
-
-
-	  if (type != PC_SLICE_TYPE_NONE
-	      &amp;&amp; ! IS_PC_SLICE_TYPE_BSD (type)
-	      &amp;&amp; ! IS_PC_SLICE_TYPE_EXTENDED (type))
-	    {
-
-		
-	      hd_total_sectors+=len;
-
-	    }
-
-	  // We want to ignore any error here.  
-	  errnum = ERR_NONE;
-
-	} // End of hd count
-	  errnum = ERR_NONE;
-	hd_total_sectors=(unsigned long int)(hd_total_sectors/2); // Convert 512 bytes blocks into 1024 bytes blocks (aka KB)
-	human_number(human_number_buffer_ptr, &amp;hd_total_sectors);
-
-				// Add title
-				
-				add_title (&amp;menu_array[menu_level], &quot;   %d         hd%c        sd%c     (hd%d)     hd%d   %s&quot;,j + 1,'a'+j,'a'+j, j,j,human_number_buffer_ptr);
-				
-				// Add instructions
-				
-				add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_device=(hd%d)&quot;,j);
-				add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_hd=hd%d&quot;,j);
-				add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_linux_letter=%c&quot;,'a'+j);
-				add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_lide_hd=hd%c&quot;,'a' + j);
-				add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_lscsi_hd=sd%c&quot;,'a' + j);
-				add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;set out_hurd_hd=hd%d&quot;,j);
-				add_instruction (&amp;menu_array[menu_level], (char *) MENU_BUF, &quot;back&quot;);
-
-				close_title ((char *) MENU_BUF, &amp;menu_array[menu_level]);
-
-
-			    } // Disk detected
- 	     errnum = ERR_NONE;
-			} // for j
-	  errnum = ERR_NONE;
-		    } // for i
-
-
-
-close_menu ((char *) MENU_BUF, &amp;menu_array[menu_level]);
-// NEW CODE - END
-
-// Define the new menu - End 
-  saved_drive = tmp_drive;
-  saved_partition = tmp_partition;
-  current_drive = tmp_current_drive;
-
-  configfile_end();
-  /* Never reach here.  */
-  return 0;
-}
-
-static struct builtin builtin_selecthd =
-{
-  &quot;selecthd&quot;,
-  selecthd_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;selecthd&quot;,
-  &quot;Let user select hd and return into the step the configfile was loading..&quot;
-};
-
-
-
-#define VARIABLE_STORE_SIZE 512
-char variable_store[VARIABLE_STORE_SIZE];
-unsigned int variable_store_actpos; /* Points to the next free entry */
-struct variable_list_struct {
-  char *name;
-  char *value;
-} variable_list[VARIABLES_MAX];
-
-static void var_show(void)
-{
-  int i = 0;
-
-  for (; i &lt; VARIABLES_MAX; i++)
-    if (variable_list[i].name)
-      {
-	grub_printf(&quot;%s = %s\n&quot;,
-	            variable_list[i].name,
-		    variable_list[i].value);
-      }
-}
-
-static int var_get_index(char *var)
-{
-  int i = 0;
-
-  if (!*var)
-    return -1;
-
-  for (; i &lt; VARIABLES_MAX; i++)
-    if (variable_list[i].name &amp;&amp;
-	grub_strcmp(variable_list[i].name, var) == 0)
-      return i;
-
-  return -1;
-}
-
-char *var_get(char *var)
-{
-  int i;
-
-  if ((i = var_get_index(var)) == -1)
-    return NULL;
-
-  return variable_list[i].value;
-}
-
-static char *var_alloc_mem(unsigned int len)
-{
-  if (VARIABLE_STORE_SIZE &lt; variable_store_actpos + len
-      || !len)
-    return NULL;
-
-  variable_store_actpos += len;
-  return &amp;variable_store[variable_store_actpos - len];
-}
-
-/* Maybe we're implementing &quot;unset&quot; later? */
-static int var_get_free_var(void)
-{
-  int i = 0;
-
-  for (; i &lt; VARIABLES_MAX; i++)
-    if (variable_list[i].name == NULL)
-      return i;
-
-  return -1;
-}
-
-static inline char *skip_ws(char *s)
-{
-  while (isspace(*s))
-    s++;
-  return s;
-}
-
-static int var_sprint_once(char *buf, char *str)
-{
-
-  char *b = buf;
-
-
-  while (*str)
-    {
-
-      if (*str == '$' &amp;&amp; *(str + 1) == '$')
-	{
-          *b++ = *str++;
-	  str++; 
-	}
-      else if (*str == '$' &amp;&amp; *(str + 1) == '(')
-	{
-	  /* Found start of variable */
-	  char *end_var;
-	  char *c = str + 2;
-
-	  end_var = c;
-	  while (*end_var &amp;&amp; *end_var != ')')
-	    end_var++;
-
-	  if (*end_var == ')')
-	    {
-	      char *val;
-
-	      /* Copy variable name into var */
-
-              str = end_var + 1;
-
-	      *end_var = 0;
-	      if ((val = var_get(c)))
-		{
-		  /* All ok, we got it */
-		  /* Copy to buf */
-		  while (*val)
-		    *b++ = *val++;
-
-		  *end_var = ')';
-
-		  continue;
-		}
-	      /* else
-		grub_printf(&quot;Unknown variable: %var!\n&quot;, var); */
-
-	      *end_var = ')';
-	    }
-	}
-
-      *b++ = *str++;
-    }
-
-  *b = 0;
-
-  return b - buf;
-}
-
-int var_sprint(char *buf, char *str)
-{
-  //int i = 10;
-  /* Waste some stack here... */
-  const int buffer_size = 1000;
-  char buffer[buffer_size];
-
-  grub_strcpy(buf, str);
-
-  /* adrian15 - So that we can parse $$ without any problem
-
- We're not checking any return values here or any array overflows... :( 
-  do
-    {
-      if (grub_strlen(buf) &gt; buffer_size)
-	{
-	  grub_printf(&quot;Buffer overflow: %s(%d)\n&quot;, __FILE__, __LINE__);
-	  while (1) {}
-	}
-      
-      grub_strcpy(buffer, buf);
-
-      var_sprint_once(buf, buffer);
-    }
-  while (--i &amp;&amp; grub_strcmp(buf, buffer));
-
-  if (!i)
-    {
-      grub_printf(&quot;Possible loop in var_sprintf!\n&quot;);
-      getkey();
-    }
-*/
-      if (grub_strlen(buf) &gt; buffer_size)
-	{
-	  grub_printf(&quot;Buffer overflow: %s(%d)\n&quot;, __FILE__, __LINE__);
-	  while (1) {}
-	}
-      
-      grub_strcpy(buffer, buf);
-
-      var_sprint_once(buf, buffer);
-
-  return grub_strlen(buf);
-}
-
-/* Use our own buffer instead of a supplied one and
- * return the pointer to the buffer and not the bytes
- * processed. */
-/* We try to detect buffer overruns... */
-static char var_sprint_buffer[1500];
-static const long var_sprint_magic = 0x14233241;
-char *var_sprint_buf(char *str, int *bytes)
-{
-  *(long *)(var_sprint_buffer + sizeof(var_sprint_buffer) - sizeof(var_sprint_magic)) = var_sprint_magic;
-
-  *bytes = var_sprint(var_sprint_buffer, str);
-
-  if (*(long *)(var_sprint_buffer + sizeof(var_sprint_buffer) - sizeof(var_sprint_magic)) != var_sprint_magic)
-    {
-      grub_printf(&quot;Possible buffer overrun: %s(%d)\n&quot;, __FILE__, __LINE__);
-      while (1) {}
-    }
-  return var_sprint_buffer;
-}
-
-/* This function just updates the pointer to the value, this value has to 
- * be inside the variable_store */
-static int var_set_no_copy(char *name, char *val)
-{
-  int i;
-
-  if (val &lt; variable_store || val &gt;= (variable_store + VARIABLE_STORE_SIZE))
-    return 1;
-
-  i = var_get_index(name);
-
-  if (i == -1)
-    {
-      /* The variable doesn't exist yet, so we have a new variable */
-      char *a = name;
-
-      /* Some sanity check */
-      while (*a)
-	{
-	  if (*a == '(' || *a == ')' || *a == ' ')
-	    return 1;
-	  a++;
-        }
-      
-
-      if ((i = var_get_free_var()) == -1)
-	return 1;
-
-      if ((a = var_alloc_mem(grub_strlen(name) + 1)) == NULL)
-	return 1;
-
-      grub_strcpy(a, name);
-      variable_list[i].name = a;
-    }
-
-  variable_list[i].value = val;
-
-  return 0; /* Ok */
-}
-
-/* XXX: this is a bit code duplication with var_set_no_copy, 
- *      so if someone has some free time, feel free to join this
- */
-int var_set(char *name, char *value, int parse)
-{
-  int i;
-
-  if (parse)
-    value = var_sprint_buf(value, &amp;i);
-
-  i = var_get_index(name);
-
-  if (i == -1)
-    {
-      /* The variable doesn't exist yet, so we have a new variable */
-      char *a = name;
-
-      /* Some sanity check */
-      while (*a)
-	{
-	  if (*a == '(' || *a == ')' || *a == ' ')
-	    return 1;
-	  a++;
-        }
-      
-      if ((i = var_get_free_var()) == -1)
-	return 1;
-
-      if ((a = var_alloc_mem(grub_strlen(name) + 1)) == NULL)
-	return 1;
-
-      grub_strcpy(a, name);
-      variable_list[i].name = a;
-
-      if ((a = var_alloc_mem(grub_strlen(value) + 1)) == NULL)
-	return 1;
-
-      grub_strcpy(a, value);
-      variable_list[i].value = a;
-    } 
-  else
-    {
-      /* Variable already exists */
-      if (grub_strlen(variable_list[i].value) &gt;= grub_strlen(value))
-	{
-	  /* We can just replace the value but we're potentially 
-	   * loosing space */
-	  grub_strcpy(variable_list[i].value, value);
-	}
-      else
-	{
-	  /* New value is longer then the old one, we need to
-	   * allocate a new place and drop the old one (i.e. wasting it) */
-	  char *a;
-	  if ((a = var_alloc_mem(grub_strlen(value) + 1)) == NULL)
-	    return 1;
-
-	  grub_strcpy(a, value);
-
-	  variable_list[i].value = a;
-	}
-    }
-
-  //grub_printf(&quot;Saved %s=\&quot;%s\&quot; in slot %d.\n&quot;, variable_list[i].name, variable_list[i].value, i + 1);
-  //getkey();
-
-  return 0; /* Ok */
-}
-
-
-
-
-static int
-set_func(char *arg, int flags)
-{
-  char *a = arg;
-  char *variable, *value;
-  char *end_variable, end_variable_val;
-  char *end_value, end_value_val;
-  char end_char;
-  int i = 0, parse = 0, emptysetonly = 0;
-
-  a = skip_ws(a);
-
-  if (!*a)
-    {
-      var_show();
-      return 0;
-    }
-
-  variable = a;
-  while (*a &amp;&amp; *a != ':' &amp;&amp; *a != '=' &amp;&amp; *a != ' ')
-    a++;
-  end_variable_val = *a;
-  end_variable = a;
-
-  a = skip_ws(a);
-
-  if (*a == ':')
-    {
-      parse = 1;
-      a++;
-    }
-  if (*a == '?')
-    {
-      emptysetonly = 1;
-      a++;
-    }
-
-  if (*a != '=')
-    goto bad_arg;
-
-  a++;
-  a = skip_ws(a);
-
-  end_char = ' ';
-  if (*a == '&quot;')
-    {
-      end_char = *a;
-      a++;
-    }
-  /* XXX: add/fix \&quot; and \\ stuff */
-  value = a;
-  while (*a &amp;&amp; *a != end_char)
-    a++;
-  end_value_val = *a;
-  end_value = a;
-
-  *end_value = *end_variable = 0;
-
-  if ((emptysetonly &amp;&amp; var_get_index(variable) == -1) ||
-      !emptysetonly)
-    i = var_set(variable, value, parse);
-
-  *end_value    = end_value_val;
-  *end_variable = end_variable_val;
-
-  return i;
-
-bad_arg:
-  grub_printf(&quot;%s: ERR_BAD_ARGUMENT\n&quot;, __func__);
-  getkey();
-  errnum = ERR_BAD_ARGUMENT;
-  return 1;
-}
-
-static struct builtin builtin_set =
-{
-  &quot;set&quot;,
-  set_func,
-  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
-  &quot;set var=val&quot;,
-  &quot;Set a variable to a value.&quot;
-};
-
-static int
-print_func(char *arg, int flags)
-{
-  grub_printf(&quot;%s\n&quot;, var_sprint_buf(arg, &amp;flags));
-  return 0;
-}
-
-static struct builtin builtin_print =
-{
-  &quot;print&quot;,
-  print_func,
-  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
-  &quot;print \&quot;string with vars\&quot;&quot;,
-  &quot;Print a string which may contain variables. Variables are enclosed&quot;
-  &quot; in $( and ) (like \&quot;make\&quot;).&quot;
-};
-
-static struct builtin builtin_echo =
-{
-  &quot;echo&quot;,
-  print_func,
-  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
-  &quot;echo \&quot;string with vars\&quot;&quot;,
-  &quot;Alias for \&quot;print\&quot;.&quot;
-};
-
-
-
-
-#define TOGGLES 2
-#define MAX_BLOCKS 3
-#define MAX_VAR_PER_BLOCK 4
-
-struct toggle_data_struct {
-  int key; /* int because of F-keys !? */
-  int current_block;
-  char nr_blocks;
-  struct {
-    char nr_vars;
-    struct {
-      int var;		/* index of variable_list */
-      char *value;	/* pointer to value */
-    } var[MAX_VAR_PER_BLOCK];
-  } block[MAX_BLOCKS];
-} toggle_data[TOGGLES];
-int toggles_used = 0;
-
-char toggle_trigger_init_done;
-
-static int get_toggle_slot_for_key(int key)
-{
-  int i = 0;
-
-  for (; i &lt; TOGGLES; i++)
-    if (toggle_data[i].key == key)
-      return i;
-
-  return -1;
-}
-
-int toggle_print_status(int x, int y)
-{
-  /* Basically print all variable which are on the left side on toggles */
-  int printed[VARIABLES_MAX];
-  int printed_something = 0;
-  int i, t, b, v, dummy;
-  const int ylines = 6;
-  int xpos[ylines];
-  int dy = 0;
-
-  for (i = 0; i &lt; ylines; i++)
-    xpos[i] = x;
-
-  for (i = 0; i &lt; VARIABLES_MAX; i++)
-    printed[i] = 0;
-
-  for (t = 0; t &lt; toggles_used; t++)
-    {
-      for (b = 0; b &lt; toggle_data[t].nr_blocks; b++)
-	{
-	  for (v = 0; v &lt; toggle_data[t].block[b].nr_vars; v++)
-	    {
-	      i = toggle_data[t].block[b].var[v].var;
-	      if (!printed[i])
-		{
-		  int len;
-		  char *vals;
-
-		  gotoxy(xpos[dy], y + dy);
-
-		  /* don't use printf here since we need the lengths
-		   * of the printed string and we don't want to use another
-		   * buffer for sprintf
-		   */
-		  grub_putstr(variable_list[i].name);
-		  grub_putchar('=');
-		  len = grub_strlen(variable_list[i].name) + 1;
-
-		  vals = var_sprint_buf(variable_list[i].value, &amp;dummy);
-		  grub_putstr(vals);
-		  len += grub_strlen(vals);
-
-		  xpos[dy] += len + 2;
-
-		  if (++dy == ylines) {
-		    dy = 0;
-		  }
-
-		  printed[i] = printed_something = 1;
-		}
-	    }
-	}
-    }
-
-  return printed_something;
-}
-
-static int toggle_do_block(int slot, int block_nr)
-{
-  int v;
-
-  if (slot &gt;= toggles_used || block_nr &gt;= toggle_data[slot].nr_blocks)
-    return 0;
-
-  /* Set all variables in th block block_nr to their new values */
-  for (v = 0; v &lt; toggle_data[slot].block[block_nr].nr_vars; v++)
-    {
-      int l = toggle_data[slot].block[block_nr].var[v].var;
-
-      var_set_no_copy(variable_list[l].name, toggle_data[slot].block[block_nr].var[v].value);
-    }
-
-  return 1; /* Ok */
-}
-
-static int toggle_find_slot(int key)
-{
-  int i = 0;
-
-  for (; i &lt; toggles_used; i++)
-      if (toggle_data[i].key == key)
-	return i;
-
-  return -1;
-} 
-
-int toggle_do_key(int key)
-{
-  int slot;
-
-  if ((slot = toggle_find_slot(key)) == -1)
-    return 0;
-
-  /* Proceed to the next block */
-  if (++toggle_data[slot].current_block == toggle_data[slot].nr_blocks)
-    toggle_data[slot].current_block = 0;
-
-  toggle_do_block(slot, toggle_data[slot].current_block);
-
-  return 1;
-}
-
-int toggle_iterate_key(int key)
-{
-  int slot;
-
-  if ((slot = toggle_find_slot(key)) == -1) {
-    errnum = ERR_BAD_ARGUMENT;
-    return 1;
-  }
-
-  /* Proceed to the next block */
-  if (++toggle_data[slot].current_block == toggle_data[slot].nr_blocks) {
-    errnum = ERR_BAD_ARGUMENT;
-    // Although we're going through an error we set the values to the first values for safety
-    toggle_data[slot].current_block=0; 
-    toggle_do_block(slot, toggle_data[slot].current_block);
-    return 1;
-  }
-  
-  toggle_do_block(slot, toggle_data[slot].current_block);
-
-  return 0;
-}
-
-int toggle_set_first_key(int key)
-{
-  int slot;
-
-  if ((slot = toggle_find_slot(key)) == -1) {
-    errnum = ERR_BAD_ARGUMENT;
-    return 1;
-  }
-
-  /* Proceed to the fist block */
-  toggle_data[slot].current_block = 0;
-
-  toggle_do_block(slot, toggle_data[slot].current_block);
-
-  return 0;
-}
-
-/* toggle 
-
-static int
-toggle_func(char *arg, int flags)
-{
-  int slot, key, block = 0, i;
-  char *a = arg, *eb;
-  int command;
-  enum {
-    COMMAND_SET,
-    COMMAND_SELECT,
-    COMMAND_TRIGGER,
-    COMMAND_SETFIRST,
-    COMMAND_ITERATE
-  };
-
-//  static int process_var(int bl, int var, char *start, char *end)
-  int process_var(int bl, int var, char *start, char *end)
-  {
-    char *p, origvar, *origvarp, origval, *v;
-
-    //grub_printf(&quot;VAR(%d, %d) %s [%d]\n&quot;, bl, var, start, end-start+1);
-
-    start = skip_ws(start);
-    p = start;
-    while (p &lt; end &amp;&amp; *p != '=' &amp;&amp; !isspace(*p))
-      p++;
-
-    origvar = *p;
-    origvarp = p;
-
-    p = skip_ws(p);
-    if (*p != '=')
-      return 1;
-    
-    p = skip_ws(p+1);
-
-    // value is now from p to end (both inclusive)
-
-    origval = *(end + 1);
-    *(end + 1) = 0;
-    *origvarp = 0;
-
-    // See if we already have the same value in that toggle
-    //  (in case we're entering a menu multiple time we would
-    //  allocate memory multiple time) 
-    
-    if (toggle_data[slot].block[bl].var[var].value &amp;&amp;
-	var_get_index(start) != -1 &amp;&amp;
-	!grub_strcmp(toggle_data[slot].block[bl].var[var].value, p))
-      {
-      }
-    else
-      {
-	// Allocate space for the value and hang it in 
-	if ((v = var_alloc_mem(grub_strlen(p) + 1)) == NULL)
-	  return 1;
-	grub_strcpy(v, p);
-
-	var_set_no_copy(start, v);
-
-	if ((toggle_data[slot].block[bl].var[var].var = var_get_index(start)) == -1)
-	  return 1; // internal error 
-	toggle_data[slot].block[bl].var[var].value = v;
-      }
-
-    *origvarp = origvar;
-    *(end + 1) = origval;
-
-    //grub_printf(&quot;slot=%d block=%d var=%d %d=%s\n&quot;, slot, bl, var, toggle_data[slot].block[bl].var[var].var, v);
-
-    if (var &gt;= toggle_data[slot].block[bl].nr_vars)
-      toggle_data[slot].block[bl].nr_vars = var + 1;
-
-    return 0;
-  }
-  //static int process_block(int bl, char *start, char *end)
-  int process_block(int bl, char *start, char *end)
-  {
-    char *p = start;
-    int var = 0;
-
-    //grub_printf(&quot;BL(%d) %s [%d]\n&quot;, bl, start, end-start+1);
-
-    while (p &lt;= end)
-      {
-	if (*p == ',' || p == end)
-	  {
-	    if (var == MAX_VAR_PER_BLOCK)
-	      return ERR_WONT_FIT;
-
-	    if (process_var(bl, var, start, (p == end) ? p : (p-1)))
-	      return ERR_BAD_ARGUMENT;
-
-	    var++;
-	    start = p + 1;
-	  }
-	p++;
-      }
-
-    return 0;
-  }
-
-
-  // parse args 
-  // proceed to next arg 
-  while (*a &amp;&amp; *a == ' ')
-    a++;
-
-  // Get command 
-  {
-    eb = a;
-
-    while (!isspace(*eb))
-      eb++;
-    
-    if (!isspace(*eb))
-      goto bad_arg;
-
-    //grub_printf(&quot;trigger: processing line: %s\n&quot;, a);
-
-    *eb = 0;
-
-    if (!grub_strcmp(a, &quot;set&quot;))
-      command = COMMAND_SET;
-    else if (!grub_strcmp(a, &quot;select&quot;))
-      command = COMMAND_SELECT;
-    else if (!grub_strcmp(a, &quot;trigger&quot;))
-      command = COMMAND_TRIGGER;
-    else if (!grub_strcmp(a, &quot;setfirst&quot;))
-      command = COMMAND_SETFIRST;
-    else if (!grub_strcmp(a, &quot;iterate&quot;))
-      command = COMMAND_ITERATE;
-    else
-      {
-	grub_printf(&quot;toggle: Unknown command!\n&quot;);
-        goto bad_arg;
-      }
-
-    *eb = ' ';
-    a = eb + 1;
-  }
-
-  a = skip_ws(a);
-
-  if (command == COMMAND_SET)
-    {
-
-      if (!*a || !*(a+1))
-	goto bad_arg;
-
-      key = *a;
-      a++;
-
-      //grub_printf(&quot;key: %c\n&quot;, key);
-
-      // Find slot for key 
-      slot = get_toggle_slot_for_key(key);
-      if (slot == -1)
-	{
-	  // Get next free toggle_data slot 
-	  slot = toggles_used;
-	  if (slot == TOGGLES)
-	    goto wont_fit;
-	  toggle_data[slot].key = key;
-	  toggles_used++;
-	}
-
-      // Reset current slot 
-      toggle_data[slot].nr_blocks = toggle_data[slot].current_block = 0;
-      for (i = 0; i &lt; MAX_VAR_PER_BLOCK; i++)
-	toggle_data[slot].block[i].nr_vars = 0;
-
-      while (*a)
-	{
-	  int ret;
-
-	  a = skip_ws(a);
-
-	  if (*a != '{')
-	    goto bad_arg;
-	  // find the correspondig '}' 
-	  eb = a++;
-	  while (*eb &amp;&amp; *eb != '}')
-	    eb++;
-	  if (*eb != '}')
-	    goto bad_arg;
-	  // Now we have the block between a and eb-1 
-	  ret = process_block(block, a, eb-1);
-	  if (ret == ERR_WONT_FIT)
-	    goto wont_fit;
-	  if (ret)
-	    goto bad_arg;
-
-	  a = eb + 1;
-
-	  block++;
-	  if (*a) {
-	    if (block == MAX_BLOCKS)
-	      goto wont_fit;
-	  }
-	}
-      toggle_data[slot].nr_blocks = block;
-
-      // finally, set all vars from the first block 
-      toggle_do_block(slot, 0);
-    }
-  else if (command == COMMAND_SELECT)
-    {
-      while (*a)
-	{
-	  int k, b, s;
-
-	  // there's something between a and eb-1 now 
-	  // *a is a key and *(a+1) == '=' 
-	  k = *a++;
-
-	  if (*a++ != '=')
-	    goto bad_arg;
-
-	  if (!safe_parse_maxint(&amp;a, &amp;b))
-	    goto bad_arg;
-
-	  if ((s = toggle_find_slot(k)) == -1)
-	    goto bad_arg;
-
-	  if (!toggle_do_block(s, b))
-	    goto bad_arg;
-
-          toggle_data[s].current_block = b;
-
-	  a = skip_ws(a);
-	}
-    }
-  else if (command == COMMAND_TRIGGER)
-    {
-      char *vr, *vre, *vl, *vle, *vrval;
-      char o;
-      int cmp;
-      // remaining a(rg) format: VAR==VAL &quot;command&quot;
-      //grub_printf(&quot;%s: trigger\n&quot;);
-
-      // Find the '=' 
-      vr = a;
-      while (*a &amp;&amp; *a != ' ' &amp;&amp; *a != '=')
-	a++;
-
-      if (*a != '=' || *(a+1) != '=')
-	goto bad_arg;
-
-      vre = a;
-
-      if (vr == vre)
-	goto bad_arg;
-
-      a += 2;
-      vl = a;
-
-      while (!isspace(*a))
-	a++;
-
-      vle = a;
-
-      if (vl == vle)
-	goto bad_arg;
-
-
-      *vre = 0;
-      vrval = var_get(vr);
-      *vre = '=';
-
-      if (!vrval)
-	goto bad_arg;
-
-      o = *vle;
-      *vle = 0;
-      cmp = grub_strcmp(vrval, vl);
-      *vle = o;
-
-      a = skip_ws(a);
-
-      if (!cmp)
-        toggle_func(a, 0);
-    }
-  else if (command == COMMAND_SETFIRST) {
-      while (*a)
-	{
-	  int k;
-	  k = *a;
-	  return (toggle_set_first_key(k));
-	}
-  }
-  else if (command == COMMAND_ITERATE) {
-      while (*a)
-	{
-	  int k;
-	  k = *a;
-	  return (toggle_iterate_key(k));
-	}
-  } 
-
-  return 0;
-
-wont_fit:
-  grub_printf(&quot;%s: ERR_WONT_FIT\n&quot;, __func__);
-  getkey();
-  errnum = ERR_WONT_FIT;
-  return 1;
-
-bad_arg:
-  grub_printf(&quot;%s: ERR_BAD_ARGUMENT\n&quot;, __func__);
-  getkey();
-  errnum = ERR_BAD_ARGUMENT;
-  return 1;
-}
-
-void toggle_trigger_init(void)
-{
-  int detect_vmware(void)
-//  static int detect_vmware(void)
-    {
-#ifndef GRUB_UTIL
-      char *start = (char *)0xc0000;
-      int size = 16 &lt;&lt; 10;
-      int i = 0, p = 0;
-      char *s = &quot;VMware, Inc.&quot;;
-
-      while (i &lt; size)
-	{
-	  if (*(start + i) == s[p])
-	    {
-	      p++;
-	      if (!s[p])
-		return 1;
-	    }
-	  else
-	    p = 0;
-	  i++;
-	}
-#endif
-      return 0;
-    }
-
-  if (toggle_trigger_init_done)
-    return;
-  toggle_trigger_init_done = 1;
-
-  var_set(&quot;TT_VMWARE&quot;, (detect_vmware()) ? &quot;1&quot; : &quot;0&quot;, 0);
-}
-
-static struct builtin builtin_toggle =
-{
-  &quot;toggle&quot;,
-  toggle_func,
-  BUILTIN_CMDLINE | BUILTIN_MENU | BUILTIN_HELP_LIST,
-  &quot;toggle [command] args...\n&quot;,
-  &quot;[command] can be: set - select - trigger - setfirst - iterate\n&quot;
-  &quot;toggle set k {KERNEL= $(KERNELSTABLE)} {KERNEL=$(KERNELDEVEL)}\n&quot;
-  &quot;  (Switches with a shift+k press)\n&quot;
-  &quot;toggle select k=1\n&quot;
-  &quot;  Select DEVEL kernels cause count begins at 0\n&quot;
-  &quot;toggle select k=0\n&quot;
-  &quot;  Select stable kernel\n&quot; 
-  &quot;toggle set K {var1=val1,var2=val2} {var1=val3,var2=val4}\n&quot;
-  &quot;  you can put more commands in a block also\n&quot;
-  &quot;toggle trigger TT_val==1 ...\n&quot;
-  &quot;  Evaluate the following ... commands if the toggle-trigger value is set.\n&quot;
-  &quot;toggle setfirst k\n&quot;
-  &quot;  Sets k to its first value (Stable kernel). Error if no value present.\n&quot;
-  &quot;toggle iterate k\n&quot;
-  &quot;  Sets k to the next value. Error if we're in last value.\n&quot;
-
-
-};
-
-*/
-
-
-static char var_expand_line_edit = 1;
-
-char is_var_expand(void)
-{
-  return var_expand_line_edit;
-}
-
-/* isfs_func */
-
-static int
-isfs (char *arg, int flags)
-{
-
-  unsigned long tmp_drive = saved_drive;
-  unsigned long tmp_partition = saved_partition;
-
-  char map_str[25]; // We should use some cheaper memory such as menu_entries but I am not very sure
-  char *auxiliar_char_pointer;
-  char *map_ptr = map_str;
-
-  /* Parse variables - Begin */
-  char *source_device;
-  int giventype; 
-  int isfs_bool=0;
-
-
-  /* Parse source device */
-  source_device = arg;
-  arg = skip_to (0,arg);
-  nul_terminate(source_device);
-
-  
-
-while ((*arg) &amp;&amp; (!(isfs_bool))) {
-
-/* Parse given type */
-  auxiliar_char_pointer = arg;
-  arg = skip_to (0,arg);
-  if ( ! safe_parse_maxint (&amp;auxiliar_char_pointer, &amp;giventype) ) return 1;
-
-  /* Parse variables - End */
-
-
-  /* Get last sector number sector into sector_number_int variable - Begin */
-
-  if ((! set_device (source_device)
-				    || ! open_partition ()
-				    ))
-
-  return 1;
-
-  //grub_printf(&quot;Partition type given: %d\n&quot;,giventype);
-  //grub_printf(&quot;Partition type detected: %d\n&quot;,current_slice);
-
-  isfs_bool=(giventype==current_slice);
-
-  }
-
-  /* Get last sector number sector into sector_number_int variable - End */
-
-  /* Set grub_device variable - end */
-
-  saved_drive = tmp_drive;
-  saved_partition = tmp_partition;
-
-  return (isfs_bool);
-
-
-}
-
-
-static int
-isfs_func (char *arg, int flags)
-{
-
-  if (isfs(arg,flags)) {
-     return 0;
-  } else {
-     errnum = ERR_FILE_NOT_FOUND;
-     return 1;
-  }
-	
-
-}
-
-static int
-isnotfs_func (char *arg, int flags)
-{
-
-  if (!(isfs(arg,flags))) {
-     return 0;
-  } else {
-     errnum = ERR_FILE_NOT_FOUND;
-     return 1;
-  }
-
-}
-
-
-static struct builtin builtin_isfs =
-{
-  &quot;isfs&quot;,
-  isfs_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;isfs PARTITION TYPE1 TYPE2 ...&quot;,
-  &quot;If PARTITION is from one of the types in the list no error is reported.&quot;
-};
-
-static struct builtin builtin_isnotfs =
-{
-  &quot;isnotfs&quot;,
-  isnotfs_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;isnotfs PARTITION TYPE1 TYPE2 ...&quot;,
-  &quot;If PARTITION is NOT from one of the types in the list no error is reported.&quot;
-};
-
-/* lastsector */
-
-static int
-lastsector_func (char *arg, int flags)
-{
-
-  unsigned long tmp_drive = saved_drive;
-  unsigned long tmp_partition = saved_partition;
-
-  char map_str[25]; // We should use some cheaper memory such as menu_entries but I am not very sure
-  char *map_ptr = map_str;
-
-  /* Parse variables - Begin */
-  char *source_device, *sector_number_var;
-  unsigned long int sector_number_int;
-
-
-  /* Parse source device */
-  source_device = arg;
-  arg = skip_to (0,arg);
-  nul_terminate(source_device);
-
-  /* Parse sector numbervariable*/
-  sector_number_var = arg;
-  arg = skip_to (0,arg);
-  nul_terminate(sector_number_var);
-
-  /* Parse variables - End */
-
-
-  /* Get last sector number sector into sector_number_int variable - Begin */
-
-  if ((! set_device (source_device)
-				    || ! open_partition ()
-				    ))
-
-  return 1;
-
-  sector_number_int=((part_length)-1) * SECTOR_SIZE;
-
-  /* Get last sector number sector into sector_number_int variable - End */
-
-
-  /* Set grub_device variable -  1st part begin */
-	grub_sprintf (map_ptr,&quot;%s=&quot;,sector_number_var);
-
-  /* Set grub_device variable -  2nd part begin */
-
-	grub_sprintf (map_ptr,&quot;%s%d&quot;,map_ptr,sector_number_int);
-
-	set_func(map_ptr,1);
-
-  /* Set grub_device variable - end */
-
-  saved_drive = tmp_drive;
-  saved_partition = tmp_partition;
-
-  return 0; // Everything is fine
-
-}
-
-static struct builtin builtin_lastsector =
-{
-  &quot;lastsector&quot;,
-  lastsector_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;lastsector DEVICE VARIABLE&quot;,
-  &quot;Saves lastsector offset of DEVICE (only PARTITIONS) into VARIABLE&quot;
-};
-
-
-/* setgrubdevice */
-
-static int
-setgrubdevice_func (char *arg, int flags)
-{
-
-	char map_str[25]; // We should use some cheaper memory such as menu_entries but I am not very sure
-	char *map_ptr = map_str;
-/* Set grub_device variable - begin */
-	grub_sprintf (map_ptr,&quot;grub_device=&quot;);
-	if (saved_drive == NETWORK_DRIVE)
-	{
-		/* Network drive.  */
-		grub_sprintf (map_ptr,&quot;%s(nd)&quot;,map_ptr);
-	}
-	else if ((cdrom_drive != GRUB_INVALID_DRIVE) &amp;&amp;(saved_drive==cdrom_drive)) 
-	{
-		/* cdrom drive */
-      		grub_sprintf (map_ptr,&quot;%s(cd)&quot;,map_ptr);
-	}
-	else if (saved_drive &amp; 0x80)
-	{
-		/* Hard disk drive.  */
-		grub_sprintf (map_ptr,&quot;%s(hd%d&quot;,map_ptr, saved_drive - 0x80);
-	
-		if ((saved_partition &amp; 0xFF0000) != 0xFF0000)
-			grub_sprintf (map_ptr,&quot;%s,%d&quot;,map_ptr, saved_partition &gt;&gt; 16);
-	
-		if ((saved_partition &amp; 0x00FF00) != 0x00FF00)
-			grub_sprintf (map_ptr,&quot;%s,%c&quot;,map_ptr, ((saved_partition &gt;&gt; 8) &amp; 0xFF) + 'a');
-
-		grub_sprintf (map_ptr,&quot;%s)&quot;,map_ptr);
-	}
-	else
-	{
-		/* Floppy disk drive.  */
-		grub_sprintf (map_ptr,&quot;%s(fd%d)&quot;,map_ptr, saved_drive);
-	}
-
-	set_func(map_ptr,1);
-
-/* Set grub_device variable - end */
-
-/* Set grub_drive variable - begin */
-	grub_sprintf (map_ptr,&quot;grub_drive=&quot;);
-	if (saved_drive == NETWORK_DRIVE)
-	{
-		/* Network drive.  */
-		grub_sprintf (map_ptr,&quot;%snd&quot;,map_ptr);
-	}
-	else if ((cdrom_drive != GRUB_INVALID_DRIVE) &amp;&amp;(saved_drive==cdrom_drive)) 
-	{
-		/* cdrom drive */
-      		grub_sprintf (map_ptr,&quot;%scd&quot;,map_ptr);
-	}
-	else if (saved_drive &amp; 0x80)
-	{
-		/* Hard disk drive.  */
-		grub_sprintf (map_ptr,&quot;%shd%d&quot;,map_ptr, saved_drive - 0x80);
-	}
-	else
-	{
-		/* Floppy disk drive.  */
-		grub_sprintf (map_ptr,&quot;%sfd%d&quot;,map_ptr, saved_drive);
-	}
-
-	set_func(map_ptr,1);
-
-
-
-/* Set grub_drive variable - end */
-
-/* Set grub_partition variable - begin */
-	grub_sprintf (map_ptr,&quot;grub_partition=&quot;);
-	if (saved_drive == NETWORK_DRIVE)
-	{
-		/* Network drive.  */
-		grub_sprintf (map_ptr,&quot;%s)&quot;,map_ptr);
-	}
-	else if ((cdrom_drive != GRUB_INVALID_DRIVE) &amp;&amp;(saved_drive==cdrom_drive)) 
-	{
-		/* cdrom drive */
-      		grub_sprintf (map_ptr,&quot;%s)&quot;,map_ptr);
-	}
-	else if (saved_drive &amp; 0x80)
-	{
-		/* Hard disk drive.  */
-	
-		if ((saved_partition &amp; 0xFF0000) != 0xFF0000)
-			grub_sprintf (map_ptr,&quot;%s,%d&quot;,map_ptr, saved_partition &gt;&gt; 16);
-	
-		if ((saved_partition &amp; 0x00FF00) != 0x00FF00)
-			grub_sprintf (map_ptr,&quot;%s,%c&quot;,map_ptr, ((saved_partition &gt;&gt; 8) &amp; 0xFF) + 'a');
-
-		grub_sprintf (map_ptr,&quot;%s)&quot;,map_ptr);
-	}
-	else
-	{
-		/* Floppy disk drive.  */
-		grub_sprintf (map_ptr,&quot;%s)&quot;,map_ptr, saved_drive);
-	}
-
-	set_func(map_ptr,1);
-
-/* Set grub_partition variable - end */
-
-	return 0; // Everything is fine
-
-}
-
-static struct builtin builtin_setgrubdevice =
-{
-  &quot;setgrubdevice&quot;,
-  setgrubdevice_func,
-  BUILTIN_MENU | BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;setgrubdevice&quot;,
-  &quot;Sets grub device variable to the current root&quot;
-};
-
-
-
-/* usbshift */
-
-static int
-usbshift_func (char *arg, int flags)
-{
-  /* Check if we're running inside hd0 thanks to saved_drive*/
-  if (saved_drive == 0x80) {
-	int i = 0x80;
-	char map_str[25]; // We should use some cheaper memory such as menu_entries but I am not very sure
-	char *map_ptr = map_str;
- /* Drives shift */
-	grub_sprintf(map_ptr,&quot;(hd%d) (hd%d)&quot;,i +1 - 0x80 ,i - 0x80);
-	struct geometry geom;
-
-    	while ((! get_diskinfo (i, &amp;geom))&amp;&amp;(! get_diskinfo (i+1, &amp;geom))) 
-		{
-			if (map_func(map_ptr,1)) return 1;
-			i++;
-			grub_sprintf(map_ptr,&quot;(hd%d) (hd%d)&quot;,i + 1 - 0x80,i - 0x80);
-		}
-/* map_func always sets ERRNUM in the last call, so clear it.  */
-	errnum = ERR_NONE;
-	grub_sprintf(map_ptr,&quot;(hd0) (hd%d)&quot;,i - 0x80);
-	if (map_func(map_ptr,1)) return 1;
- /* saved_drive renamed */
-	saved_drive = i; 
- /* grub_device renamed */
-
-
-if (saved_drive &amp; 0x80)
-    {
-	setgrubdevice_func(&quot;&quot;,1); // Set grub device variable as the root one 
-    } else return 1; // Saved drive must be a drive at this point!!!
-
-
-/*Let's call the bios to swap drives without rebooting */
-
-check_int13_handler(0); // 0 means that we want the function NOT to modify the saved drive
-
-//map_pseudo_reboot (int *new_grub_drive,struct geometry *geom,char *map_ptr);
-map_pseudo_reboot (&amp;i,&amp;geom,&amp;map_ptr);
-/*
-root_func ((var_sprint_buf(&quot;$(grub_device)&quot;, &amp;i)),1); // i must be a integer, it does not matter modifying it right now
-boot_drive = saved_drive;
-install_partition = saved_partition;
-
- Restore map vector 
-	i = 0x80;
-	grub_sprintf(map_ptr,&quot;(hd%d) (hd%d)&quot;,i - 0x80 ,i - 0x80);
-    	while ((! get_diskinfo (i, &amp;geom))) 
-		{
-			if (map_func(map_ptr,1)) return 1;
-			i++;
-			grub_sprintf(map_ptr,&quot;(hd%d) (hd%d)&quot;,i - 0x80 ,i - 0x80);
-		}
- map_func always sets ERRNUM in the last call, so clear it.  
-	errnum = ERR_NONE;
-
-*/
-
-
-return 0; // Everything is fine
-
-
-  } else return 0; // If there's no hd0 we do not want any error here.
-
-}
-
-static struct builtin builtin_usbshift =
-{
-  &quot;usbshift&quot;,
-  usbshift_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;usbshift&quot;,
-  &quot;Shift the devices so that first device is the last one.&quot;
-  &quot; and then the second one is the first one, the third one&quot;
-  &quot; is the second one and so on.&quot;
-};
-
-
-/* liveswap */
-
-static int
-liveswap_func (char *arg, int flags)
-
-{
-
-/* FIXME-ADRIAN15:  map_str and map_ptr should be shared by usbshift_func and liveswap_func */
-   struct geometry geom;
-   char map_str[25]; // We should use some cheaper memory such as menu_entries but I am not very sure
-   char *map_ptr = map_str;
-
-   check_int13_handler(1); // 1 means that we want the function TO to modify the saved drive
-   map_pseudo_reboot (&amp;saved_drive,&amp;geom,&amp;map_ptr);
-}
-
-static struct builtin builtin_liveswap =
-{
-  &quot;liveswap&quot;,
-  liveswap_func,
-  BUILTIN_CMDLINE | BUILTIN_HELP_LIST,
-  &quot;liveswap&quot;,
-  &quot;Swap drives without booting anything&quot;
-};
-
-
-
-int map_pseudo_reboot (int *new_grub_drive,struct geometry *geom,char **map_ptr) {
-
-
-int i;
-
-		// In order to call it: &amp;integer_variable
-		//*(new_grub_drive)
-root_func ((var_sprint_buf(&quot;$(grub_device)&quot;, new_grub_drive)),1); // new_grub_drive a reference to a integer
-boot_drive = saved_drive;
-install_partition = saved_partition;
-
-/* Restore map vector */
-	i = 0x80;
-	grub_sprintf((*map_ptr),&quot;(hd%d) (hd%d)&quot;,i - 0x80 ,i - 0x80);
-    	while ((! get_diskinfo (i, geom))) 
-		{
-			if (map_func((*map_ptr),1)) return 1;
-			i++;
-			grub_sprintf((*map_ptr),&quot;(hd%d) (hd%d)&quot;,i - 0x80 ,i - 0x80);
-		}
-/* map_func always sets ERRNUM in the last call, so clear it.  */
-	errnum = ERR_NONE;
-
-return 0;
-
-}
-
-
-/* The table of builtin commands. Sorted in dictionary order.  */
-struct builtin *builtin_table[] =
-{
-
-&amp;builtin_adhocerror,
-&amp;builtin_back,
-  &amp;builtin_boot,
-  &amp;builtin_call,
-  &amp;builtin_cat,
-  &amp;builtin_catis,
-  &amp;builtin_chainloader,
-//  &amp;builtin_cmp, - let's comment the cmp command we do not need it in SGD
-  &amp;builtin_color,
-  &amp;builtin_configfile,
-  &amp;builtin_dd,
-  &amp;builtin_dddd,
-  &amp;builtin_default,
-#ifdef GRUB_UTIL
-  &amp;builtin_device,
-#endif /* GRUB_UTIL */
-//  &amp;builtin_displayapm,
-//  &amp;builtin_displaymem,
-#ifdef GRUB_UTIL
-  &amp;builtin_dump,
-#endif /* GRUB_UTIL */
-  &amp;builtin_echo,
-  &amp;builtin_embed,
-  &amp;builtin_fallback,
-  &amp;builtin_fdisklu,
-  &amp;builtin_fexists,
-  &amp;builtin_find,
-  &amp;builtin_findf,
-  &amp;builtin_geometry,
-  &amp;builtin_halt,
-  &amp;builtin_help,
-  &amp;builtin_hide,
-  &amp;builtin_initrd,
-  &amp;builtin_install,
-  &amp;builtin_ipause,
-  &amp;builtin_isfs,
-  &amp;builtin_isnotfs,
-  &amp;builtin_kernel,
-  &amp;builtin_lastsector,
-  &amp;builtin_liveswap,
-//  &amp;builtin_lock, // We do not need lock command in SGD, maybe in a SGD hd installation :)
-  &amp;builtin_makeactive,
-  &amp;builtin_map,
-#ifdef USE_MD5_PASSWORDS
-  &amp;builtin_md5crypt,
-#endif /* USE_MD5_PASSWORDS */
-  &amp;builtin_modaddr,
-  &amp;builtin_module,
-  &amp;builtin_modulenounzip,
-  &amp;builtin_notzero,
-  &amp;builtin_partinfo,
-  //&amp;builtin_password,
-  &amp;builtin_pause,
-  &amp;builtin_print,
-#ifdef GRUB_UTIL
-  &amp;builtin_quit,
-#endif /* GRUB_UTIL */
-  &amp;builtin_read,
-  &amp;builtin_reboot,
-  &amp;builtin_root,
-  &amp;builtin_rootnoverify,
-  //&amp;builtin_savedefault,
-  &amp;builtin_selectfile,
-  &amp;builtin_selecthd,
-  &amp;builtin_selectpart,
-  &amp;builtin_set,
-  &amp;builtin_setgrubdevice,
-  &amp;builtin_setkey,
-  &amp;builtin_setup,
-  &amp;builtin_sgdgfxmenu,
-  &amp;builtin_sgdgfxmenuoff,
-  &amp;builtin_timeout,
-  &amp;builtin_title,
-//  &amp;builtin_toggle,
-  &amp;builtin_unhide,
-  &amp;builtin_usbshift,
-  0
-};

Deleted: castillonroy/dev_grub/stage2/disk_io.c.orig
===================================================================
--- castillonroy/dev_grub/stage2/disk_io.c.orig	2009-06-01 19:30:15 UTC (rev 3)
+++ castillonroy/dev_grub/stage2/disk_io.c.orig	2009-06-02 17:21:33 UTC (rev 4)
@@ -1,1964 +0,0 @@
-/* disk_io.c - implement abstract BIOS disk input and output */
-/*
- *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 1999,2000,2001,2002,2003,2004  Free Software Foundation, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-
-#include &lt;shared.h&gt;
-#include &lt;filesys.h&gt;
-
-#ifdef SUPPORT_NETBOOT
-# define GRUB	1
-# include &lt;etherboot.h&gt;
-#endif
-
-#ifdef GRUB_UTIL
-# include &lt;device.h&gt;
-#endif
-
-/* instrumentation variables */
-void (*disk_read_hook) (int, int, int) = NULL;
-void (*disk_read_func) (int, int, int) = NULL;
-
-#ifndef STAGE1_5
-int print_possibilities;
-
-static int do_completion;
-static int unique;
-static char *unique_string;
-
-#endif
-
-int fsmax;
-struct fsys_entry fsys_table[NUM_FSYS + 1] =
-{
-  /* TFTP should come first because others don't handle net device.  */
-# ifdef FSYS_TFTP
-  {&quot;tftp&quot;, tftp_mount, tftp_read, tftp_dir, tftp_close, 0},
-# endif
-# ifdef FSYS_FAT
-  {&quot;fat&quot;, fat_mount, fat_read, fat_dir, 0, 0},
-# endif
-# ifdef FSYS_EXT2FS
-  {&quot;ext2fs&quot;, ext2fs_mount, ext2fs_read, ext2fs_dir, 0, 0},
-# endif
-# ifdef FSYS_MINIX
-  {&quot;minix&quot;, minix_mount, minix_read, minix_dir, 0, 0},
-# endif
-# ifdef FSYS_REISERFS
-  {&quot;reiserfs&quot;, reiserfs_mount, reiserfs_read, reiserfs_dir, 0, reiserfs_embed},
-# endif
-# ifdef FSYS_VSTAFS
-  {&quot;vstafs&quot;, vstafs_mount, vstafs_read, vstafs_dir, 0, 0},
-# endif
-# ifdef FSYS_JFS
-  {&quot;jfs&quot;, jfs_mount, jfs_read, jfs_dir, 0, jfs_embed},
-# endif
-# ifdef FSYS_XFS
-  {&quot;xfs&quot;, xfs_mount, xfs_read, xfs_dir, 0, 0},
-# endif
-# ifdef FSYS_UFS
-  {&quot;ufs&quot;, ufs_mount, ufs_read, ufs_dir, 0, ufs_embed},
-# endif
-# ifdef FSYS_UFS2
-  {&quot;ufs2&quot;, ufs2_mount, ufs2_read, ufs2_dir, 0, ufs2_embed},
-# endif
-# ifdef FSYS_ISO9660
-  {&quot;iso9660&quot;, iso9660_mount, iso9660_read, iso9660_dir, 0, 0},
-# endif
-  /* XX FFS should come last as it's superblock is commonly crossing tracks
-     on floppies from track 1 to 2, while others only use 1.  */
-# ifdef FSYS_FFS
-  {&quot;ffs&quot;, ffs_mount, ffs_read, ffs_dir, 0, ffs_embed},
-# endif
-  {0, 0, 0, 0, 0, 0}
-};
-
-
-/* These have the same format as &quot;boot_drive&quot; and &quot;install_partition&quot;, but
-   are meant to be working values. */
-unsigned long current_drive = GRUB_INVALID_DRIVE;
-unsigned long current_partition;
-
-#ifndef STAGE1_5
-/* The register ESI should contain the address of the partition to be
-   used for loading a chain-loader when chain-loading the loader.  */
-unsigned long boot_part_addr = 0;
-#endif
-
-/*
- *  Global variables describing details of the filesystem
- */
-
-/* FIXME: BSD evil hack */
-#include &quot;freebsd.h&quot;
-int bsd_evil_hack;
-
-/* filesystem type */
-int fsys_type = NUM_FSYS;
-#ifndef NO_BLOCK_FILES
-static int block_file = 0;
-#endif /* NO_BLOCK_FILES */
-
-/* these are the translated numbers for the open partition */
-unsigned long part_start;
-unsigned long part_length;
-
-int current_slice;
-
-/* disk buffer parameters */
-int buf_drive = -1;
-int buf_track;
-struct geometry buf_geom;
-
-/* filesystem common variables */
-int filepos;
-int filemax;
-
-static inline unsigned long
-grub_log2 (unsigned long word)
-{
-  asm volatile (&quot;bsfl %1,%0&quot;
-		: &quot;=r&quot; (word)
-		: &quot;r&quot; (word));
-  return word;
-}
-
-int
-rawread (int drive, int sector, int byte_offset, int byte_len, char *buf)
-{
-  int slen, sectors_per_vtrack;
-  int sector_size_bits = grub_log2 (buf_geom.sector_size);
-
-  if (byte_len &lt;= 0)
-    return 1;
-
-  while (byte_len &gt; 0 &amp;&amp; !errnum)
-    {
-      int soff, num_sect, track, size = byte_len;
-      char *bufaddr;
-
-      /*
-       *  Check track buffer.  If it isn't valid or it is from the
-       *  wrong disk, then reset the disk geometry.
-       */
-		
-      if (buf_drive != drive)
-	{
-	  if (get_diskinfo (drive, &amp;buf_geom))
-	    {
-	      errnum = ERR_NO_DISK;
-	      return 0;
-	    }
-	  buf_drive = drive;
-	  buf_track = -1;
-	  sector_size_bits = grub_log2 (buf_geom.sector_size);
-	}
-
-      /* Make sure that SECTOR is valid.  */
-      if (sector &lt; 0 || sector &gt;= buf_geom.total_sectors)
-	{
-	  errnum = ERR_GEOM;
-	  return 0;
-	}
-      
-      slen = ((byte_offset + byte_len + buf_geom.sector_size - 1)
-	      &gt;&gt; sector_size_bits);
-      
-      /* Eliminate a buffer overflow.  */
-      if ((buf_geom.sectors &lt;&lt; sector_size_bits) &gt; BUFFERLEN)
-	sectors_per_vtrack = (BUFFERLEN &gt;&gt; sector_size_bits);
-      else
-	sectors_per_vtrack = buf_geom.sectors;
-      
-      /* Get the first sector of track.  */
-      soff = sector % sectors_per_vtrack;
-      track = sector - soff;
-      num_sect = sectors_per_vtrack - soff;
-      bufaddr = ((char *) BUFFERADDR
-		 + (soff &lt;&lt; sector_size_bits) + byte_offset);
-
-      if (track != buf_track)
-	{
-	  int bios_err, read_start = track, read_len = sectors_per_vtrack;
-
-	  /*
-	   *  If there's more than one read in this entire loop, then
-	   *  only make the earlier reads for the portion needed.  This
-	   *  saves filling the buffer with data that won't be used!
-	   */
-	  if (slen &gt; num_sect)
-	    {
-	      read_start = sector;
-	      read_len = num_sect;
-	      bufaddr = (char *) BUFFERADDR + byte_offset;
-	    }
-
-	  bios_err = biosdisk (BIOSDISK_READ, drive, &amp;buf_geom,
-			       read_start, read_len, BUFFERSEG);
-	  if (bios_err)
-	    {
-	      buf_track = -1;
-
-	      if (bios_err == BIOSDISK_ERROR_GEOMETRY)
-		errnum = ERR_GEOM;
-	      else
-		{
-		  /*
-		   *  If there was an error, try to load only the
-		   *  required sector(s) rather than failing completely.
-		   */
-		  if (slen &gt; num_sect
-		      || biosdisk (BIOSDISK_READ, drive, &amp;buf_geom,
-				   sector, slen, BUFFERSEG))
-		    errnum = ERR_READ;
-
-		  bufaddr = (char *) BUFFERADDR + byte_offset;
-		}
-	    }
-	  else
-	    buf_track = track;
-
-	  if ((buf_track == 0 || sector == 0)
-	      &amp;&amp; (PC_SLICE_TYPE (BUFFERADDR, 0) == PC_SLICE_TYPE_EZD
-		  || PC_SLICE_TYPE (BUFFERADDR, 1) == PC_SLICE_TYPE_EZD
-		  || PC_SLICE_TYPE (BUFFERADDR, 2) == PC_SLICE_TYPE_EZD
-		  || PC_SLICE_TYPE (BUFFERADDR, 3) == PC_SLICE_TYPE_EZD))
-	    {
-	      /* This is a EZD disk map sector 0 to sector 1 */
-	      if (buf_track == 0 || slen &gt;= 2)
-		{
-		  /* We already read the sector 1, copy it to sector 0 */
-		  memmove ((char *) BUFFERADDR, 
-			   (char *) BUFFERADDR + buf_geom.sector_size,
-			   buf_geom.sector_size);
-		}
-	      else
-		{
-		  if (biosdisk (BIOSDISK_READ, drive, &amp;buf_geom,
-				1, 1, BUFFERSEG))
-		    errnum = ERR_READ;
-		}
-	    }
-	}
-	  
-      if (size &gt; ((num_sect &lt;&lt; sector_size_bits) - byte_offset))
-	size = (num_sect &lt;&lt; sector_size_bits) - byte_offset;
-
-      /*
-       *  Instrumentation to tell which sectors were read and used.
-       */
-      if (disk_read_func)
-	{
-	  int sector_num = sector;
-	  int length = buf_geom.sector_size - byte_offset;
-	  if (length &gt; size)
-	    length = size;
-	  (*disk_read_func) (sector_num++, byte_offset, length);
-	  length = size - length;
-	  if (length &gt; 0)
-	    {
-	      while (length &gt; buf_geom.sector_size)
-		{
-		  (*disk_read_func) (sector_num++, 0, buf_geom.sector_size);
-		  length -= buf_geom.sector_size;
-		}
-	      (*disk_read_func) (sector_num, 0, length);
-	    }
-	}
-
-      grub_memmove (buf, bufaddr, size);
-
-      buf += size;
-      byte_len -= size;
-      sector += num_sect;
-      byte_offset = 0;
-    }
-
-  return (!errnum);
-}
-
-
-int
-devread (int sector, int byte_offset, int byte_len, char *buf)
-{
-  /*
-   *  Check partition boundaries
-   */
-  if (sector &lt; 0
-      || ((sector + ((byte_offset + byte_len - 1) &gt;&gt; SECTOR_BITS))
-	  &gt;= part_length))
-    {
-      errnum = ERR_OUTSIDE_PART;
-      return 0;
-    }
-
-  /*
-   *  Get the read to the beginning of a partition.
-   */
-  sector += byte_offset &gt;&gt; SECTOR_BITS;
-  byte_offset &amp;= SECTOR_SIZE - 1;
-
-#if !defined(STAGE1_5)
-  if (disk_read_hook &amp;&amp; debug)
-    printf (&quot;&lt;%d, %d, %d&gt;&quot;, sector, byte_offset, byte_len);
-#endif /* !STAGE1_5 */
-
-  /*
-   *  Call RAWREAD, which is very similar, but:
-   *
-   *    --  It takes an extra parameter, the drive number.
-   *    --  It requires that &quot;sector&quot; is relative to the beginning
-   *            of the disk.
-   *    --  It doesn't handle offsets of more than 511 bytes into the
-   *            sector.
-   */
-  return rawread (current_drive, part_start + sector, byte_offset,
-		  byte_len, buf);
-}
-
-#ifndef STAGE1_5
-int
-rawwrite (int drive, int sector, char *buf)
-{
-  if (sector == 0)
-    {
-      if (biosdisk (BIOSDISK_READ, drive, &amp;buf_geom, 0, 1, SCRATCHSEG))
-	{
-	  errnum = ERR_WRITE;
-	  return 0;
-	}
-
-      if (PC_SLICE_TYPE (SCRATCHADDR, 0) == PC_SLICE_TYPE_EZD
-	  || PC_SLICE_TYPE (SCRATCHADDR, 1) == PC_SLICE_TYPE_EZD
-	  || PC_SLICE_TYPE (SCRATCHADDR, 2) == PC_SLICE_TYPE_EZD
-	  || PC_SLICE_TYPE (SCRATCHADDR, 3) == PC_SLICE_TYPE_EZD)
-	sector = 1;
-    }
-  
-  memmove ((char *) SCRATCHADDR, buf, SECTOR_SIZE);
-  if (biosdisk (BIOSDISK_WRITE, drive, &amp;buf_geom,
-		sector, 1, SCRATCHSEG))
-    {
-      errnum = ERR_WRITE;
-      return 0;
-    }
-
-  if (sector - sector % buf_geom.sectors == buf_track)
-    /* Clear the cache.  */
-    buf_track = -1;
-
-  return 1;
-}
-
-int
-sdevwrite (int device_sector_number, int sector_count, char *read_and_write_buffer, int offset, int size) {
-// device_sector_number: First sector to read
-// sector_count: Number of sectors to read
-// read_and_write_buffer: Buffer where information to write it is found
-// offset: Offset in the output sector
-// size: Size of data to write
-char auxiliar_buffer[512];
-
-  if ((size &lt;= 0) || size &gt; SECTOR_SIZE) {
-		grub_printf(&quot;sdevwrite: size is &lt; 0 or &gt; %d\n&quot;,SECTOR_SIZE);
-		return 0; // 0 means error as grub logic
-  }
-  if (size==SECTOR_SIZE) {
-    return (devwrite (device_sector_number,sector_count,read_and_write_buffer));
-  } else {
-    if (devread (device_sector_number,0,SECTOR_SIZE,auxiliar_buffer)) return 1;
-    if (grub_memmove (auxiliar_buffer+offset,read_and_write_buffer,size))
-    return 1;
-    return (devwrite (device_sector_number,sector_count,auxiliar_buffer));
-  }
-
-}
-
-int
-devwrite (int sector, int sector_count, char *buf)
-{
-#if defined(GRUB_UTIL) &amp;&amp; defined(__linux__)
-  if (current_partition != 0xFFFFFF
-      &amp;&amp; is_disk_device (device_map, current_drive))
-    {
-      /* If the grub shell is running under Linux and the user wants to
-	 embed a Stage 1.5 into a partition instead of a MBR, use system
-	 calls directly instead of biosdisk, because of the bug in
-	 Linux. *sigh*  */
-      return write_to_partition (device_map, current_drive, current_partition,
-				 sector, sector_count, buf);
-    }
-  else
-#endif /* GRUB_UTIL &amp;&amp; __linux__ */
-    {
-      int i;
-      
-      for (i = 0; i &lt; sector_count; i++)
-	{
-	  if (! rawwrite (current_drive, part_start + sector + i, 
-			  buf + (i &lt;&lt; SECTOR_BITS)))
-	      return 0;
-
-	}
-      return 1;
-    }
-}
-
-static int
-sane_partition (void)
-{
-  /* network drive */
-  if (current_drive == NETWORK_DRIVE)
-    return 1;
-  
-  if (!(current_partition &amp; 0xFF000000uL)
-      &amp;&amp; ((current_drive &amp; 0xFFFFFF7F) &lt; 16
-	  || current_drive == cdrom_drive)
-      &amp;&amp; (current_partition &amp; 0xFF) == 0xFF
-      &amp;&amp; ((current_partition &amp; 0xFF00) == 0xFF00
-	  || (current_partition &amp; 0xFF00) &lt; 0x1000)
-      &amp;&amp; ((current_partition &gt;&gt; 16) == 0xFF
-	  || (current_drive &amp; 0x80)))
-    return 1;
-
-  errnum = ERR_DEV_VALUES;
-  return 0;
-}
-#endif /* ! STAGE1_5 */
-
-static void
-attempt_mount (void)
-{
-#ifndef STAGE1_5
-  for (fsys_type = 0; fsys_type &lt; NUM_FSYS; fsys_type++)
-    if ((fsys_table[fsys_type].mount_func) ())
-      break;
-
-  if (fsys_type == NUM_FSYS &amp;&amp; errnum == ERR_NONE)
-    errnum = ERR_FSYS_MOUNT;
-#else
-  fsys_type = 0;
-  if ((*(fsys_table[fsys_type].mount_func)) () != 1)
-    {
-      fsys_type = NUM_FSYS;
-      errnum = ERR_FSYS_MOUNT;
-    }
-#endif
-}
-
-
-#ifndef STAGE1_5
-/* Turn on the active flag for the partition SAVED_PARTITION in the
-   drive SAVED_DRIVE. If an error occurs, return zero, otherwise return
-   non-zero.  */
-int
-make_saved_active (void)
-{
-  char mbr[512];
-
-  if (saved_drive &amp; 0x80)
-    {
-      /* Hard disk */
-      int part = saved_partition &gt;&gt; 16;
-
-      /* If the partition is not a primary partition, the active flag is
-	 meaningless. (XXX: Really?)  */
-      if (part &gt; 3)
-	{
-	  errnum = ERR_DEV_VALUES;
-	  return 0;
-	}
-
-      /* Read the MBR in the scratch space.  */
-      if (! rawread (saved_drive, 0, 0, SECTOR_SIZE, mbr))
-	return 0;
-
-      /* If the partition is an extended partition, setting the active
-	 flag violates the specification by IBM.  */
-      if (IS_PC_SLICE_TYPE_EXTENDED (PC_SLICE_TYPE (mbr, part)))
-	{
-	  errnum = ERR_DEV_VALUES;
-	  return 0;
-	}
-
-      /* Check if the active flag is disabled.  */
-      if (PC_SLICE_FLAG (mbr, part) != PC_SLICE_FLAG_BOOTABLE)
-	{
-	  int i;
-
-	  /* Clear all the active flags in this table.  */
-	  for (i = 0; i &lt; 4; i++)
-	    PC_SLICE_FLAG (mbr, i) = 0;
-
-	  /* Set the flag.  */
-	  PC_SLICE_FLAG (mbr, part) = PC_SLICE_FLAG_BOOTABLE;
-
-	  /* Write back the MBR.  */
-	  if (! rawwrite (saved_drive, 0, mbr))
-	    return 0;
-	}
-    }
-  else
-    {
-      /* If the drive is not a hard disk drive, you shouldn't call this
-	 function. (XXX: Should I just ignore this error?)  */
-      errnum = ERR_DEV_VALUES;
-      return 0;
-    }
-
-  return 1;
-}
-
-/* Hide/Unhide CURRENT_PARTITION.  */
-int
-set_partition_hidden_flag (int hidden)
-{
-  unsigned long part = 0xFFFFFF;
-  unsigned long start, len, offset, ext_offset;
-  int entry, type;
-  char mbr[512];
-  
-  /* The drive must be a hard disk.  */
-  if (! (current_drive &amp; 0x80))
-    {
-      errnum = ERR_BAD_ARGUMENT;
-      return 1;
-    }
-  
-  /* The partition must be a PC slice.  */
-  if ((current_partition &gt;&gt; 16) == 0xFF
-      || (current_partition &amp; 0xFFFF) != 0xFFFF)
-    {
-      errnum = ERR_BAD_ARGUMENT;
-      return 1;
-    }
-  
-  /* Look for the partition.  */
-  while (next_partition (current_drive, 0xFFFFFF, &amp;part, &amp;type,           
-			 &amp;start, &amp;len, &amp;offset, &amp;entry,
-			 &amp;ext_offset, mbr))
-    {                                                                       
-      if (part == current_partition)
-	{
-	  /* Found.  */
-	  if (hidden)
-	    PC_SLICE_TYPE (mbr, entry) |= PC_SLICE_TYPE_HIDDEN_FLAG;
-	  else
-	    PC_SLICE_TYPE (mbr, entry) &amp;= ~PC_SLICE_TYPE_HIDDEN_FLAG;       
-	  
-	  /* Write back the MBR to the disk.  */
-	  buf_track = -1;
-	  if (! rawwrite (current_drive, offset, mbr))
-	    return 1;
-	  
-	  /* Succeed.  */
-	  return 0;
-	}
-    }
-  
-  return 1;
-}
-
-
-static void
-check_and_print_mount (int flags)
-{
-  attempt_mount ();
-  if (errnum == ERR_FSYS_MOUNT)
-    errnum = ERR_NONE;
-  if (!errnum)
-    print_fsys_type ();
-  if (!flags)
-  print_error ();
-}
-#endif /* STAGE1_5 */
-
-
-/* Get the information on next partition on the drive DRIVE.
-   The caller must not modify the contents of the arguments when
-   iterating this function. The partition representation in GRUB will
-   be stored in *PARTITION. Likewise, the partition type in *TYPE, the
-   start sector in *START, the length in *LEN, the offset of the
-   partition table in *OFFSET, the entry number in the table in *ENTRY,
-   the offset of the extended partition in *EXT_OFFSET.
-   BUF is used to store a MBR, the boot sector of a partition, or
-   a BSD label sector, and it must be at least 512 bytes length.
-   When calling this function first, *PARTITION must be initialized to
-   0xFFFFFF. The return value is zero if fails, otherwise non-zero.  */
-int
-next_partition (unsigned long drive, unsigned long dest,
-		unsigned long *partition, int *type,
-		unsigned long *start, unsigned long *len,
-		unsigned long *offset, int *entry,
-		unsigned long *ext_offset, char *buf)
-{
-  /* Forward declarations.  */
-  auto int next_bsd_partition (void);
-  auto int next_solaris_partition(void);
-  auto int next_pc_slice (void);
-
-  /* Get next BSD partition in current PC slice.  */
-  int next_bsd_partition (void)
-    {
-      int i;
-      int bsd_part_no = (*partition &amp; 0xFF00) &gt;&gt; 8;
-
-      /* If this is the first time...  */
-      if (bsd_part_no == 0xFF)
-	{
-	  /* Check if the BSD label is within current PC slice.  */
-	  if (*len &lt; BSD_LABEL_SECTOR + 1)
-	    {
-	      errnum = ERR_BAD_PART_TABLE;
-	      return 0;
-	    }
-
-	  /* Read the BSD label.  */
-	  if (! rawread (drive, *start + BSD_LABEL_SECTOR,
-			 0, SECTOR_SIZE, buf))
-	    return 0;
-
-	  /* Check if it is valid.  */
-	  if (! BSD_LABEL_CHECK_MAG (buf))
-	    {
-	      errnum = ERR_BAD_PART_TABLE;
-	      return 0;
-	    }
-	  
-	  bsd_part_no = -1;
-	}
-
-      /* Search next valid BSD partition.  */
-      for (i = bsd_part_no + 1; i &lt; BSD_LABEL_NPARTS (buf); i++)
-	{
-	  if (BSD_PART_TYPE (buf, i))
-	    {
-	      /* Note that *TYPE and *PARTITION were set
-		 for current PC slice.  */
-	      *type = (BSD_PART_TYPE (buf, i) &lt;&lt; 8) | (*type &amp; 0xFF);
-	      *start = BSD_PART_START (buf, i);
-	      *len = BSD_PART_LENGTH (buf, i);
-	      *partition = (*partition &amp; 0xFF00FF) | (i &lt;&lt; 8);
-
-#ifndef STAGE1_5
-	      /* XXX */
-	      if ((drive &amp; 0x80) &amp;&amp; BSD_LABEL_DTYPE (buf) == DTYPE_SCSI)
-		bsd_evil_hack = 4;
-#endif /* ! STAGE1_5 */
-	      
-	      return 1;
-	    }
-	}
-
-      errnum = ERR_NO_PART;
-      return 0;
-    }
-
-  /* Get next Solaris partition in current PC slice.  */
-  int next_solaris_partition (void)
-    {
-      static unsigned long pcs_start;
-      int i;
-      int sol_part_no = (*partition &amp; 0xFF00) &gt;&gt; 8;
-
-      /* If this is the first time...  */
-      if (sol_part_no == 0xFF)
-	{
-	  /* Check if the Solaris label is within current PC slice.  */
-	  if (*len &lt; SOL_LABEL_LOC + 1)
-	    {
-	      errnum = ERR_BAD_PART_TABLE;
-	      return 0;
-	    }
-
-	  /* Read the Solaris label.  */
-	  if (! rawread (drive, *start + SOL_LABEL_LOC, 0, SECTOR_SIZE, buf))
-	    return 0;
-
-	  /* Check if it is valid.  */
-	  if (! SOL_LABEL_CHECK_MAG (buf))
-	    {
-	      errnum = ERR_BAD_PART_TABLE;
-	      return 0;
-	    }
-	  
-	  sol_part_no = -1;
-	  pcs_start = *start;	/* save the start of pc slice */
-	}
-
-      /* Search next valid BSD partition.  */
-      for (i = sol_part_no + 1; i &lt; SOL_LABEL_NPARTS; i++)
-	{
-	  if (SOL_PART_EXISTS (buf, i))
-	    {
-	      /* SOL_PART_START is relative to fdisk partition */
-	      *start = SOL_PART_START (buf, i) + pcs_start;
-	      *len = SOL_PART_LENGTH (buf, i);
-	      *partition = (*partition &amp; 0xFF00FF) | (i &lt;&lt; 8);
-
-	      return 1;
-	    }
-	}
-
-      errnum = ERR_NO_PART;
-      return 0;
-    }
-
-  /* Get next PC slice. Be careful of that this function may return
-     an empty PC slice (i.e. a partition whose type is zero) as well.  */
-  int next_pc_slice (void)
-    {
-      int pc_slice_no = (*partition &amp; 0xFF0000) &gt;&gt; 16;
-
-      /* If this is the first time...  */
-      if (pc_slice_no == 0xFF)
-	{
-	  *offset = 0;
-	  *ext_offset = 0;
-	  *entry = -1;
-	  pc_slice_no = -1;
-	}
-
-      /* Read the MBR or the boot sector of the extended partition.  */
-      if (! rawread (drive, *offset, 0, SECTOR_SIZE, buf)) 
-	return 0;
-
-
-      /* Check if it is valid.  */
-      if (! PC_MBR_CHECK_SIG (buf))
-	{
-	  errnum = ERR_BAD_PART_TABLE;
-	  return 0;
-	}
-
-      /* Increase the entry number.  */
-      (*entry)++;
-
-      /* If this is out of current partition table...  */
-      if (*entry == PC_SLICE_MAX)
-	{
-	  int i;
-	  /* Search the first extended partition in current table.  */
-	  for (i = 0; i &lt; PC_SLICE_MAX; i++)
-	    {
-	      if (IS_PC_SLICE_TYPE_EXTENDED (PC_SLICE_TYPE (buf, i)))
-		{
-		  /* Found. Set the new offset and the entry number,
-		     and restart this function.  */
-		  *offset = *ext_offset + PC_SLICE_START (buf, i);
-		  if (! *ext_offset)
-		    *ext_offset = *offset;
-		  *entry = -1;
-		  return next_pc_slice ();
-		}
-	    }
-
-	  errnum = ERR_NO_PART;
-	  return 0;
-	}
-      
-      *type = PC_SLICE_TYPE (buf, *entry);
-      *start = *offset + PC_SLICE_START (buf, *entry);
-      *len = PC_SLICE_LENGTH (buf, *entry);
-
-      /* The calculation of a PC slice number is complicated, because of
-	 the rather odd definition of extended partitions. Even worse,
-	 there is no guarantee that this is consistent with every
-	 operating systems. Uggh.  */
-      if (pc_slice_no &lt; PC_SLICE_MAX
-	  || (! IS_PC_SLICE_TYPE_EXTENDED (*type)
-	      &amp;&amp; *type != PC_SLICE_TYPE_NONE))
-	pc_slice_no++;
-      *partition = (pc_slice_no &lt;&lt; 16) | 0xFFFF;
-      return 1;
-    }
-
-  /* Start the body of this function.  */
-  
-#ifndef STAGE1_5
-  if (current_drive == NETWORK_DRIVE)
-    return 0;
-#endif
-
-
-
-
-
-
-
-
-
-
-
-
-
-  /* check for Solaris partition */
-  if (*partition != 0xFFFFFF &amp;&amp; IS_PC_SLICE_TYPE_SOLARIS (*type &amp; 0xff))
-    {
-      if (next_solaris_partition ())
-	return 1;
-      errnum = ERR_NONE;
-    }
-
-  /* If previous partition is a BSD partition or a PC slice which
-     contains BSD partitions...  */
-  if ((*partition != 0xFFFFFF &amp;&amp; IS_PC_SLICE_TYPE_BSD (*type &amp; 0xff))
-      || ! (drive &amp; 0x80))
-    {
-      if (*type == PC_SLICE_TYPE_NONE)
-	*type = PC_SLICE_TYPE_FREEBSD;
-      
-      /* Get next BSD partition, if any.  */
-      if (next_bsd_partition ())
-	return 1;
-
-      /* If the destination partition is a BSD partition and current
-	 BSD partition has any error, abort the operation.  */
-      if ((dest &amp; 0xFF00) != 0xFF00
-	  &amp;&amp; ((dest &amp; 0xFF0000) == 0xFF0000
-	      || (dest &amp; 0xFF0000) == (*partition &amp; 0xFF0000)))
-	return 0;
-
-      /* Ignore the error.  */
-      errnum = ERR_NONE;
-    }
-  return next_pc_slice ();
-}
-
-#ifndef STAGE1_5
-// THE FIX of error 25 needs removing this line static unsigned long cur_part_offset; adrian15
-static unsigned long cur_part_addr;
-#endif
-
-
-
-
-/* Open a partition.  */
-int
-real_open_partition (int flags)
-{
-  unsigned long dest_partition = current_partition;
-  unsigned long part_offset;
-  unsigned long ext_offset;
-  int entry;
-  char buf[SECTOR_SIZE];
-  int unix_part, pc_slice;
-
-  /* For simplicity.  */
-  auto int next (void);
-  int next (void)
-    {
-      int ret = next_partition (current_drive, dest_partition,
-				&amp;current_partition, &amp;current_slice,
-				&amp;part_start, &amp;part_length,
-				&amp;part_offset, &amp;entry, &amp;ext_offset, buf);
-      unix_part = (current_partition &gt;&gt; 8) &amp; 0xFF;
-      pc_slice = current_partition &gt;&gt; 16;
-      return ret;
-    }
-  
-#ifndef STAGE1_5
-  /* network drive */
-  if (current_drive == NETWORK_DRIVE)
-    return 1;
-  
-  if (! sane_partition ())
-    return 0;
-#endif
-
-  bsd_evil_hack = 0;
-  current_slice = 0;
-  part_start = 0;
-
-  /* Make sure that buf_geom is valid. */
-  if (buf_drive != current_drive)
-    {
-      if (get_diskinfo (current_drive, &amp;buf_geom))
-	{
-	  errnum = ERR_NO_DISK;
-	  return 0;
-	}
-      buf_drive = current_drive;
-      buf_track = -1;
-    }
-  part_length = buf_geom.total_sectors;
-
-  /* If this is the whole disk, return here.  */
-  if (! flags &amp;&amp; current_partition == 0xFFFFFF)
-
-    {
-#ifndef STAGE1_5
-      cur_part_offset = 0;
-#endif /* ! STAGE1_5 */
-      return 1;
-    }
-  if (flags)
-    dest_partition = 0xFFFFFF;
-
-  /* Initialize CURRENT_PARTITION for next_partition.  */
-  current_partition = 0xFFFFFF;
-  
-  while (next ())
-    {
-#ifndef STAGE1_5
-    loop_start:
-      
-      cur_part_offset = part_offset;
-      cur_part_addr = BOOT_PART_TABLE + (entry &lt;&lt; 4);
-#endif /* ! STAGE1_5 */
-
-      /* If this is a valid partition...  */
-      if (current_slice)
-	{
-#ifndef STAGE1_5
-	  /* Display partition information.  */
-	  if (flags &amp;&amp; ! IS_PC_SLICE_TYPE_EXTENDED (current_slice))
-	    {
-	      if (! do_completion)
-		{
-		  if (current_drive &amp; 0x80)
-		    grub_printf (&quot;   Partition num: %d, &quot;,
-				 current_partition &gt;&gt; 16);
-
-		  if (! IS_PC_SLICE_TYPE_BSD (current_slice) &amp;&amp;
-		      ! IS_PC_SLICE_TYPE_SOLARIS (current_slice))
-		    check_and_print_mount (flags);
-		  else
-		    {
-		      int got_part = 0;
-		      int saved_slice = current_slice;
-		      
-		      while (next ())
-			{
-			  if (unix_part == 0xFF)
-			    break;
-			  
-			  if (! got_part)
-			    {
-			      grub_printf (&quot;[BSD/SOLARIS sub-partitions immediately follow]\n&quot;);
-			      got_part = 1;
-			    }
-			  
-			  grub_printf (&quot;     BSD/SOLARIS Partition num: \'%c\', &quot;,
-				       unix_part + 'a');
-			  check_and_print_mount (flags);
-			}
-
-		      if (! got_part)
-			grub_printf (&quot; No BSD/SOLARIS sub-partition found, partition type 0x%x\n&quot;,
-				     saved_slice);
-		      
-		      if (errnum)
-			{
-			  errnum = ERR_NONE;
-			  break;
-			}
-		      
-		      goto loop_start;
-		    }
-		}
-	      else
-		{
-		  if (unix_part != 0xFF)
-		    {
-		      char str[16];
-		      
-		      if (! (current_drive &amp; 0x80)
-			  || (dest_partition &gt;&gt; 16) == pc_slice)
-			grub_sprintf (str, &quot;%c)&quot;, unix_part + 'a');
-		      else
-			grub_sprintf (str, &quot;%d,%c)&quot;,
-				      pc_slice, unix_part + 'a');
-		      print_a_completion (str);
-		    }
-		  else if (! IS_PC_SLICE_TYPE_BSD (current_slice) &amp;&amp;
-		      ! IS_PC_SLICE_TYPE_SOLARIS (current_slice))
-		    {
-		      char str[8];
-		      
-		      grub_sprintf (str, &quot;%d)&quot;, pc_slice);
-		      print_a_completion (str);
-		    }
-		}
-	    }
-	  
-	  errnum = ERR_NONE;
-#endif /* ! STAGE1_5 */
-	  
-	  /* Check if this is the destination partition.  */
-	  if (! flags
-	      &amp;&amp; (dest_partition == current_partition
-		  || ((dest_partition &gt;&gt; 16) == 0xFF
-		      &amp;&amp; ((dest_partition &gt;&gt; 8) &amp; 0xFF) == unix_part)))
-	    return 1;
-	}
-    }
-
-#ifndef STAGE1_5
-  if (flags)
-    {
-      errnum = ERR_NONE;
-      if (! (current_drive &amp; 0x80))
-	{
-	  current_partition = 0xFFFFFF;
-	  current_slice = 0;
-	  part_start = 0;
-	  part_length = buf_geom.total_sectors;
-	  check_and_print_mount (flags);
-	}
-      else
-	{
-          cur_part_addr = 0;
-          cur_part_offset = 0;
-	}
-      
-      errnum = ERR_NONE;
-      return 1;
-    }
-#endif /* ! STAGE1_5 */
-  
-  return 0;
-}
-
-
-int
-open_partition (void)
-{
-  return real_open_partition (0);
-}
-
-
-#ifndef STAGE1_5
-/* XX used for device completion in 'set_device' and 'print_completions' */
-static int incomplete, disk_choice;
-static enum
-{
-  PART_UNSPECIFIED = 0,
-  PART_DISK,
-  PART_CHOSEN,
-}
-part_choice;
-#endif /* ! STAGE1_5 */
-
-
-char *
-set_device (char *device)
-{
-#ifdef STAGE1_5
-    /* In Stage 1.5, the first 4 bytes of FILENAME has a device number.  */
-  unsigned long dev = *((unsigned long *) device);
-  int drive = (dev &gt;&gt; 24) &amp; 0xFF;
-  int partition = dev &amp; 0xFFFFFF;
-
-  /* If DRIVE is disabled, use SAVED_DRIVE instead.  */
-  if (drive == GRUB_INVALID_DRIVE)
-    current_drive = saved_drive;
-  else
-    current_drive = drive;
-
-  /* The `partition' part must always have a valid number.  */
-  current_partition = partition;
-  
-  return device + sizeof (unsigned long);
-  
-#else /* ! STAGE1_5 */
-  
-  int result = 0;
-
-  incomplete = 0;
-  disk_choice = 1;
-  part_choice = PART_UNSPECIFIED;
-  current_drive = saved_drive;
-  current_partition = 0xFFFFFF;
-
-  if (*device == '(' &amp;&amp; !*(device + 1))
-    /* user has given '(' only, let disk_choice handle what disks we have */
-    return device + 1;
-
-  if (*device == '(' &amp;&amp; *(++device))
-    {
-      if (*device != ',' &amp;&amp; *device != ')')
-	{
-	  char ch = *device;
-#ifdef SUPPORT_NETBOOT
-	  if (*device == 'n' &amp;&amp; !network_ready)
-	    bootp();
-
-	  if (*device == 'f' || *device == 'h'
-	      || (*device == 'n' &amp;&amp; network_ready)
-	      || (*device == 'c' &amp;&amp; cdrom_drive != GRUB_INVALID_DRIVE))
-#else
-	  if (*device == 'f' || *device == 'h'
-	      || (*device == 'c' &amp;&amp; cdrom_drive != GRUB_INVALID_DRIVE))
-#endif /* SUPPORT_NETBOOT */
-	    {
-	      /* user has given '([fhn]', check for resp. add 'd' and
-		 let disk_choice handle what disks we have */
-	      if (!*(device + 1))
-		{
-		  device++;
-		  *device++ = 'd';
-		  *device = '\0';
-		  return device;
-		}
-	      else if (*(device + 1) == 'd' &amp;&amp; !*(device + 2))
-		return device + 2;
-	    }
-
-	  if ((*device == 'f'
-	       || *device == 'h'
-#ifdef SUPPORT_NETBOOT
-	       || (*device == 'n' &amp;&amp; network_ready)
-#endif
-	       || (*device == 'c' &amp;&amp; cdrom_drive != GRUB_INVALID_DRIVE))
-	      &amp;&amp; (device += 2, (*(device - 1) != 'd')))
-	    errnum = ERR_NUMBER_PARSING;
-	  
-#ifdef SUPPORT_NETBOOT
-	  if (ch == 'n' &amp;&amp; network_ready)
-	    current_drive = NETWORK_DRIVE;
-	  else
-#endif /* SUPPORT_NETBOOT */
-	    {
-	      if (ch == 'c' &amp;&amp; cdrom_drive != GRUB_INVALID_DRIVE)
-		current_drive = cdrom_drive;
-	      else
-		{
-		  safe_parse_maxint (&amp;device, (int *) &amp;current_drive);
-		  
-		  disk_choice = 0;
-		  if (ch == 'h')
-		    current_drive += 0x80;
-		}
-	    }
-	}
-
-      if (errnum)
-	return 0;
-
-      if (*device == ')')
-	{
-	  part_choice = PART_CHOSEN;
-	  result = 1;
-	}
-      else if (*device == ',')
-	{
-	  /* Either an absolute PC, BSD, or Solaris partition. */
-	  disk_choice = 0;
-	  part_choice ++;
-	  device++;
-
-	  if (*device &gt;= '0' &amp;&amp; *device &lt;= '9')
-	    {
-	      part_choice ++;
-	      current_partition = 0;
-
-	      if (!(current_drive &amp; 0x80)
-		  || !safe_parse_maxint (&amp;device, (int *) &amp;current_partition)
-		  || current_partition &gt; 254)
-		{
-		  errnum = ERR_DEV_FORMAT;
-		  return 0;
-		}
-
-	      current_partition = (current_partition &lt;&lt; 16) + 0xFFFF;
-
-	      if (*device == ',')
-		device++;
-	      
-	      if (*device &gt;= 'a' &amp;&amp; *device &lt;= 'p')
-		{
-		  current_partition = (((*(device++) - 'a') &lt;&lt; 8)
-				       | (current_partition &amp; 0xFF00FF));
-		}
-	    }
-	  else if (*device &gt;= 'a' &amp;&amp; *device &lt;= 'p')
-	    {
-	      part_choice ++;
-	      current_partition = ((*(device++) - 'a') &lt;&lt; 8) | 0xFF00FF;
-	    }
-
-	  if (*device == ')')
-	    {
-	      if (part_choice == PART_DISK)
-		{
-		  current_partition = saved_partition;
-		  part_choice ++;
-		}
-
-	      result = 1;
-	    }
-	}
-    }
-
-  if (! sane_partition ())
-    return 0;
-  
-  if (result)
-    return device + 1;
-  else
-    {
-      if (!*device)
-	incomplete = 1;
-      errnum = ERR_DEV_FORMAT;
-    }
-
-  return 0;
-  
-#endif /* ! STAGE1_5 */
-}
-
-/*
- *  This performs a &quot;mount&quot; on the current device, both drive and partition
- *  number.
- */
-
-int
-open_device (void)
-{
-  if (open_partition ())
-    attempt_mount ();
-
-  if (errnum != ERR_NONE)
-    return 0;
-
-  return 1;
-}
-
-
-#ifndef STAGE1_5
-int
-set_bootdev (int hdbias)
-{
-  int i, j;
-
-  /* Copy the boot partition information to 0x7be-0x7fd for chain-loading.  */
-  if ((saved_drive &amp; 0x80) &amp;&amp; cur_part_addr)
-    {
-      if (rawread (saved_drive, cur_part_offset,
-		   0, SECTOR_SIZE, (char *) SCRATCHADDR))
-	{
-	  char *dst, *src;
-      
-	  /* Need only the partition table.
-	     XXX: We cannot use grub_memmove because BOOT_PART_TABLE
-	     (0x07be) is less than 0x1000.  */
-	  dst = (char *) BOOT_PART_TABLE;
-	  src = (char *) SCRATCHADDR + BOOTSEC_PART_OFFSET;
-	  while (dst &lt; (char *) BOOT_PART_TABLE + BOOTSEC_PART_LENGTH)
-	    *dst++ = *src++;
-	  
-	  /* Set the active flag of the booted partition.  */
-	  for (i = 0; i &lt; 4; i++)
-	    PC_SLICE_FLAG (BOOT_PART_TABLE, i) = 0;
-	  
-	  *((unsigned char *) cur_part_addr) = PC_SLICE_FLAG_BOOTABLE;
-	  boot_part_addr = cur_part_addr;
-	}
-      else
-	return 0;
-    }
-  
-  /*
-   *  Set BSD boot device.
-   */
-  i = (saved_partition &gt;&gt; 16) + 2;
-  if (saved_partition == 0xFFFFFF)
-    i = 1;
-  else if ((saved_partition &gt;&gt; 16) == 0xFF)
-    i = 0;
-
-  /* FIXME: extremely evil hack!!! */
-  j = 2;
-  if (saved_drive &amp; 0x80)
-    j = bsd_evil_hack;
-
-  return MAKEBOOTDEV (j, (i &gt;&gt; 4), (i &amp; 0xF),
-		      ((saved_drive - hdbias) &amp; 0x7F),
-		      ((saved_partition &gt;&gt; 8) &amp; 0xFF));
-}
-#endif /* STAGE1_5 */
-
-
-static char *
-setup_part (char *filename)
-{
-#ifdef STAGE1_5
-
-  if (! (filename = set_device (filename)))
-    {
-      current_drive = GRUB_INVALID_DRIVE;
-      return 0;
-    }
-  
-# ifndef NO_BLOCK_FILES
-  if (*filename != '/')
-    open_partition ();
-  else
-# endif /* ! NO_BLOCK_FILES */
-    open_device ();
-  
-#else /* ! STAGE1_5 */
-  
-  if (*filename == '(')
-    {
-      if ((filename = set_device (filename)) == 0)
-	{
-	  current_drive = GRUB_INVALID_DRIVE;
-	  return 0;
-	}
-# ifndef NO_BLOCK_FILES
-      if (*filename != '/')
-	open_partition ();
-      else
-# endif /* ! NO_BLOCK_FILES */
-	open_device ();
-    }
-  else if (saved_drive != current_drive
-	   || saved_partition != current_partition
-	   || (*filename == '/' &amp;&amp; fsys_type == NUM_FSYS)
-	   || buf_drive == -1)
-    {
-      current_drive = saved_drive;
-      current_partition = saved_partition;
-      /* allow for the error case of &quot;no filesystem&quot; after the partition
-         is found.  This makes block files work fine on no filesystem */
-# ifndef NO_BLOCK_FILES
-      if (*filename != '/')
-	open_partition ();
-      else
-# endif /* ! NO_BLOCK_FILES */
-	open_device ();
-    }
-  
-#endif /* ! STAGE1_5 */
-  
-  if (errnum &amp;&amp; (*filename == '/' || errnum != ERR_FSYS_MOUNT))
-    return 0;
-  else
-    errnum = 0;
-
-#ifndef STAGE1_5
-  if (!sane_partition ())
-    return 0;
-#endif
-
-  return filename;
-}
-
-
-#ifndef STAGE1_5
-/*
- *  This prints the filesystem type or gives relevant information.
- */
-
-void
-print_fsys_type (void)
-{
-  if (! do_completion)
-    {
-      printf (&quot; Filesystem type &quot;);
-      
-      if (fsys_type != NUM_FSYS)
-	printf (&quot;is %s, &quot;, fsys_table[fsys_type].name);
-      else
-	printf (&quot;unknown, &quot;);
-      
-      if (current_partition == 0xFFFFFF)
-	printf (&quot;using whole disk\n&quot;);
-      else
-	printf (&quot;partition type 0x%x\n&quot;, current_slice &amp; 0xFF);
-    }
-}
-
-void
-save_fsys_type (void)
-{
-
-struct builtin *builtin;
-builtin = find_command (&quot;set&quot;);
-
-char temporal_char[128];
-char *pointer = temporal_char;
-*pointer=0;
-
-      if (fsys_type != NUM_FSYS) {
-	grub_strcpy(pointer,&quot;AUX=&quot;);
-	pointer++;
-	pointer++;
-	pointer++;
-	pointer++;
-	grub_strcpy(pointer,fsys_table[fsys_type].name);
-	pointer--;
-	pointer--;
-	pointer--;
-	pointer--;
-	(builtin-&gt;func)(pointer,1);  	
-	}
-      else {
-	
-	(builtin-&gt;func)(&quot;AUX=\&quot;\&quot;&quot;,1);  
-	}
-}
-
-#endif /* STAGE1_5 */
-
-#ifndef STAGE1_5
-/* If DO_COMPLETION is true, just print NAME. Otherwise save the unique
-   part into UNIQUE_STRING.  */
-void
-print_a_completion (char *name)
-{
-  /* If NAME is &quot;.&quot; or &quot;..&quot;, do not count it.  */
-  if (grub_strcmp (name, &quot;.&quot;) == 0 || grub_strcmp (name, &quot;..&quot;) == 0)
-    return;
-  
-  if (do_completion)
-    {
-      char *buf = unique_string;
-      
-      if (! unique)
-	while ((*buf++ = *name++))
-	  ;
-      else
-	{
-	  while (*buf &amp;&amp; (*buf == *name))
-	    {
-	      buf++;
-	      name++;
-	    }
-	  /* mismatch, strip it.  */
-	  *buf = '\0';
-	}
-    }
-  else
-    grub_printf (&quot; %s&quot;, name);
-  
-  unique++;
-}
-
-/*
- *  This lists the possible completions of a device string, filename, or
- *  any sane combination of the two.
- */
-
-int
-print_completions (int is_filename, int is_completion)
-{
-  char *buf = (char *) COMPLETION_BUF;
-  char *ptr = buf;
-
-  unique_string = (char *) UNIQUE_BUF;
-  *unique_string = 0;
-  unique = 0;
-  do_completion = is_completion;
-
-  if (! is_filename)
-    {
-      /* Print the completions of builtin commands.  */
-      struct builtin **builtin;
-
-      if (! is_completion)
-	grub_printf (&quot; Possible commands are:&quot;);
-      
-      for (builtin = builtin_table; (*builtin); builtin++)
-	{
-	  /* If *BUILTIN cannot be run in the command-line, skip it.  */
-	  if (! ((*builtin)-&gt;flags &amp; BUILTIN_CMDLINE))
-	    continue;
-
-	  if (substring (buf, (*builtin)-&gt;name) &lt;= 0)
-	    print_a_completion ((*builtin)-&gt;name);
-	}
-
-      if (is_completion &amp;&amp; *unique_string)
-	{
-	  if (unique == 1)
-	    {
-	      char *u = unique_string + grub_strlen (unique_string);
-
-	      *u++ = ' ';
-	      *u = 0;
-	    }
-	  
-	  grub_strcpy (buf, unique_string);
-	}
-
-      if (! is_completion)
-	grub_putchar ('\n');
-      
-      print_error ();
-      do_completion = 0;
-      if (errnum)
-	return -1;
-      else
-	return unique - 1;
-    }
-
-  if (*buf == '/' || (ptr = set_device (buf)) || incomplete)
-    {
-      errnum = 0;
-
-      if (*buf == '(' &amp;&amp; (incomplete || ! *ptr))
-	{
-	  if (! part_choice)
-	    {
-	      /* disk completions */
-	      int disk_no, i, j;
-	      struct geometry geom;
-
-	      if (! is_completion)
-		grub_printf (&quot; Possible disks are: &quot;);
-
-	      if (!ptr
-		  || *(ptr-1) != 'd'
-#ifdef SUPPORT_NETBOOT
-		  || *(ptr-2) != 'n'
-#endif /* SUPPORT_NETBOOT */
-		  || *(ptr-2) != 'c')
-		{
-		  for (i = (ptr &amp;&amp; (*(ptr-1) == 'd' &amp;&amp; *(ptr-2) == 'h') ? 1:0);
-		       i &lt; (ptr &amp;&amp; (*(ptr-1) == 'd' &amp;&amp; *(ptr-2) == 'f') ? 1:2);
-		       i++)
-		    {
-		      for (j = 0; j &lt; 16; j++)
-			{
-			  disk_no = (i * 0x80) + j;
-			  if ((disk_choice || disk_no == current_drive)
-			      &amp;&amp; ! get_diskinfo (disk_no, &amp;geom))
-			    {
-			      char dev_name[8];
-
-			      grub_sprintf (dev_name, &quot;%cd%d&quot;, i ? 'h':'f', j);
-			      print_a_completion (dev_name);
-			    }
-			}
-		    }
-		}
-
-	      if (cdrom_drive != GRUB_INVALID_DRIVE
-		  &amp;&amp; (disk_choice || cdrom_drive == current_drive)
-		  &amp;&amp; (!ptr
-		      || *(ptr-1) == '('
-		      || (*(ptr-1) == 'd' &amp;&amp; *(ptr-2) == 'c')))
-		print_a_completion (&quot;cd&quot;);
-
-# ifdef SUPPORT_NETBOOT
-	      if (network_ready
-		  &amp;&amp; (disk_choice || NETWORK_DRIVE == current_drive)
-		  &amp;&amp; (!ptr
-		      || *(ptr-1) == '('
-		      || (*(ptr-1) == 'd' &amp;&amp; *(ptr-2) == 'n')))
-		print_a_completion (&quot;nd&quot;);
-# endif /* SUPPORT_NETBOOT */
-
-	      if (is_completion &amp;&amp; *unique_string)
-		{
-		  ptr = buf;
-		  while (*ptr != '(')
-		    ptr--;
-		  ptr++;
-		  grub_strcpy (ptr, unique_string);
-		  if (unique == 1)
-		    {
-		      ptr += grub_strlen (ptr);
-		      if (*unique_string == 'h')
-			{
-			  *ptr++ = ',';
-			  *ptr = 0;
-			}
-		      else
-			{
-			  *ptr++ = ')';
-			  *ptr = 0;
-			}
-		    }
-		}
-
-	      if (! is_completion)
-		grub_putchar ('\n');
-	    }
-	  else
-	    {
-	      /* partition completions */
-	      if (part_choice == PART_CHOSEN
-		  &amp;&amp; open_partition ()
-		  &amp;&amp; ! IS_PC_SLICE_TYPE_BSD (current_slice))
-		{
-		  unique = 1;
-		  ptr = buf + grub_strlen (buf);
-		  if (*(ptr - 1) != ')')
-		    {
-		      *ptr++ = ')';
-		      *ptr = 0;
-		    }
-		}
-	      else
-		{
-		  if (! is_completion)
-		    grub_printf (&quot; Possible partitions are:\n&quot;);
-		  real_open_partition (1);
-		  
-		  if (is_completion &amp;&amp; *unique_string)
-		    {
-		      ptr = buf;
-		      while (*ptr++ != ',')
-			;
-		      grub_strcpy (ptr, unique_string);
-		    }
-		}
-	    }
-	}
-      else if (ptr &amp;&amp; *ptr == '/')
-	{
-	  /* filename completions */
-	  if (! is_completion)
-	    grub_printf (&quot; Possible files are:&quot;);
-	  
-	  dir (buf);
-	  
-	  if (is_completion &amp;&amp; *unique_string)
-	    {
-	      ptr += grub_strlen (ptr);
-	      while (*ptr != '/')
-		ptr--;
-	      ptr++;
-	      
-	      grub_strcpy (ptr, unique_string);
-	      
-	      if (unique == 1)
-		{
-		  ptr += grub_strlen (unique_string);
-
-		  /* Check if the file UNIQUE_STRING is a directory.  */
-		  *ptr = '/';
-		  *(ptr + 1) = 0;
-		  
-		  dir (buf);
-		  
-		  /* Restore the original unique value.  */
-		  unique = 1;
-		  
-		  if (errnum)
-		    {
-		      /* Regular file */
-		      errnum = 0;
-		      *ptr = ' ';
-		      *(ptr + 1) = 0;
-		    }
-		}
-	    }
-	  
-	  if (! is_completion)
-	    grub_putchar ('\n');
-	}
-      else
-	errnum = ERR_BAD_FILENAME;
-    }
-
-  print_error ();
-  do_completion = 0;
-  if (errnum)
-    return -1;
-  else
-    return unique - 1;
-}
-#endif /* STAGE1_5 */
-
-
-/*
- *  This is the generic file open function.
- */
-
-int
-grub_open (char *filename)
-{
-#ifndef STAGE1_5
-  const int buf_size = 1500;
-  const char *try_filenames[] = { &quot;menu.lst&quot;, &quot;m&quot; };
-  char fn[buf_size]; /* arbitrary... */
-  char *filename_orig = filename;
-  int trycount = 0;
-
-  if (grub_strlen(filename) &gt; buf_size)
-    {
-      printf(&quot;Buffer overflow: %s(%d)\n&quot;, __FILE__, __LINE__);
-      while (1) {}
-    }
-
-  /* initially, we need to copy filename to fn */
-  grub_strcpy(fn, filename_orig);
-  fn[grub_strlen(filename_orig)] = 0;
-
-restart:
-  errnum = 0; /* hrm... */
-  filename = fn;
-#endif
-
-#ifndef NO_DECOMPRESSION
-  compressed_file = 0;
-#endif /* NO_DECOMPRESSION */
-
-  /* if any &quot;dir&quot; function uses/sets filepos, it must
-     set it to zero before returning if opening a file! */
-  filepos = 0;
-
-  if (!(filename = setup_part (filename)))
-    return 0;
-
-#ifndef NO_BLOCK_FILES
-  block_file = 0;
-#endif /* NO_BLOCK_FILES */
-
-  /* This accounts for partial filesystem implementations. */
-  fsmax = MAXINT;
-
-  if (*filename != '/')
-    {
-#ifndef NO_BLOCK_FILES
-      char *ptr = filename;
-      int tmp, list_addr = BLK_BLKLIST_START;
-      filemax = 0;
-
-      while (list_addr &lt; BLK_MAX_ADDR)
-	{
-	  tmp = 0;
-	  safe_parse_maxint (&amp;ptr, &amp;tmp);
-	  errnum = 0;
-
-	  if (*ptr != '+')
-	    {
-	      if ((*ptr &amp;&amp; *ptr != '/' &amp;&amp; !isspace (*ptr))
-		  || tmp == 0 || tmp &gt; filemax)
-		errnum = ERR_BAD_FILENAME;
-	      else
-		filemax = tmp;
-
-	      break;
-	    }
-
-	  /* since we use the same filesystem buffer, mark it to
-	     be remounted */
-	  fsys_type = NUM_FSYS;
-
-	  BLK_BLKSTART (list_addr) = tmp;
-	  ptr++;
-
-	  if (!safe_parse_maxint (&amp;ptr, &amp;tmp)
-	      || tmp == 0
-	      || (*ptr &amp;&amp; *ptr != ',' &amp;&amp; *ptr != '/' &amp;&amp; !isspace (*ptr)))
-	    {
-	      errnum = ERR_BAD_FILENAME;
-	      break;
-	    }
-
-	  BLK_BLKLENGTH (list_addr) = tmp;
-
-	  filemax += (tmp * SECTOR_SIZE);
-	  list_addr += BLK_BLKLIST_INC_VAL;
-
-	  if (*ptr != ',')
-	    break;
-
-	  ptr++;
-	}
-
-      if (list_addr &lt; BLK_MAX_ADDR &amp;&amp; ptr != filename &amp;&amp; !errnum)
-	{
-	  block_file = 1;
-	  BLK_CUR_FILEPOS = 0;
-	  BLK_CUR_BLKLIST = BLK_BLKLIST_START;
-	  BLK_CUR_BLKNUM = 0;
-
-#ifndef NO_DECOMPRESSION
-	  return gunzip_test_header ();
-#else /* NO_DECOMPRESSION */
-	  return 1;
-#endif /* NO_DECOMPRESSION */
-	}
-#else /* NO_BLOCK_FILES */
-      errnum = ERR_BAD_FILENAME;
-#endif /* NO_BLOCK_FILES */
-    }
-
-  if (!errnum &amp;&amp; fsys_type == NUM_FSYS)
-    errnum = ERR_FSYS_MOUNT;
-
-# ifndef STAGE1_5
-  /* set &quot;dir&quot; function to open a file */
-  print_possibilities = 0;
-# endif
-
-  if (!errnum &amp;&amp; (*(fsys_table[fsys_type].dir_func)) (filename))
-    {
-#ifndef NO_DECOMPRESSION
-      return gunzip_test_header ();
-#else /* NO_DECOMPRESSION */
-      return 1;
-#endif /* NO_DECOMPRESSION */
-    }
-
-  return 0;
-}
-
-
-int
-grub_read (char *buf, int len)
-{
-  /* Make sure &quot;filepos&quot; is a sane value */
-  if ((filepos &lt; 0) || (filepos &gt; filemax))
-    filepos = filemax;
-
-  /* Make sure &quot;len&quot; is a sane value */
-  if ((len &lt; 0) || (len &gt; (filemax - filepos)))
-    len = filemax - filepos;
-
-  /* if target file position is past the end of
-     the supported/configured filesize, then
-     there is an error */
-  if (filepos + len &gt; fsmax)
-    {
-      errnum = ERR_FILELENGTH;
-      return 0;
-    }
-
-#ifndef NO_DECOMPRESSION
-  if (compressed_file)
-    return gunzip_read (buf, len);
-#endif /* NO_DECOMPRESSION */
-
-#ifndef NO_BLOCK_FILES
-  if (block_file)
-    {
-      int size, off, ret = 0;
-
-      while (len &amp;&amp; !errnum)
-	{
-	  /* we may need to look for the right block in the list(s) */
-	  if (filepos &lt; BLK_CUR_FILEPOS)
-	    {
-	      BLK_CUR_FILEPOS = 0;
-	      BLK_CUR_BLKLIST = BLK_BLKLIST_START;
-	      BLK_CUR_BLKNUM = 0;
-	    }
-
-	  /* run BLK_CUR_FILEPOS up to filepos */
-	  while (filepos &gt; BLK_CUR_FILEPOS)
-	    {
-	      if ((filepos - (BLK_CUR_FILEPOS &amp; ~(SECTOR_SIZE - 1)))
-		  &gt;= SECTOR_SIZE)
-		{
-		  BLK_CUR_FILEPOS += SECTOR_SIZE;
-		  BLK_CUR_BLKNUM++;
-
-		  if (BLK_CUR_BLKNUM &gt;= BLK_BLKLENGTH (BLK_CUR_BLKLIST))
-		    {
-		      BLK_CUR_BLKLIST += BLK_BLKLIST_INC_VAL;
-		      BLK_CUR_BLKNUM = 0;
-		    }
-		}
-	      else
-		BLK_CUR_FILEPOS = filepos;
-	    }
-
-	  off = filepos &amp; (SECTOR_SIZE - 1);
-	  size = ((BLK_BLKLENGTH (BLK_CUR_BLKLIST) - BLK_CUR_BLKNUM)
-		  * SECTOR_SIZE) - off;
-	  if (size &gt; len)
-	    size = len;
-
-	  disk_read_func = disk_read_hook;
-
-	  /* read current block and put it in the right place in memory */
-	  devread (BLK_BLKSTART (BLK_CUR_BLKLIST) + BLK_CUR_BLKNUM,
-		   off, size, buf);
-
-	  disk_read_func = NULL;
-
-	  len -= size;
-	  filepos += size;
-	  ret += size;
-	  buf += size;
-	}
-
-      if (errnum)
-	ret = 0;
-
-      return ret;
-    }
-#endif /* NO_BLOCK_FILES */
-
-  if (fsys_type == NUM_FSYS)
-    {
-      errnum = ERR_FSYS_MOUNT;
-      return 0;
-    }
-
-  return (*(fsys_table[fsys_type].read_func)) (buf, len);
-}
-
-#ifndef STAGE1_5
-/* Reposition a file offset.  */
-int
-grub_seek (int offset)
-{
-  if (offset &gt; filemax || offset &lt; 0)
-    return -1;
-
-  filepos = offset;
-  return offset;
-}
-
-int
-dir (char *dirname)
-{
-#ifndef NO_DECOMPRESSION
-  compressed_file = 0;
-#endif /* NO_DECOMPRESSION */
-
-  if (!(dirname = setup_part (dirname)))
-    return 0;
-
-  if (*dirname != '/')
-    errnum = ERR_BAD_FILENAME;
-
-  if (fsys_type == NUM_FSYS)
-    errnum = ERR_FSYS_MOUNT;
-
-  if (errnum)
-    return 0;
-
-  /* set &quot;dir&quot; function to list completions */
-  print_possibilities = 1;
-
-  return (*(fsys_table[fsys_type].dir_func)) (dirname);
-}
-#endif /* STAGE1_5 */
-
-void 
-grub_close (void)
-{
-#ifndef NO_BLOCK_FILES
-  if (block_file)
-    return;
-#endif /* NO_BLOCK_FILES */
-  
-  if (fsys_table[fsys_type].close_func != 0)
-    (*(fsys_table[fsys_type].close_func)) ();
-}

Deleted: castillonroy/dev_grub/stage2/filesys.h.orig
===================================================================
--- castillonroy/dev_grub/stage2/filesys.h.orig	2009-06-01 19:30:15 UTC (rev 3)
+++ castillonroy/dev_grub/stage2/filesys.h.orig	2009-06-02 17:21:33 UTC (rev 4)
@@ -1,175 +0,0 @@
-/* filesys.h - abstract filesystem interface */
-/*
- *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 1999,2000,2001,2004  Free Software Foundation, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#include &quot;pc_slice.h&quot;
-
-#ifdef FSYS_FFS
-#define FSYS_FFS_NUM 1
-int ffs_mount (void);
-int ffs_read (char *buf, int len);
-int ffs_dir (char *dirname);
-int ffs_embed (int *start_sector, int needed_sectors);
-#else
-#define FSYS_FFS_NUM 0
-#endif
-
-#ifdef FSYS_UFS
-#define FSYS_UFS_NUM 1
-int ufs_mount (void);
-int ufs_read (char *buf, int len);
-int ufs_dir (char *dirname);
-int ufs_embed (int *start_sector, int needed_sectors);
-#else
-#define FSYS_UFS_NUM 0
-#endif
-
-#ifdef FSYS_UFS2
-#define FSYS_UFS2_NUM 1
-int ufs2_mount (void);
-int ufs2_read (char *buf, int len);
-int ufs2_dir (char *dirname);
-int ufs2_embed (int *start_sector, int needed_sectors);
-#else
-#define FSYS_UFS2_NUM 0
-#endif
-
-#ifdef FSYS_FAT
-#define FSYS_FAT_NUM 1
-int fat_mount (void);
-int fat_read (char *buf, int len);
-int fat_dir (char *dirname);
-#else
-#define FSYS_FAT_NUM 0
-#endif
-
-#ifdef FSYS_EXT2FS
-#define FSYS_EXT2FS_NUM 1
-int ext2fs_mount (void);
-int ext2fs_read (char *buf, int len);
-int ext2fs_dir (char *dirname);
-#else
-#define FSYS_EXT2FS_NUM 0
-#endif
-
-#ifdef FSYS_MINIX
-#define FSYS_MINIX_NUM 1
-int minix_mount (void);
-int minix_read (char *buf, int len);
-int minix_dir (char *dirname);
-#else
-#define FSYS_MINIX_NUM 0
-#endif
-
-#ifdef FSYS_REISERFS
-#define FSYS_REISERFS_NUM 1
-int reiserfs_mount (void);
-int reiserfs_read (char *buf, int len);
-int reiserfs_dir (char *dirname);
-int reiserfs_embed (int *start_sector, int needed_sectors);
-#else
-#define FSYS_REISERFS_NUM 0
-#endif
-
-#ifdef FSYS_VSTAFS
-#define FSYS_VSTAFS_NUM 1
-int vstafs_mount (void);
-int vstafs_read (char *buf, int len);
-int vstafs_dir (char *dirname);
-#else
-#define FSYS_VSTAFS_NUM 0
-#endif
-
-#ifdef FSYS_JFS
-#define FSYS_JFS_NUM 1
-int jfs_mount (void);
-int jfs_read (char *buf, int len);
-int jfs_dir (char *dirname);
-int jfs_embed (int *start_sector, int needed_sectors);
-#else
-#define FSYS_JFS_NUM 0
-#endif
-
-#ifdef FSYS_XFS
-#define FSYS_XFS_NUM 1
-int xfs_mount (void);
-int xfs_read (char *buf, int len);
-int xfs_dir (char *dirname);
-#else
-#define FSYS_XFS_NUM 0
-#endif
-
-#ifdef FSYS_TFTP
-#define FSYS_TFTP_NUM 1
-int tftp_mount (void);
-int tftp_read (char *buf, int len);
-int tftp_dir (char *dirname);
-void tftp_close (void);
-#else
-#define FSYS_TFTP_NUM 0
-#endif
-
-#ifdef FSYS_ISO9660
-#define FSYS_ISO9660_NUM 1
-int iso9660_mount (void);
-int iso9660_read (char *buf, int len);
-int iso9660_dir (char *dirname);
-#else
-#define FSYS_ISO9660_NUM 0
-#endif
-
-#ifndef NUM_FSYS
-#define NUM_FSYS	\
-  (FSYS_FFS_NUM + FSYS_FAT_NUM + FSYS_EXT2FS_NUM + FSYS_MINIX_NUM	\
-   + FSYS_REISERFS_NUM + FSYS_VSTAFS_NUM + FSYS_JFS_NUM + FSYS_XFS_NUM	\
-   + FSYS_TFTP_NUM + FSYS_ISO9660_NUM + FSYS_UFS_NUM + FSYS_UFS2_NUM)
-#endif
-
-/* defines for the block filesystem info area */
-#ifndef NO_BLOCK_FILES
-#define BLK_CUR_FILEPOS      (*((int*)FSYS_BUF))
-#define BLK_CUR_BLKLIST      (*((int*)(FSYS_BUF+4)))
-#define BLK_CUR_BLKNUM       (*((int*)(FSYS_BUF+8)))
-#define BLK_MAX_ADDR         (FSYS_BUF+0x7FF9)
-#define BLK_BLKSTART(l)      (*((int*)l))
-#define BLK_BLKLENGTH(l)     (*((int*)(l+4)))
-#define BLK_BLKLIST_START    (FSYS_BUF+12)
-#define BLK_BLKLIST_INC_VAL  8
-#endif /* NO_BLOCK_FILES */
-
-/* this next part is pretty ugly, but it keeps it in one place! */
-
-struct fsys_entry
-{
-  char *name;
-  int (*mount_func) (void);
-  int (*read_func) (char *buf, int len);
-  int (*dir_func) (char *dirname);
-  void (*close_func) (void);
-  int (*embed_func) (int *start_sector, int needed_sectors);
-};
-
-#ifdef STAGE1_5
-# define print_possibilities 0
-#else
-extern int print_possibilities;
-#endif
-
-extern int fsmax;
-extern struct fsys_entry fsys_table[NUM_FSYS + 1];

Deleted: castillonroy/dev_grub/stage2/fsys_ext2fs.c.orig
===================================================================
--- castillonroy/dev_grub/stage2/fsys_ext2fs.c.orig	2009-06-01 19:30:15 UTC (rev 3)
+++ castillonroy/dev_grub/stage2/fsys_ext2fs.c.orig	2009-06-02 17:21:33 UTC (rev 4)
@@ -1,835 +0,0 @@
-/*
- *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 1999, 2001, 2003  Free Software Foundation, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#ifdef FSYS_EXT2FS
-
-#include &quot;shared.h&quot;
-#include &quot;filesys.h&quot;
-
-static int mapblock1, mapblock2;
-
-/* sizes are always in bytes, BLOCK values are always in DEV_BSIZE (sectors) */
-#define DEV_BSIZE 512
-
-/* include/linux/fs.h */
-#define BLOCK_SIZE 1024		/* initial block size for superblock read */
-/* made up, defaults to 1 but can be passed via mount_opts */
-#define WHICH_SUPER 1
-/* kind of from fs/ext2/super.c */
-#define SBLOCK (WHICH_SUPER * BLOCK_SIZE / DEV_BSIZE)	/* = 2 */
-
-/* include/asm-i386/types.h */
-typedef __signed__ char __s8;
-typedef unsigned char __u8;
-typedef __signed__ short __s16;
-typedef unsigned short __u16;
-typedef __signed__ int __s32;
-typedef unsigned int __u32;
-
-/*
- * Constants relative to the data blocks, from ext2_fs.h
- */
-#define EXT2_NDIR_BLOCKS                12
-#define EXT2_IND_BLOCK                  EXT2_NDIR_BLOCKS
-#define EXT2_DIND_BLOCK                 (EXT2_IND_BLOCK + 1)
-#define EXT2_TIND_BLOCK                 (EXT2_DIND_BLOCK + 1)
-#define EXT2_N_BLOCKS                   (EXT2_TIND_BLOCK + 1)
-
-/* include/linux/ext2_fs.h */
-struct ext2_super_block
-  {
-    __u32 s_inodes_count;	/* Inodes count */
-    __u32 s_blocks_count;	/* Blocks count */
-    __u32 s_r_blocks_count;	/* Reserved blocks count */
-    __u32 s_free_blocks_count;	/* Free blocks count */
-    __u32 s_free_inodes_count;	/* Free inodes count */
-    __u32 s_first_data_block;	/* First Data Block */
-    __u32 s_log_block_size;	/* Block size */
-    __s32 s_log_frag_size;	/* Fragment size */
-    __u32 s_blocks_per_group;	/* # Blocks per group */
-    __u32 s_frags_per_group;	/* # Fragments per group */
-    __u32 s_inodes_per_group;	/* # Inodes per group */
-    __u32 s_mtime;		/* Mount time */
-    __u32 s_wtime;		/* Write time */
-    __u16 s_mnt_count;		/* Mount count */
-    __s16 s_max_mnt_count;	/* Maximal mount count */
-    __u16 s_magic;		/* Magic signature */
-    __u16 s_state;		/* File system state */
-    __u16 s_errors;		/* Behaviour when detecting errors */
-    __u16 s_pad;
-    __u32 s_lastcheck;		/* time of last check */
-    __u32 s_checkinterval;	/* max. time between checks */
-    __u32 s_creator_os;		/* OS */
-    __u32 s_rev_level;		/* Revision level */
-    __u16 s_def_resuid;		/* Default uid for reserved blocks */
-    __u16 s_def_resgid;		/* Default gid for reserved blocks */
-	/*
-	 * These fields are for EXT2_DYNAMIC_REV superblocks only.
-	 *
-	 * Note: the difference between the compatible feature set and
-	 * the incompatible feature set is that if there is a bit set
-	 * in the incompatible feature set that the kernel doesn't
-	 * know about, it should refuse to mount the filesystem.
-	 * 
-	 * e2fsck's requirements are more strict; if it doesn't know
-	 * about a feature in either the compatible or incompatible
-	 * feature set, it must abort and not try to meddle with
-	 * things it doesn't understand...
-	 */
-	__u32	s_first_ino; 		/* First non-reserved inode */
-	__u16   s_inode_size; 		/* size of inode structure */
-	__u16	s_block_group_nr; 	/* block group # of this superblock */
-	__u32	s_feature_compat; 	/* compatible feature set */
-	__u32	s_feature_incompat; 	/* incompatible feature set */
-	__u32	s_feature_ro_compat; 	/* readonly-compatible feature set */
-	__u8	s_uuid[16];		/* 128-bit uuid for volume */
-	char	s_volume_name[16]; 	/* volume name */
-	char	s_last_mounted[64]; 	/* directory where last mounted */
-	__u32	s_algorithm_usage_bitmap; /* For compression */
-	/*
-	 * Performance hints.  Directory preallocation should only
-	 * happen if the EXT2_COMPAT_PREALLOC flag is on.
-	 */
-	__u8	s_prealloc_blocks;	/* Nr of blocks to try to preallocate*/
-	__u8	s_prealloc_dir_blocks;	/* Nr to preallocate for dirs */
-	__u16	s_padding1;
-	/*
-	 * Journaling support valid if EXT3_FEATURE_COMPAT_HAS_JOURNAL set.
-	 */
-	__u8	s_journal_uuid[16];	/* uuid of journal superblock */
-	__u32	s_journal_inum;		/* inode number of journal file */
-	__u32	s_journal_dev;		/* device number of journal file */
-	__u32	s_last_orphan;		/* start of list of inodes to delete */
-	__u32	s_hash_seed[4];		/* HTREE hash seed */
-	__u8	s_def_hash_version;	/* Default hash version to use */
-	__u8	s_reserved_char_pad;
-	__u16	s_reserved_word_pad;
-	__u32	s_default_mount_opts;
- 	__u32	s_first_meta_bg; 	/* First metablock block group */
-	__u32	s_reserved[190];	/* Padding to the end of the block */
-  };
-
-struct ext2_group_desc
-  {
-    __u32 bg_block_bitmap;	/* Blocks bitmap block */
-    __u32 bg_inode_bitmap;	/* Inodes bitmap block */
-    __u32 bg_inode_table;	/* Inodes table block */
-    __u16 bg_free_blocks_count;	/* Free blocks count */
-    __u16 bg_free_inodes_count;	/* Free inodes count */
-    __u16 bg_used_dirs_count;	/* Directories count */
-    __u16 bg_pad;
-    __u32 bg_reserved[3];
-  };
-
-struct ext2_inode
-  {
-    __u16 i_mode;		/* File mode */
-    __u16 i_uid;		/* Owner Uid */
-    __u32 i_size;		/* 4: Size in bytes */
-    __u32 i_atime;		/* Access time */
-    __u32 i_ctime;		/* 12: Creation time */
-    __u32 i_mtime;		/* Modification time */
-    __u32 i_dtime;		/* 20: Deletion Time */
-    __u16 i_gid;		/* Group Id */
-    __u16 i_links_count;	/* 24: Links count */
-    __u32 i_blocks;		/* Blocks count */
-    __u32 i_flags;		/* 32: File flags */
-    union
-      {
-	struct
-	  {
-	    __u32 l_i_reserved1;
-	  }
-	linux1;
-	struct
-	  {
-	    __u32 h_i_translator;
-	  }
-	hurd1;
-	struct
-	  {
-	    __u32 m_i_reserved1;
-	  }
-	masix1;
-      }
-    osd1;			/* OS dependent 1 */
-    __u32 i_block[EXT2_N_BLOCKS];	/* 40: Pointers to blocks */
-    __u32 i_version;		/* File version (for NFS) */
-    __u32 i_file_acl;		/* File ACL */
-    __u32 i_dir_acl;		/* Directory ACL */
-    __u32 i_faddr;		/* Fragment address */
-    union
-      {
-	struct
-	  {
-	    __u8 l_i_frag;	/* Fragment number */
-	    __u8 l_i_fsize;	/* Fragment size */
-	    __u16 i_pad1;
-	    __u32 l_i_reserved2[2];
-	  }
-	linux2;
-	struct
-	  {
-	    __u8 h_i_frag;	/* Fragment number */
-	    __u8 h_i_fsize;	/* Fragment size */
-	    __u16 h_i_mode_high;
-	    __u16 h_i_uid_high;
-	    __u16 h_i_gid_high;
-	    __u32 h_i_author;
-	  }
-	hurd2;
-	struct
-	  {
-	    __u8 m_i_frag;	/* Fragment number */
-	    __u8 m_i_fsize;	/* Fragment size */
-	    __u16 m_pad1;
-	    __u32 m_i_reserved2[2];
-	  }
-	masix2;
-      }
-    osd2;			/* OS dependent 2 */
-  };
-
-/* linux/limits.h */
-#define NAME_MAX         255	/* # chars in a file name */
-
-/* linux/posix_type.h */
-typedef long linux_off_t;
-
-/* linux/ext2fs.h */
-#define EXT2_NAME_LEN 255
-struct ext2_dir_entry
-  {
-    __u32 inode;		/* Inode number */
-    __u16 rec_len;		/* Directory entry length */
-    __u8 name_len;		/* Name length */
-    __u8 file_type;
-    char name[EXT2_NAME_LEN];	/* File name */
-  };
-
-/* linux/ext2fs.h */
-/*
- * EXT2_DIR_PAD defines the directory entries boundaries
- *
- * NOTE: It must be a multiple of 4
- */
-#define EXT2_DIR_PAD                    4
-#define EXT2_DIR_ROUND                  (EXT2_DIR_PAD - 1)
-#define EXT2_DIR_REC_LEN(name_len)      (((name_len) + 8 + EXT2_DIR_ROUND) &amp; \
-                                         ~EXT2_DIR_ROUND)
-
-
-/* ext2/super.c */
-#define grub_log2(n) ffz(~(n))
-
-#define EXT2_SUPER_MAGIC      0xEF53	/* include/linux/ext2_fs.h */
-#define EXT2_ROOT_INO              2	/* include/linux/ext2_fs.h */
-#define PATH_MAX                1024	/* include/linux/limits.h */
-#define MAX_LINK_COUNT             5	/* number of symbolic links to follow */
-
-/* made up, these are pointers into FSYS_BUF */
-/* read once, always stays there: */
-#define SUPERBLOCK \
-    ((struct ext2_super_block *)(FSYS_BUF))
-#define GROUP_DESC \
-    ((struct ext2_group_desc *) \
-     ((int)SUPERBLOCK + sizeof(struct ext2_super_block)))
-#define INODE \
-    ((struct ext2_inode *)((int)GROUP_DESC + EXT2_BLOCK_SIZE(SUPERBLOCK)))
-#define DATABLOCK1 \
-    ((int)((int)INODE + sizeof(struct ext2_inode)))
-#define DATABLOCK2 \
-    ((int)((int)DATABLOCK1 + EXT2_BLOCK_SIZE(SUPERBLOCK)))
-
-/* linux/ext2_fs.h */
-#define EXT2_ADDR_PER_BLOCK(s)          (EXT2_BLOCK_SIZE(s) / sizeof (__u32))
-#define EXT2_ADDR_PER_BLOCK_BITS(s)		(grub_log2(EXT2_ADDR_PER_BLOCK(s)))
-
-#define EXT2_INODE_SIZE(s)             (SUPERBLOCK-&gt;s_inode_size)
-#define EXT2_INODES_PER_BLOCK(s)       (EXT2_BLOCK_SIZE(s)/EXT2_INODE_SIZE(s))
-
-/* linux/ext2_fs.h */
-#define EXT2_BLOCK_SIZE_BITS(s)        ((s)-&gt;s_log_block_size + 10)
-/* kind of from ext2/super.c */
-#define EXT2_BLOCK_SIZE(s)	(1 &lt;&lt; EXT2_BLOCK_SIZE_BITS(s))
-/* linux/ext2fs.h */
-#define EXT2_DESC_PER_BLOCK(s) \
-     (EXT2_BLOCK_SIZE(s) / sizeof (struct ext2_group_desc))
-/* linux/stat.h */
-#define S_IFMT  00170000
-#define S_IFLNK  0120000
-#define S_IFREG  0100000
-#define S_IFDIR  0040000
-#define S_ISLNK(m)	(((m) &amp; S_IFMT) == S_IFLNK)
-#define S_ISREG(m)      (((m) &amp; S_IFMT) == S_IFREG)
-#define S_ISDIR(m)      (((m) &amp; S_IFMT) == S_IFDIR)
-
-/* include/asm-i386/bitops.h */
-/*
- * ffz = Find First Zero in word. Undefined if no zero exists,
- * so code should check against ~0UL first..
- */
-static __inline__ unsigned long
-ffz (unsigned long word)
-{
-  __asm__ (&quot;bsfl %1,%0&quot;
-:	   &quot;=r&quot; (word)
-:	   &quot;r&quot; (~word));
-  return word;
-}
-
-/* check filesystem types and read superblock into memory buffer */
-int
-ext2fs_mount (void)
-{
-  int retval = 1;
-
-  if ((((current_drive &amp; 0x80) || (current_slice != 0))
-       &amp;&amp; (current_slice != PC_SLICE_TYPE_EXT2FS)
-       &amp;&amp; (current_slice != PC_SLICE_TYPE_LINUX_RAID)
-       &amp;&amp; (! IS_PC_SLICE_TYPE_BSD_WITH_FS (current_slice, FS_EXT2FS))
-       &amp;&amp; (! IS_PC_SLICE_TYPE_BSD_WITH_FS (current_slice, FS_OTHER)))
-      || part_length &lt; (SBLOCK + (sizeof (struct ext2_super_block) / DEV_BSIZE))
-      || !devread (SBLOCK, 0, sizeof (struct ext2_super_block),
-		   (char *) SUPERBLOCK)
-      || SUPERBLOCK-&gt;s_magic != EXT2_SUPER_MAGIC)
-      retval = 0;
-
-  return retval;
-}
-
-/* Takes a file system block number and reads it into BUFFER. */
-static int
-ext2_rdfsb (int fsblock, int buffer)
-{
-#ifdef E2DEBUG
-  printf (&quot;fsblock %d buffer %d\n&quot;, fsblock, buffer);
-#endif /* E2DEBUG */
-  return devread (fsblock * (EXT2_BLOCK_SIZE (SUPERBLOCK) / DEV_BSIZE), 0,
-		  EXT2_BLOCK_SIZE (SUPERBLOCK), (char *) buffer);
-}
-
-/* from
-  ext2/inode.c:ext2_bmap()
-*/
-/* Maps LOGICAL_BLOCK (the file offset divided by the blocksize) into
-   a physical block (the location in the file system) via an inode. */
-static int
-ext2fs_block_map (int logical_block)
-{
-
-#ifdef E2DEBUG
-  unsigned char *i;
-  for (i = (unsigned char *) INODE;
-       i &lt; ((unsigned char *) INODE + sizeof (struct ext2_inode));
-       i++)
-    {
-      printf (&quot;%c&quot;, &quot;0123456789abcdef&quot;[*i &gt;&gt; 4]);
-      printf (&quot;%c&quot;, &quot;0123456789abcdef&quot;[*i % 16]);
-      if (!((i + 1 - (unsigned char *) INODE) % 16))
-	{
-	  printf (&quot;\n&quot;);
-	}
-      else
-	{
-	  printf (&quot; &quot;);
-	}
-    }
-  printf (&quot;logical block %d\n&quot;, logical_block);
-#endif /* E2DEBUG */
-
-  /* if it is directly pointed to by the inode, return that physical addr */
-  if (logical_block &lt; EXT2_NDIR_BLOCKS)
-    {
-#ifdef E2DEBUG
-      printf (&quot;returning %d\n&quot;, (unsigned char *) (INODE-&gt;i_block[logical_block]));
-      printf (&quot;returning %d\n&quot;, INODE-&gt;i_block[logical_block]);
-#endif /* E2DEBUG */
-      return INODE-&gt;i_block[logical_block];
-    }
-  /* else */
-  logical_block -= EXT2_NDIR_BLOCKS;
-  /* try the indirect block */
-  if (logical_block &lt; EXT2_ADDR_PER_BLOCK (SUPERBLOCK))
-    {
-      if (mapblock1 != 1
-	  &amp;&amp; !ext2_rdfsb (INODE-&gt;i_block[EXT2_IND_BLOCK], DATABLOCK1))
-	{
-	  errnum = ERR_FSYS_CORRUPT;
-	  return -1;
-	}
-      mapblock1 = 1;
-      return ((__u32 *) DATABLOCK1)[logical_block];
-    }
-  /* else */
-  logical_block -= EXT2_ADDR_PER_BLOCK (SUPERBLOCK);
-  /* now try the double indirect block */
-  if (logical_block &lt; (1 &lt;&lt; (EXT2_ADDR_PER_BLOCK_BITS (SUPERBLOCK) * 2)))
-    {
-      int bnum;
-      if (mapblock1 != 2
-	  &amp;&amp; !ext2_rdfsb (INODE-&gt;i_block[EXT2_DIND_BLOCK], DATABLOCK1))
-	{
-	  errnum = ERR_FSYS_CORRUPT;
-	  return -1;
-	}
-      mapblock1 = 2;
-      if ((bnum = (((__u32 *) DATABLOCK1)
-		   [logical_block &gt;&gt; EXT2_ADDR_PER_BLOCK_BITS (SUPERBLOCK)]))
-	  != mapblock2
-	  &amp;&amp; !ext2_rdfsb (bnum, DATABLOCK2))
-	{
-	  errnum = ERR_FSYS_CORRUPT;
-	  return -1;
-	}
-      mapblock2 = bnum;
-      return ((__u32 *) DATABLOCK2)
-	[logical_block &amp; (EXT2_ADDR_PER_BLOCK (SUPERBLOCK) - 1)];
-    }
-  /* else */
-  mapblock2 = -1;
-  logical_block -= (1 &lt;&lt; (EXT2_ADDR_PER_BLOCK_BITS (SUPERBLOCK) * 2));
-  if (mapblock1 != 3
-      &amp;&amp; !ext2_rdfsb (INODE-&gt;i_block[EXT2_TIND_BLOCK], DATABLOCK1))
-    {
-      errnum = ERR_FSYS_CORRUPT;
-      return -1;
-    }
-  mapblock1 = 3;
-  if (!ext2_rdfsb (((__u32 *) DATABLOCK1)
-		   [logical_block &gt;&gt; (EXT2_ADDR_PER_BLOCK_BITS (SUPERBLOCK)
-				      * 2)],
-		   DATABLOCK2))
-    {
-      errnum = ERR_FSYS_CORRUPT;
-      return -1;
-    }
-  if (!ext2_rdfsb (((__u32 *) DATABLOCK2)
-		   [(logical_block &gt;&gt; EXT2_ADDR_PER_BLOCK_BITS (SUPERBLOCK))
-		    &amp; (EXT2_ADDR_PER_BLOCK (SUPERBLOCK) - 1)],
-		   DATABLOCK2))
-    {
-      errnum = ERR_FSYS_CORRUPT;
-      return -1;
-    }
-  return ((__u32 *) DATABLOCK2)
-    [logical_block &amp; (EXT2_ADDR_PER_BLOCK (SUPERBLOCK) - 1)];
-}
-
-/* preconditions: all preconds of ext2fs_block_map */
-int
-ext2fs_read (char *buf, int len)
-{
-  int logical_block;
-  int offset;
-  int map;
-  int ret = 0;
-  int size = 0;
-
-#ifdef E2DEBUG
-  static char hexdigit[] = &quot;0123456789abcdef&quot;;
-  unsigned char *i;
-  for (i = (unsigned char *) INODE;
-       i &lt; ((unsigned char *) INODE + sizeof (struct ext2_inode));
-       i++)
-    {
-      printf (&quot;%c&quot;, hexdigit[*i &gt;&gt; 4]);
-      printf (&quot;%c&quot;, hexdigit[*i % 16]);
-      if (!((i + 1 - (unsigned char *) INODE) % 16))
-	{
-	  printf (&quot;\n&quot;);
-	}
-      else
-	{
-	  printf (&quot; &quot;);
-	}
-    }
-#endif /* E2DEBUG */
-  while (len &gt; 0)
-    {
-      /* find the (logical) block component of our location */
-      logical_block = filepos &gt;&gt; EXT2_BLOCK_SIZE_BITS (SUPERBLOCK);
-      offset = filepos &amp; (EXT2_BLOCK_SIZE (SUPERBLOCK) - 1);
-      map = ext2fs_block_map (logical_block);
-#ifdef E2DEBUG
-      printf (&quot;map=%d\n&quot;, map);
-#endif /* E2DEBUG */
-      if (map &lt; 0)
-	break;
-
-      size = EXT2_BLOCK_SIZE (SUPERBLOCK);
-      size -= offset;
-      if (size &gt; len)
-	size = len;
-
-      if (map == 0) {
-        memset ((char *) buf, 0, size);
-      } else {
-        disk_read_func = disk_read_hook;
-
-        devread (map * (EXT2_BLOCK_SIZE (SUPERBLOCK) / DEV_BSIZE),
-	         offset, size, buf);
-
-        disk_read_func = NULL;
-      }
-
-      buf += size;
-      len -= size;
-      filepos += size;
-      ret += size;
-    }
-
-  if (errnum)
-    ret = 0;
-
-  return ret;
-}
-
-
-/* Based on:
-   def_blk_fops points to
-   blkdev_open, which calls (I think):
-   sys_open()
-   do_open()
-   open_namei()
-   dir_namei() which accesses current-&gt;fs-&gt;root
-     fs-&gt;root was set during original mount:
-     (something)... which calls (I think):
-     ext2_read_super()
-     iget()
-     __iget()
-     read_inode()
-     ext2_read_inode()
-       uses desc_per_block_bits, which is set in ext2_read_super()
-       also uses group descriptors loaded during ext2_read_super()
-   lookup()
-   ext2_lookup()
-   ext2_find_entry()
-   ext2_getblk()
-
-*/
-
-static inline
-int ext2_is_fast_symlink (void)
-{
-  int ea_blocks;
-  ea_blocks = INODE-&gt;i_file_acl ? EXT2_BLOCK_SIZE (SUPERBLOCK) / DEV_BSIZE : 0;
-  return INODE-&gt;i_blocks == ea_blocks;
-}
-
-/* preconditions: ext2fs_mount already executed, therefore supblk in buffer
- *   known as SUPERBLOCK
- * returns: 0 if error, nonzero iff we were able to find the file successfully
- * postconditions: on a nonzero return, buffer known as INODE contains the
- *   inode of the file we were trying to look up
- * side effects: messes up GROUP_DESC buffer area
- */
-int
-ext2fs_dir (char *dirname)
-{
-  int current_ino = EXT2_ROOT_INO;	/* start at the root */
-  int updir_ino = current_ino;	/* the parent of the current directory */
-  int group_id;			/* which group the inode is in */
-  int group_desc;		/* fs pointer to that group */
-  int desc;			/* index within that group */
-  int ino_blk;			/* fs pointer of the inode's information */
-  int str_chk = 0;		/* used to hold the results of a string compare */
-  struct ext2_group_desc *gdp;
-  struct ext2_inode *raw_inode;	/* inode info corresponding to current_ino */
-
-  char linkbuf[PATH_MAX];	/* buffer for following symbolic links */
-  int link_count = 0;
-
-  char *rest;
-  char ch;			/* temp char holder */
-
-  int off;			/* offset within block of directory entry (off mod blocksize) */
-  int loc;			/* location within a directory */
-  int blk;			/* which data blk within dir entry (off div blocksize) */
-  long map;			/* fs pointer of a particular block from dir entry */
-  struct ext2_dir_entry *dp;	/* pointer to directory entry */
-#ifdef E2DEBUG
-  unsigned char *i;
-#endif	/* E2DEBUG */
-
-  /* loop invariants:
-     current_ino = inode to lookup
-     dirname = pointer to filename component we are cur looking up within
-     the directory known pointed to by current_ino (if any)
-   */
-
-  while (1)
-    {
-#ifdef E2DEBUG
-      printf (&quot;inode %d\n&quot;, current_ino);
-      printf (&quot;dirname=%s\n&quot;, dirname);
-#endif /* E2DEBUG */
-
-      /* look up an inode */
-      group_id = (current_ino - 1) / (SUPERBLOCK-&gt;s_inodes_per_group);
-      group_desc = group_id &gt;&gt; grub_log2 (EXT2_DESC_PER_BLOCK (SUPERBLOCK));
-      desc = group_id &amp; (EXT2_DESC_PER_BLOCK (SUPERBLOCK) - 1);
-#ifdef E2DEBUG
-      printf (&quot;ipg=%d, dpb=%d\n&quot;, SUPERBLOCK-&gt;s_inodes_per_group,
-	      EXT2_DESC_PER_BLOCK (SUPERBLOCK));
-      printf (&quot;group_id=%d group_desc=%d desc=%d\n&quot;, group_id, group_desc, desc);
-#endif /* E2DEBUG */
-      if (!ext2_rdfsb (
-			(WHICH_SUPER + group_desc + SUPERBLOCK-&gt;s_first_data_block),
-			(int) GROUP_DESC))
-	{
-	  return 0;
-	}
-      gdp = GROUP_DESC;
-      ino_blk = gdp[desc].bg_inode_table +
-	(((current_ino - 1) % (SUPERBLOCK-&gt;s_inodes_per_group))
-	 &gt;&gt; grub_log2 (EXT2_INODES_PER_BLOCK (SUPERBLOCK)));
-#ifdef E2DEBUG
-      printf (&quot;inode table fsblock=%d\n&quot;, ino_blk);
-#endif /* E2DEBUG */
-      if (!ext2_rdfsb (ino_blk, (int) INODE))
-	{
-	  return 0;
-	}
-
-      /* reset indirect blocks! */
-      mapblock2 = mapblock1 = -1;
-
-      raw_inode = (struct ext2_inode *)( (unsigned long)INODE +
-	((current_ino - 1) &amp; (EXT2_INODES_PER_BLOCK (SUPERBLOCK) - 1))
-					 * EXT2_INODE_SIZE(SUPERBLOCK));
-#ifdef E2DEBUG
-      printf (&quot;ipb=%d, sizeof(inode)=%d\n&quot;,
-	      EXT2_INODES_PER_BLOCK (SUPERBLOCK),
-	      EXT2_INODE_SIZE(SUPERBLOCK));
-      printf (&quot;inode=%x, raw_inode=%x\n&quot;, INODE, raw_inode);
-      printf (&quot;offset into inode table block=%d\n&quot;, (int) raw_inode - (int) INODE);
-      for (i = (unsigned char *) INODE; i &lt;= (unsigned char *) raw_inode;
-	   i++)
-	{
-	  printf (&quot;%c&quot;, &quot;0123456789abcdef&quot;[*i &gt;&gt; 4]);
-	  printf (&quot;%c&quot;, &quot;0123456789abcdef&quot;[*i % 16]);
-	  if (!((i + 1 - (unsigned char *) INODE) % 16))
-	    {
-	      printf (&quot;\n&quot;);
-	    }
-	  else
-	    {
-	      printf (&quot; &quot;);
-	    }
-	}
-      printf (&quot;first word=%x\n&quot;, *((int *) raw_inode));
-#endif /* E2DEBUG */
-
-      /* copy inode to fixed location */
-      memmove ((void *) INODE, (void *) raw_inode, sizeof (struct ext2_inode));
-
-#ifdef E2DEBUG
-      printf (&quot;first word=%x\n&quot;, *((int *) INODE));
-#endif /* E2DEBUG */
-
-      /* If we've got a symbolic link, then chase it. */
-      if (S_ISLNK (INODE-&gt;i_mode))
-	{
-	  int len;
-	  if (++link_count &gt; MAX_LINK_COUNT)
-	    {
-	      errnum = ERR_SYMLINK_LOOP;
-	      return 0;
-	    }
-
-	  /* Find out how long our remaining name is. */
-	  len = 0;
-	  while (dirname[len] &amp;&amp; !isspace (dirname[len]))
-	    len++;
-
-	  /* Get the symlink size. */
-	  filemax = (INODE-&gt;i_size);
-	  if (filemax + len &gt; sizeof (linkbuf) - 2)
-	    {
-	      errnum = ERR_FILELENGTH;
-	      return 0;
-	    }
-
-	  if (len)
-	    {
-	      /* Copy the remaining name to the end of the symlink data.
-	         Note that DIRNAME and LINKBUF may overlap! */
-	      memmove (linkbuf + filemax, dirname, len);
-	    }
-	  linkbuf[filemax + len] = '\0';
-
-	  /* Read the symlink data. */
-	  if (! ext2_is_fast_symlink ())
-	    {
-	      /* Read the necessary blocks, and reset the file pointer. */
-	      len = grub_read (linkbuf, filemax);
-	      filepos = 0;
-	      if (!len)
-		return 0;
-	    }
-	  else
-	    {
-	      /* Copy the data directly from the inode. */
-	      len = filemax;
-	      memmove (linkbuf, (char *) INODE-&gt;i_block, len);
-	    }
-
-#ifdef E2DEBUG
-	  printf (&quot;symlink=%s\n&quot;, linkbuf);
-#endif
-
-	  dirname = linkbuf;
-	  if (*dirname == '/')
-	    {
-	      /* It's an absolute link, so look it up in root. */
-	      current_ino = EXT2_ROOT_INO;
-	      updir_ino = current_ino;
-	    }
-	  else
-	    {
-	      /* Relative, so look it up in our parent directory. */
-	      current_ino = updir_ino;
-	    }
-
-	  /* Try again using the new name. */
-	  continue;
-	}
-
-      /* if end of filename, INODE points to the file's inode */
-      if (!*dirname || isspace (*dirname))
-	{
-	  if (!S_ISREG (INODE-&gt;i_mode))
-	    {
-	      errnum = ERR_BAD_FILETYPE;
-	      return 0;
-	    }
-
-	  filemax = (INODE-&gt;i_size);
-	  return 1;
-	}
-
-      /* else we have to traverse a directory */
-      updir_ino = current_ino;
-
-      /* skip over slashes */
-      while (*dirname == '/')
-	dirname++;
-
-      /* if this isn't a directory of sufficient size to hold our file, abort */
-      if (!(INODE-&gt;i_size) || !S_ISDIR (INODE-&gt;i_mode))
-	{
-	  errnum = ERR_BAD_FILETYPE;
-	  return 0;
-	}
-
-      /* skip to next slash or end of filename (space) */
-      for (rest = dirname; (ch = *rest) &amp;&amp; !isspace (ch) &amp;&amp; ch != '/';
-	   rest++);
-
-      /* look through this directory and find the next filename component */
-      /* invariant: rest points to slash after the next filename component */
-      *rest = 0;
-      loc = 0;
-
-      do
-	{
-
-#ifdef E2DEBUG
-	  printf (&quot;dirname=%s, rest=%s, loc=%d\n&quot;, dirname, rest, loc);
-#endif /* E2DEBUG */
-
-	  /* if our location/byte offset into the directory exceeds the size,
-	     give up */
-	  if (loc &gt;= INODE-&gt;i_size)
-	    {
-	      if (print_possibilities &lt; 0)
-		{
-# if 0
-		  putchar ('\n');
-# endif
-		}
-	      else
-		{
-		  errnum = ERR_FILE_NOT_FOUND;
-		  *rest = ch;
-		}
-	      return (print_possibilities &lt; 0);
-	    }
-
-	  /* else, find the (logical) block component of our location */
-	  blk = loc &gt;&gt; EXT2_BLOCK_SIZE_BITS (SUPERBLOCK);
-
-	  /* we know which logical block of the directory entry we are looking
-	     for, now we have to translate that to the physical (fs) block on
-	     the disk */
-	  map = ext2fs_block_map (blk);
-#ifdef E2DEBUG
-	  printf (&quot;fs block=%d\n&quot;, map);
-#endif /* E2DEBUG */
-	  mapblock2 = -1;
-	  if ((map &lt; 0) || !ext2_rdfsb (map, DATABLOCK2))
-	    {
-	      errnum = ERR_FSYS_CORRUPT;
-	      *rest = ch;
-	      return 0;
-	    }
-	  off = loc &amp; (EXT2_BLOCK_SIZE (SUPERBLOCK) - 1);
-	  dp = (struct ext2_dir_entry *) (DATABLOCK2 + off);
-	  /* advance loc prematurely to next on-disk directory entry  */
-	  loc += dp-&gt;rec_len;
-
-	  /* NOTE: ext2fs filenames are NOT null-terminated */
-
-#ifdef E2DEBUG
-	  printf (&quot;directory entry ino=%d\n&quot;, dp-&gt;inode);
-	  if (dp-&gt;inode)
-	    printf (&quot;entry=%s\n&quot;, dp-&gt;name);
-#endif /* E2DEBUG */
-
-	  if (dp-&gt;inode)
-	    {
-	      int saved_c = dp-&gt;name[dp-&gt;name_len];
-
-	      dp-&gt;name[dp-&gt;name_len] = 0;
-	      str_chk = substring (dirname, dp-&gt;name);
-
-# ifndef STAGE1_5
-	      if (print_possibilities &amp;&amp; ch != '/'
-		  &amp;&amp; (!*dirname || str_chk &lt;= 0))
-		{
-		  if (print_possibilities &gt; 0)
-		    print_possibilities = -print_possibilities;
-		  print_a_completion (dp-&gt;name);
-		}
-# endif
-
-	      dp-&gt;name[dp-&gt;name_len] = saved_c;
-	    }
-
-	}
-      while (!dp-&gt;inode || (str_chk || (print_possibilities &amp;&amp; ch != '/')));
-
-      current_ino = dp-&gt;inode;
-      *(dirname = rest) = ch;
-    }
-  /* never get here */
-}
-
-#endif /* FSYS_EXT2_FS */

Deleted: castillonroy/dev_grub/stage2/fsys_fat.c.orig
===================================================================
--- castillonroy/dev_grub/stage2/fsys_fat.c.orig	2009-06-01 19:30:15 UTC (rev 3)
+++ castillonroy/dev_grub/stage2/fsys_fat.c.orig	2009-06-02 17:21:33 UTC (rev 4)
@@ -1,488 +0,0 @@
-/*
- *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 2000,2001,2005   Free Software Foundation, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#ifdef FSYS_FAT
-
-#include &quot;shared.h&quot;
-#include &quot;filesys.h&quot;
-#include &quot;fat.h&quot;
-
-struct fat_superblock 
-{
-  int fat_offset;
-  int fat_length;
-  int fat_size;
-  int root_offset;
-  int root_max;
-  int data_offset;
-  
-  int num_sectors;
-  int num_clust;
-  int clust_eof_marker;
-  int sects_per_clust;
-  int sectsize_bits;
-  int clustsize_bits;
-  int root_cluster;
-  
-  int cached_fat;
-  int file_cluster;
-  int current_cluster_num;
-  int current_cluster;
-};
-
-/* pointer(s) into filesystem info buffer for DOS stuff */
-#define FAT_SUPER ( (struct fat_superblock *) \
- 		    ( FSYS_BUF + 32256) )/* 512 bytes long */
-#define FAT_BUF   ( FSYS_BUF + 30208 )	/* 4 sector FAT buffer */
-#define NAME_BUF  ( FSYS_BUF + 29184 )	/* Filename buffer (833 bytes) */
-
-#define FAT_CACHE_SIZE 2048
-
-static __inline__ unsigned long
-grub_log2 (unsigned long word)
-{
-  __asm__ (&quot;bsfl %1,%0&quot;
-	   : &quot;=r&quot; (word)
-	   : &quot;r&quot; (word));
-  return word;
-}
-
-int
-fat_mount (void)
-{
-  struct fat_bpb bpb;
-  __u32 magic, first_fat;
-  
-  /* Check partition type for harddisk */
-  if (((current_drive &amp; 0x80) || (current_slice != 0))
-      &amp;&amp; ! IS_PC_SLICE_TYPE_FAT (current_slice)
-      &amp;&amp; (! IS_PC_SLICE_TYPE_BSD_WITH_FS (current_slice, FS_MSDOS)))
-    return 0;
-  
-  /* Read bpb */
-  if (! devread (0, 0, sizeof (bpb), (char *) &amp;bpb))
-    return 0;
-
-  /* Check if the number of sectors per cluster is zero here, to avoid
-     zero division.  */
-  if (bpb.sects_per_clust == 0)
-    return 0;
-  
-  FAT_SUPER-&gt;sectsize_bits = grub_log2 (FAT_CVT_U16 (bpb.bytes_per_sect));
-  FAT_SUPER-&gt;clustsize_bits
-    = FAT_SUPER-&gt;sectsize_bits + grub_log2 (bpb.sects_per_clust);
-  
-  /* Fill in info about super block */
-  FAT_SUPER-&gt;num_sectors = FAT_CVT_U16 (bpb.short_sectors) 
-    ? FAT_CVT_U16 (bpb.short_sectors) : bpb.long_sectors;
-  
-  /* FAT offset and length */
-  FAT_SUPER-&gt;fat_offset = FAT_CVT_U16 (bpb.reserved_sects);
-  FAT_SUPER-&gt;fat_length = 
-    bpb.fat_length ? bpb.fat_length : bpb.fat32_length;
-  
-  /* Rootdir offset and length for FAT12/16 */
-  FAT_SUPER-&gt;root_offset = 
-    FAT_SUPER-&gt;fat_offset + bpb.num_fats * FAT_SUPER-&gt;fat_length;
-  FAT_SUPER-&gt;root_max = FAT_DIRENTRY_LENGTH * FAT_CVT_U16(bpb.dir_entries);
-  
-  /* Data offset and number of clusters */
-  FAT_SUPER-&gt;data_offset = 
-    FAT_SUPER-&gt;root_offset
-    + ((FAT_SUPER-&gt;root_max - 1) &gt;&gt; FAT_SUPER-&gt;sectsize_bits) + 1;
-  FAT_SUPER-&gt;num_clust = 
-    2 + ((FAT_SUPER-&gt;num_sectors - FAT_SUPER-&gt;data_offset) 
-	 / bpb.sects_per_clust);
-  FAT_SUPER-&gt;sects_per_clust = bpb.sects_per_clust;
-  
-  if (!bpb.fat_length)
-    {
-      /* This is a FAT32 */
-      if (FAT_CVT_U16(bpb.dir_entries))
- 	return 0;
-      
-      if (bpb.flags &amp; 0x0080)
-	{
-	  /* FAT mirroring is disabled, get active FAT */
-	  int active_fat = bpb.flags &amp; 0x000f;
-	  if (active_fat &gt;= bpb.num_fats)
-	    return 0;
-	  FAT_SUPER-&gt;fat_offset += active_fat * FAT_SUPER-&gt;fat_length;
-	}
-      
-      FAT_SUPER-&gt;fat_size = 8;
-      FAT_SUPER-&gt;root_cluster = bpb.root_cluster;
-
-      /* Yes the following is correct.  FAT32 should be called FAT28 :) */
-      FAT_SUPER-&gt;clust_eof_marker = 0xffffff8;
-    } 
-  else 
-    {
-      if (!FAT_SUPER-&gt;root_max)
- 	return 0;
-      
-      FAT_SUPER-&gt;root_cluster = -1;
-      if (FAT_SUPER-&gt;num_clust &gt; FAT_MAX_12BIT_CLUST) 
-	{
-	  FAT_SUPER-&gt;fat_size = 4;
-	  FAT_SUPER-&gt;clust_eof_marker = 0xfff8;
-	} 
-      else
-	{
-	  FAT_SUPER-&gt;fat_size = 3;
-	  FAT_SUPER-&gt;clust_eof_marker = 0xff8;
-	}
-    }
-
-  /* Now do some sanity checks */
-  
-  if (FAT_CVT_U16(bpb.bytes_per_sect) != (1 &lt;&lt; FAT_SUPER-&gt;sectsize_bits)
-      || FAT_CVT_U16(bpb.bytes_per_sect) != SECTOR_SIZE
-      || bpb.sects_per_clust != (1 &lt;&lt; (FAT_SUPER-&gt;clustsize_bits
- 				       - FAT_SUPER-&gt;sectsize_bits))
-      || FAT_SUPER-&gt;num_clust &lt;= 2
-      || (FAT_SUPER-&gt;fat_size * FAT_SUPER-&gt;num_clust / (2 * SECTOR_SIZE)
- 	  &gt; FAT_SUPER-&gt;fat_length))
-    return 0;
-  
-  /* kbs: Media check on first FAT entry [ported from PUPA] */
-
-  if (!devread(FAT_SUPER-&gt;fat_offset, 0,
-               sizeof(first_fat), (char *)&amp;first_fat))
-    return 0;
-
-  if (FAT_SUPER-&gt;fat_size == 8)
-    {
-      first_fat &amp;= 0x0fffffff;
-      magic = 0x0fffff00;
-    }
-  else if (FAT_SUPER-&gt;fat_size == 4)
-    {
-      first_fat &amp;= 0x0000ffff;
-      magic = 0xff00;
-    }
-  else
-    {
-      first_fat &amp;= 0x00000fff;
-      magic = 0x0f00;
-    }
-
-  /* Ignore the 3rd bit, because some BIOSes assigns 0xF0 to the media
-     descriptor, even if it is a so-called superfloppy (e.g. an USB key).
-     The check may be too strict for this kind of stupid BIOSes, as
-     they overwrite the media descriptor.  */
-  if ((first_fat | 0x8) != (magic | bpb.media | 0x8))
-    return 0;
-
-  FAT_SUPER-&gt;cached_fat = - 2 * FAT_CACHE_SIZE;
-  return 1;
-}
-
-int
-fat_read (char *buf, int len)
-{
-  int logical_clust;
-  int offset;
-  int ret = 0;
-  int size;
-  
-  if (FAT_SUPER-&gt;file_cluster &lt; 0)
-    {
-      /* root directory for fat16 */
-      size = FAT_SUPER-&gt;root_max - filepos;
-      if (size &gt; len)
- 	size = len;
-      if (!devread(FAT_SUPER-&gt;root_offset, filepos, size, buf))
- 	return 0;
-      filepos += size;
-      return size;
-    }
-  
-  logical_clust = filepos &gt;&gt; FAT_SUPER-&gt;clustsize_bits;
-  offset = (filepos &amp; ((1 &lt;&lt; FAT_SUPER-&gt;clustsize_bits) - 1));
-  if (logical_clust &lt; FAT_SUPER-&gt;current_cluster_num)
-    {
-      FAT_SUPER-&gt;current_cluster_num = 0;
-      FAT_SUPER-&gt;current_cluster = FAT_SUPER-&gt;file_cluster;
-    }
-  
-  while (len &gt; 0)
-    {
-      int sector;
-      while (logical_clust &gt; FAT_SUPER-&gt;current_cluster_num)
-	{
-	  /* calculate next cluster */
-	  int fat_entry = 
-	    FAT_SUPER-&gt;current_cluster * FAT_SUPER-&gt;fat_size;
-	  int next_cluster;
-	  int cached_pos = (fat_entry - FAT_SUPER-&gt;cached_fat);
-	  
-	  if (cached_pos &lt; 0 || 
-	      (cached_pos + FAT_SUPER-&gt;fat_size) &gt; 2*FAT_CACHE_SIZE)
-	    {
-	      FAT_SUPER-&gt;cached_fat = (fat_entry &amp; ~(2*SECTOR_SIZE - 1));
-	      cached_pos = (fat_entry - FAT_SUPER-&gt;cached_fat);
-	      sector = FAT_SUPER-&gt;fat_offset
-		+ FAT_SUPER-&gt;cached_fat / (2*SECTOR_SIZE);
-	      if (!devread (sector, 0, FAT_CACHE_SIZE, (char*) FAT_BUF))
-		return 0;
-	    }
-	  next_cluster = * (unsigned long *) (FAT_BUF + (cached_pos &gt;&gt; 1));
-	  if (FAT_SUPER-&gt;fat_size == 3)
-	    {
-	      if (cached_pos &amp; 1)
-		next_cluster &gt;&gt;= 4;
-	      next_cluster &amp;= 0xFFF;
-	    }
-	  else if (FAT_SUPER-&gt;fat_size == 4)
-	    next_cluster &amp;= 0xFFFF;
-	  
-	  if (next_cluster &gt;= FAT_SUPER-&gt;clust_eof_marker)
-	    return ret;
-	  if (next_cluster &lt; 2 || next_cluster &gt;= FAT_SUPER-&gt;num_clust)
-	    {
-	      errnum = ERR_FSYS_CORRUPT;
-	      return 0;
-	    }
-	  
-	  FAT_SUPER-&gt;current_cluster = next_cluster;
-	  FAT_SUPER-&gt;current_cluster_num++;
-	}
-      
-      sector = FAT_SUPER-&gt;data_offset +
-	((FAT_SUPER-&gt;current_cluster - 2) &lt;&lt; (FAT_SUPER-&gt;clustsize_bits
- 					      - FAT_SUPER-&gt;sectsize_bits));
-      size = (1 &lt;&lt; FAT_SUPER-&gt;clustsize_bits) - offset;
-      if (size &gt; len)
-	size = len;
-      
-      disk_read_func = disk_read_hook;
-      
-      devread(sector, offset, size, buf);
-      
-      disk_read_func = NULL;
-      
-      len -= size;
-      buf += size;
-      ret += size;
-      filepos += size;
-      logical_clust++;
-      offset = 0;
-    }
-  return errnum ? 0 : ret;
-}
-
-int
-fat_dir (char *dirname)
-{
-  char *rest, ch, dir_buf[FAT_DIRENTRY_LENGTH];
-  char *filename = (char *) NAME_BUF;
-  int attrib = FAT_ATTRIB_DIR;
-#ifndef STAGE1_5
-  int do_possibilities = 0;
-#endif
-  
-  /* XXX I18N:
-   * the positions 2,4,6 etc are high bytes of a 16 bit unicode char 
-   */
-  static unsigned char longdir_pos[] = 
-  { 1, 3, 5, 7, 9, 14, 16, 18, 20, 22, 24, 28, 30 };
-  int slot = -2;
-  int alias_checksum = -1;
-  
-  FAT_SUPER-&gt;file_cluster = FAT_SUPER-&gt;root_cluster;
-  filepos = 0;
-  FAT_SUPER-&gt;current_cluster_num = MAXINT;
-  
-  /* main loop to find desired directory entry */
- loop:
-  
-  /* if we have a real file (and we're not just printing possibilities),
-     then this is where we want to exit */
-  
-  if (!*dirname || isspace (*dirname))
-    {
-      if (attrib &amp; FAT_ATTRIB_DIR)
-	{
-	  errnum = ERR_BAD_FILETYPE;
-	  return 0;
-	}
-      
-      return 1;
-    }
-  
-  /* continue with the file/directory name interpretation */
-  
-  while (*dirname == '/')
-    dirname++;
-  
-  if (!(attrib &amp; FAT_ATTRIB_DIR))
-    {
-      errnum = ERR_BAD_FILETYPE;
-      return 0;
-    }
-  /* Directories don't have a file size */
-  filemax = MAXINT;
-  
-  for (rest = dirname; (ch = *rest) &amp;&amp; !isspace (ch) &amp;&amp; ch != '/'; rest++);
-  
-  *rest = 0;
-  
-# ifndef STAGE1_5
-  if (print_possibilities &amp;&amp; ch != '/')
-    do_possibilities = 1;
-# endif
-  
-  while (1)
-    {
-      if (fat_read (dir_buf, FAT_DIRENTRY_LENGTH) != FAT_DIRENTRY_LENGTH
-	  || dir_buf[0] == 0)
-	{
-	  if (!errnum)
-	    {
-# ifndef STAGE1_5
-	      if (print_possibilities &lt; 0)
-		{
-#if 0
-		  putchar ('\n');
-#endif
-		  return 1;
-		}
-# endif /* STAGE1_5 */
-	      
-	      errnum = ERR_FILE_NOT_FOUND;
-	      *rest = ch;
-	    }
-	  
-	  return 0;
-	}
-      
-      if (FAT_DIRENTRY_ATTRIB (dir_buf) == FAT_ATTRIB_LONGNAME)
-	{
-	  /* This is a long filename.  The filename is build from back
-	   * to front and may span multiple entries.  To bind these
-	   * entries together they all contain the same checksum over
-	   * the short alias.
-	   *
-	   * The id field tells if this is the first entry (the last
-	   * part) of the long filename, and also at which offset this
-	   * belongs.
-	   *
-	   * We just write the part of the long filename this entry
-	   * describes and continue with the next dir entry.
-	   */
-	  int i, offset;
-	  unsigned char id = FAT_LONGDIR_ID(dir_buf);
-	  
-	  if ((id &amp; 0x40)) 
-	    {
-	      id &amp;= 0x3f;
-	      slot = id;
-	      filename[slot * 13] = 0;
-	      alias_checksum = FAT_LONGDIR_ALIASCHECKSUM(dir_buf);
-	    } 
-	  
-	  if (id != slot || slot == 0
-	      || alias_checksum != FAT_LONGDIR_ALIASCHECKSUM(dir_buf))
-	    {
-	      alias_checksum = -1;
-	      continue;
-	    }
-	  
-	  slot--;
-	  offset = slot * 13;
-	  
-	  for (i=0; i &lt; 13; i++)
-	    filename[offset+i] = dir_buf[longdir_pos[i]];
-	  continue;
-	}
-      
-      if (!FAT_DIRENTRY_VALID (dir_buf))
-	continue;
-      
-      if (alias_checksum != -1 &amp;&amp; slot == 0)
-	{
-	  int i;
-	  unsigned char sum;
-	  
-	  slot = -2;
-	  for (sum = 0, i = 0; i&lt; 11; i++)
-	    sum = ((sum &gt;&gt; 1) | (sum &lt;&lt; 7)) + dir_buf[i];
-	  
-	  if (sum == alias_checksum)
-	    {
-# ifndef STAGE1_5
-	      if (do_possibilities)
-		goto print_filename;
-# endif /* STAGE1_5 */
-	      
-	      if (substring (dirname, filename) == 0)
-		break;
-	    }
-	}
-      
-      /* XXX convert to 8.3 filename format here */
-      {
-	int i, j, c;
-	
-	for (i = 0; i &lt; 8 &amp;&amp; (c = filename[i] = tolower (dir_buf[i]))
-	       &amp;&amp; !isspace (c); i++);
-	
-	filename[i++] = '.';
-	
-	for (j = 0; j &lt; 3 &amp;&amp; (c = filename[i + j] = tolower (dir_buf[8 + j]))
-	       &amp;&amp; !isspace (c); j++);
-	
-	if (j == 0)
-	  i--;
-	
-	filename[i + j] = 0;
-      }
-      
-# ifndef STAGE1_5
-      if (do_possibilities)
-	{
-	print_filename:
-	  if (substring (dirname, filename) &lt;= 0)
-	    {
-	      if (print_possibilities &gt; 0)
-		print_possibilities = -print_possibilities;
-	      print_a_completion (filename);
-	    }
-	  continue;
-	}
-# endif /* STAGE1_5 */
-      
-      if (substring (dirname, filename) == 0)
-	break;
-    }
-  
-  *(dirname = rest) = ch;
-  
-  attrib = FAT_DIRENTRY_ATTRIB (dir_buf);
-  filemax = FAT_DIRENTRY_FILELENGTH (dir_buf);
-  filepos = 0;
-  FAT_SUPER-&gt;file_cluster = FAT_DIRENTRY_FIRST_CLUSTER (dir_buf);
-  FAT_SUPER-&gt;current_cluster_num = MAXINT;
-  
-  /* go back to main loop at top of function */
-  goto loop;
-}
-
-#endif /* FSYS_FAT */

Deleted: castillonroy/dev_grub/stage2/rootnoverify_different_drive_error_fix.diff
===================================================================
--- castillonroy/dev_grub/stage2/rootnoverify_different_drive_error_fix.diff	2009-06-01 19:30:15 UTC (rev 3)
+++ castillonroy/dev_grub/stage2/rootnoverify_different_drive_error_fix.diff	2009-06-02 17:21:33 UTC (rev 4)
@@ -1,10 +0,0 @@
---- sgd_source_code_0.9586/dev_grub/stage2/builtins.c	2007-03-11 21:45:54.000000000 +0100
-+++ sgd_source_code_0.9588/dev_grub/stage2/builtins.c	2007-03-17 23:58:11.000000000 +0100
-@@ -3520,6 +3520,7 @@
- 	 must be set appropriately.  */
-       if (open_partition ())
- 	{
-+	  saved_drive = current_drive; // Let's update saved_drive with value from open_partition - adrian15
- 	  set_bootdev (0);
- 	  if (errnum)
- 	    return 1;

Deleted: castillonroy/dev_grub/stage2/shared.h.orig
===================================================================
--- castillonroy/dev_grub/stage2/shared.h.orig	2009-06-01 19:30:15 UTC (rev 3)
+++ castillonroy/dev_grub/stage2/shared.h.orig	2009-06-02 17:21:33 UTC (rev 4)
@@ -1,1140 +0,0 @@
-/* shared.h - definitions used in all GRUB-specific code */
-/*
- *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 1999,2000,2001,2002,2003,2004  Free Software Foundation, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-/*
- *  Generic defines to use anywhere
- */
-
-#ifndef GRUB_SHARED_HEADER
-#define GRUB_SHARED_HEADER	1
-
-#include &lt;config.h&gt;
-
-/* Add an underscore to a C symbol in assembler code if needed. */
-#ifdef HAVE_ASM_USCORE
-# define EXT_C(sym) _ ## sym
-#else
-# define EXT_C(sym) sym
-#endif
-
-/* Maybe redirect memory requests through grub_scratch_mem. */
-#ifdef GRUB_UTIL
-extern char *grub_scratch_mem;
-# define RAW_ADDR(x) ((x) + (int) grub_scratch_mem)
-# define RAW_SEG(x) (RAW_ADDR ((x) &lt;&lt; 4) &gt;&gt; 4)
-#else
-# define RAW_ADDR(x) (x)
-# define RAW_SEG(x) (x)
-#endif
-
-/*
- *  Integer sizes
- */
-
-#define MAXINT     0x7FFFFFFF
-
-/* Maximum command line size. Before you blindly increase this value,
-   see the comment in char_io.c (get_cmdline).  */
-#define MAX_CMDLINE 1600
-#define NEW_HEAPSIZE 1500
-
-/* 512-byte scratch area */
-#define SCRATCHADDR  RAW_ADDR (0x77e00)
-#define SCRATCHSEG   RAW_SEG (0x77e0)
-
-/*
- *  This is the location of the raw device buffer.  It is 31.5K
- *  in size.
- */
-
-#define BUFFERLEN   0x7e00
-#define BUFFERADDR  RAW_ADDR (0x70000)
-#define BUFFERSEG   RAW_SEG (0x7000)
-
-#define BOOT_PART_TABLE	RAW_ADDR (0x07be)
-
-/*
- *  BIOS disk defines
- */
-#define BIOSDISK_READ			0x0
-#define BIOSDISK_WRITE			0x1
-#define BIOSDISK_ERROR_GEOMETRY		0x100
-#define BIOSDISK_ERROR_SHORT_IO		0x101
-#define BIOSDISK_FLAG_LBA_EXTENSION	0x1
-#define BIOSDISK_FLAG_CDROM		0x2
-
-/*
- *  This is the filesystem (not raw device) buffer.
- *  It is 32K in size, do not overrun!
- */
-
-#define FSYS_BUFLEN  0x8000
-#define FSYS_BUF RAW_ADDR (0x68000)
-
-/* Command-line buffer for Multiboot kernels and modules. This area
-   includes the area into which Stage 1.5 and Stage 1 are loaded, but
-   that's no problem.  */
-#define MB_CMDLINE_BUF		RAW_ADDR (0x2000)
-#define MB_CMDLINE_BUFLEN	0x6000
-
-/* The buffer for the password.  */
-#define PASSWORD_BUF		RAW_ADDR (0x78000)
-#define PASSWORD_BUFLEN		0x200
-
-/* THe buffer for the filename of &quot;/boot/grub/default&quot;.  */
-#define DEFAULT_FILE_BUF	(PASSWORD_BUF + PASSWORD_BUFLEN)
-#define DEFAULT_FILE_BUFLEN	0x60
-
-/* The buffer for the command-line.  */
-#define CMDLINE_BUF		(DEFAULT_FILE_BUF + DEFAULT_FILE_BUFLEN)
-#define CMDLINE_BUFLEN		MAX_CMDLINE
-
-/* The kill buffer for the command-line.  */
-#define KILL_BUF		(CMDLINE_BUF + CMDLINE_BUFLEN)
-#define KILL_BUFLEN		MAX_CMDLINE
-
-/* The history buffer for the command-line.  */
-#define HISTORY_BUF		(KILL_BUF + KILL_BUFLEN)
-#define HISTORY_SIZE		5
-#define HISTORY_BUFLEN		(MAX_CMDLINE * HISTORY_SIZE)
-
-/* The buffer for the completion.  */
-#define COMPLETION_BUF		(HISTORY_BUF + HISTORY_BUFLEN)
-#define COMPLETION_BUFLEN	MAX_CMDLINE
-
-/* The buffer for the unique string.  */
-#define UNIQUE_BUF		(COMPLETION_BUF + COMPLETION_BUFLEN)
-#define UNIQUE_BUFLEN		MAX_CMDLINE
-
-/* The buffer for the menu entries.  */
-#define MENU_BUF		(UNIQUE_BUF + UNIQUE_BUFLEN)
-#define MENU_BUFLEN		(0x8000 + PASSWORD_BUF - MENU_BUF)
-
-/* The size of the drive map.  */
-#define DRIVE_MAP_SIZE		16
-
-/* The size of the key map.  */
-#define KEY_MAP_SIZE		128
-
-/* The size of the io map.  */
-#define IO_MAP_SIZE		128
-
-
-
-#define MENU_LEVELS_MAXIMUM	4
-
-
-
-/*
- *  Linux setup parameters
- */
-
-#define LINUX_MAGIC_SIGNATURE		0x53726448	/* &quot;HdrS&quot; */
-#define LINUX_DEFAULT_SETUP_SECTS	4
-#define LINUX_FLAG_CAN_USE_HEAP		0x80
-#define LINUX_INITRD_MAX_ADDRESS	0x38000000
-#define LINUX_MAX_SETUP_SECTS		64
-#define LINUX_BOOT_LOADER_TYPE		0x71
-#define LINUX_HEAP_END_OFFSET		(0x9000 - 0x200)
-
-#define LINUX_BZIMAGE_ADDR		RAW_ADDR (0x100000)
-#define LINUX_ZIMAGE_ADDR		RAW_ADDR (0x10000)
-#define LINUX_OLD_REAL_MODE_ADDR	RAW_ADDR (0x90000)
-#define LINUX_SETUP_STACK		0x9000
-
-#define LINUX_FLAG_BIG_KERNEL		0x1
-
-/* Linux's video mode selection support. Actually I hate it!  */
-#define LINUX_VID_MODE_NORMAL		0xFFFF
-#define LINUX_VID_MODE_EXTENDED		0xFFFE
-#define LINUX_VID_MODE_ASK		0xFFFD
-
-#define LINUX_CL_OFFSET			0x9000
-#define LINUX_CL_END_OFFSET		0x90FF
-#define LINUX_SETUP_MOVE_SIZE		0x9100
-#define LINUX_CL_MAGIC			0xA33F
-
-/*
- *  General disk stuff
- */
-
-#define SECTOR_SIZE		0x200
-#define SECTOR_BITS		9
-#define BIOS_FLAG_FIXED_DISK	0x80
-
-#define BOOTSEC_LOCATION		RAW_ADDR (0x7C00)
-#define BOOTSEC_SIGNATURE		0xAA55
-#define BOOTSEC_BPB_OFFSET		0x3
-#define BOOTSEC_BPB_LENGTH		0x3B
-#define BOOTSEC_BPB_SYSTEM_ID		0x3
-#define BOOTSEC_BPB_HIDDEN_SECTORS	0x1C
-#define BOOTSEC_PART_OFFSET		0x1BE
-#define BOOTSEC_PART_LENGTH		0x40
-#define BOOTSEC_SIG_OFFSET		0x1FE
-#define BOOTSEC_LISTSIZE		8
-
-/* Not bad, perhaps.  */
-#define NETWORK_DRIVE	0x20
-
-/*
- *  GRUB specific information
- *    (in LSB order)
- */
-
-#include &lt;stage1.h&gt;
-
-#define STAGE2_VER_MAJ_OFFS	0x6
-#define STAGE2_INSTALLPART	0x8
-#define STAGE2_SAVED_ENTRYNO	0xc
-#define STAGE2_STAGE2_ID	0x10
-#define STAGE2_FORCE_LBA	0x11
-#define STAGE2_VER_STR_OFFS	0x12
-
-/* Stage 2 identifiers */
-#define STAGE2_ID_STAGE2		0
-#define STAGE2_ID_FFS_STAGE1_5		1
-#define STAGE2_ID_E2FS_STAGE1_5		2
-#define STAGE2_ID_FAT_STAGE1_5		3
-#define STAGE2_ID_MINIX_STAGE1_5	4
-#define STAGE2_ID_REISERFS_STAGE1_5	5
-#define STAGE2_ID_VSTAFS_STAGE1_5	6
-#define STAGE2_ID_JFS_STAGE1_5		7
-#define STAGE2_ID_XFS_STAGE1_5		8
-#define STAGE2_ID_ISO9660_STAGE1_5	9
-#define STAGE2_ID_UFS2_STAGE1_5		10
-#define STAGE2_ID_UFS_STAGE1_5		11
-
-#ifndef STAGE1_5
-# define STAGE2_ID	STAGE2_ID_STAGE2
-#else
-# if defined(FSYS_FFS)
-#  define STAGE2_ID	STAGE2_ID_FFS_STAGE1_5
-# elif defined(FSYS_EXT2FS)
-#  define STAGE2_ID	STAGE2_ID_E2FS_STAGE1_5
-# elif defined(FSYS_FAT)
-#  define STAGE2_ID	STAGE2_ID_FAT_STAGE1_5
-# elif defined(FSYS_MINIX)
-#  define STAGE2_ID	STAGE2_ID_MINIX_STAGE1_5
-# elif defined(FSYS_REISERFS)
-#  define STAGE2_ID	STAGE2_ID_REISERFS_STAGE1_5
-# elif defined(FSYS_VSTAFS)
-#  define STAGE2_ID	STAGE2_ID_VSTAFS_STAGE1_5
-# elif defined(FSYS_JFS)
-#  define STAGE2_ID	STAGE2_ID_JFS_STAGE1_5
-# elif defined(FSYS_XFS)
-#  define STAGE2_ID	STAGE2_ID_XFS_STAGE1_5
-# elif defined(FSYS_ISO9660)
-#  define STAGE2_ID	STAGE2_ID_ISO9660_STAGE1_5
-# elif defined(FSYS_UFS2)
-#  define STAGE2_ID	STAGE2_ID_UFS2_STAGE1_5
-# elif defined(FSYS_UFS)
-#  define STAGE2_ID	STAGE2_ID_UFS_STAGE1_5
-# else
-#  error &quot;unknown Stage 2&quot;
-# endif
-#endif
-
-/*
- *  defines for use when switching between real and protected mode
- */
-
-#define CR0_PE_ON	0x1
-#define CR0_PE_OFF	0xfffffffe
-#define PROT_MODE_CSEG	0x8
-#define PROT_MODE_DSEG  0x10
-#define PSEUDO_RM_CSEG	0x18
-#define PSEUDO_RM_DSEG	0x20
-#define STACKOFF	(0x2000 - 0x10)
-#define PROTSTACKINIT   (FSYS_BUF - 0x10)
-
-
-/*
- * Assembly code defines
- *
- * &quot;EXT_C&quot; is assumed to be defined in the Makefile by the configure
- *   command.
- */
-
-#define ENTRY(x) .globl EXT_C(x) ; EXT_C(x):
-#define VARIABLE(x) ENTRY(x)
-
-
-#define K_RDWR  	0x60	/* keyboard data &amp; cmds (read/write) */
-#define K_STATUS	0x64	/* keyboard status */
-#define K_CMD		0x64	/* keybd ctlr command (write-only) */
-
-#define K_OBUF_FUL 	0x01	/* output buffer full */
-#define K_IBUF_FUL 	0x02	/* input buffer full */
-
-#define KC_CMD_WIN	0xd0	/* read  output port */
-#define KC_CMD_WOUT	0xd1	/* write output port */
-#define KB_OUTPUT_MASK  0xdd	/* enable output buffer full interrupt
-				   enable data line
-				   enable clock line */
-#define KB_A20_ENABLE   0x02
-
-/* Codes for getchar. */
-#define ASCII_CHAR(x)   ((x) &amp; 0xFF)
-#if !defined(GRUB_UTIL) || !defined(HAVE_LIBCURSES)
-# define KEY_LEFT        0x4B00
-# define KEY_RIGHT       0x4D00
-# define KEY_UP          0x4800
-# define KEY_DOWN        0x5000
-# define KEY_IC          0x5200	/* insert char */
-# define KEY_DC          0x5300	/* delete char */
-# define KEY_BACKSPACE   0x0008
-# define KEY_HOME        0x4700
-# define KEY_END         0x4F00
-# define KEY_NPAGE       0x5100
-# define KEY_PPAGE       0x4900
-# define A_NORMAL        0x7
-# define A_REVERSE       0x70
-#elif defined(HAVE_NCURSES_CURSES_H)
-# include &lt;ncurses/curses.h&gt;
-#elif defined(HAVE_NCURSES_H)
-# include &lt;ncurses.h&gt;
-#elif defined(HAVE_CURSES_H)
-# include &lt;curses.h&gt;
-#endif
-
-/* In old BSD curses, A_NORMAL and A_REVERSE are not defined, so we
-   define them here if they are undefined.  */
-#ifndef A_NORMAL
-# define A_NORMAL	0
-#endif /* ! A_NORMAL */
-#ifndef A_REVERSE
-# ifdef A_STANDOUT
-#  define A_REVERSE	A_STANDOUT
-# else /* ! A_STANDOUT */
-#  define A_REVERSE	0
-# endif /* ! A_STANDOUT */
-#endif /* ! A_REVERSE */
-
-/* Define ACS_* ourselves, since the definitions are not consistent among
-   various curses implementations.  */
-#undef ACS_ULCORNER
-#undef ACS_URCORNER
-#undef ACS_LLCORNER
-#undef ACS_LRCORNER
-#undef ACS_HLINE
-#undef ACS_VLINE
-#undef ACS_LARROW
-#undef ACS_RARROW
-#undef ACS_UARROW
-#undef ACS_DARROW
-
-#define ACS_ULCORNER	'+'
-#define ACS_URCORNER	'+'
-#define ACS_LLCORNER	'+'
-#define ACS_LRCORNER	'+'
-#define ACS_HLINE	'-'
-#define ACS_VLINE	'|'
-#define ACS_LARROW	'&lt;'
-#define ACS_RARROW	'&gt;'
-#define ACS_UARROW	'^'
-#define ACS_DARROW	'v'
-
-/* Special graphics characters for IBM displays. */
-#define DISP_UL		218
-#define DISP_UR		191
-#define DISP_LL		192
-#define DISP_LR		217
-#define DISP_HORIZ	196
-#define DISP_VERT	179
-#define DISP_LEFT	0x1b
-#define DISP_RIGHT	0x1a
-#define DISP_UP		0x18
-#define DISP_DOWN	0x19
-
-/* Remap some libc-API-compatible function names so that we prevent
-   circularararity. */
-#ifndef WITHOUT_LIBC_STUBS
-#define memmove grub_memmove
-#define memcpy grub_memmove	/* we don't need a separate memcpy */
-#define memset grub_memset
-#undef isspace
-#define isspace grub_isspace
-#define printf grub_printf
-#define sprintf grub_sprintf
-#undef putchar
-#define putchar grub_putchar
-#define strncat grub_strncat
-#define strstr grub_strstr
-#define memcmp grub_memcmp
-#define strcmp grub_strcmp
-#define tolower grub_tolower
-#define strlen grub_strlen
-#define strcpy grub_strcpy
-#endif /* WITHOUT_LIBC_STUBS */
-
-
-/* see typedef gfx_data_t below */
-#define gfx_ofs_ok			0x00
-#define gfx_ofs_code_seg		0x04
-#define gfx_ofs_jmp_table		0x08
-#define gfx_ofs_sys_cfg			0x38
-#define gfx_ofs_cmdline			0x6c
-#define gfx_ofs_cmdline_len		0x70
-#define gfx_ofs_menu_list		0x74
-#define gfx_ofs_menu_default_entry	0x78
-#define gfx_ofs_menu_entries		0x7c
-#define gfx_ofs_menu_entry_len		0x80
-#define gfx_ofs_args_list		0x84
-#define gfx_ofs_args_entry_len		0x88
-#define gfx_ofs_timeout			0x8c
-
-
-#ifndef ASM_FILE
-/*
- *  Below this should be ONLY defines and other constructs for C code.
- */
-
-/* multiboot stuff */
-
-#include &quot;mb_header.h&quot;
-#include &quot;mb_info.h&quot;
-
-/* For the Linux/i386 boot protocol version 2.03.  */
-struct linux_kernel_header
-{
-  char code1[0x0020];
-  unsigned short cl_magic;		/* Magic number 0xA33F */
-  unsigned short cl_offset;		/* The offset of command line */
-  char code2[0x01F1 - 0x0020 - 2 - 2];
-  unsigned char setup_sects;		/* The size of the setup in sectors */
-  unsigned short root_flags;		/* If the root is mounted readonly */
-  unsigned short syssize;		/* obsolete */
-  unsigned short swap_dev;		/* obsolete */
-  unsigned short ram_size;		/* obsolete */
-  unsigned short vid_mode;		/* Video mode control */
-  unsigned short root_dev;		/* Default root device number */
-  unsigned short boot_flag;		/* 0xAA55 magic number */
-  unsigned short jump;			/* Jump instruction */
-  unsigned long header;			/* Magic signature &quot;HdrS&quot; */
-  unsigned short version;		/* Boot protocol version supported */
-  unsigned long realmode_swtch;		/* Boot loader hook */
-  unsigned long start_sys;		/* Points to kernel version string */
-  unsigned char type_of_loader;		/* Boot loader identifier */
-  unsigned char loadflags;		/* Boot protocol option flags */
-  unsigned short setup_move_size;	/* Move to high memory size */
-  unsigned long code32_start;		/* Boot loader hook */
-  unsigned long ramdisk_image;		/* initrd load address */
-  unsigned long ramdisk_size;		/* initrd size */
-  unsigned long bootsect_kludge;	/* obsolete */
-  unsigned short heap_end_ptr;		/* Free memory after setup end */
-  unsigned short pad1;			/* Unused */
-  char *cmd_line_ptr;			/* Points to the kernel command line */
-  unsigned long initrd_addr_max;	/* The highest address of initrd */
-} __attribute__ ((packed));
-
-/* Memory map address range descriptor used by GET_MMAP_ENTRY. */
-struct mmar_desc
-{
-  unsigned long desc_len;	/* Size of this descriptor. */
-  unsigned long long addr;	/* Base address. */
-  unsigned long long length;	/* Length in bytes. */
-  unsigned long type;		/* Type of address range. */
-} __attribute__ ((packed));
-
-/* VBE controller information.  */
-struct vbe_controller
-{
-  unsigned char signature[4];
-  unsigned short version;
-  unsigned long oem_string;
-  unsigned long capabilities;
-  unsigned long video_mode;
-  unsigned short total_memory;
-  unsigned short oem_software_rev;
-  unsigned long oem_vendor_name;
-  unsigned long oem_product_name;
-  unsigned long oem_product_rev;
-  unsigned char reserved[222];
-  unsigned char oem_data[256];
-} __attribute__ ((packed));
-
-/* VBE mode information.  */
-struct vbe_mode
-{
-  unsigned short mode_attributes;
-  unsigned char win_a_attributes;
-  unsigned char win_b_attributes;
-  unsigned short win_granularity;
-  unsigned short win_size;
-  unsigned short win_a_segment;
-  unsigned short win_b_segment;
-  unsigned long win_func;
-  unsigned short bytes_per_scanline;
-
-  /* &gt;=1.2 */
-  unsigned short x_resolution;
-  unsigned short y_resolution;
-  unsigned char x_char_size;
-  unsigned char y_char_size;
-  unsigned char number_of_planes;
-  unsigned char bits_per_pixel;
-  unsigned char number_of_banks;
-  unsigned char memory_model;
-  unsigned char bank_size;
-  unsigned char number_of_image_pages;
-  unsigned char reserved0;
-
-  /* direct color */
-  unsigned char red_mask_size;
-  unsigned char red_field_position;
-  unsigned char green_mask_size;
-  unsigned char green_field_position;
-  unsigned char blue_mask_size;
-  unsigned char blue_field_position;
-  unsigned char reserved_mask_size;
-  unsigned char reserved_field_position;
-  unsigned char direct_color_mode_info;
-
-  /* &gt;=2.0 */
-  unsigned long phys_base;
-  unsigned long reserved1;
-  unsigned short reversed2;
-
-  /* &gt;=3.0 */
-  unsigned short linear_bytes_per_scanline;
-  unsigned char banked_number_of_image_pages;
-  unsigned char linear_number_of_image_pages;
-  unsigned char linear_red_mask_size;
-  unsigned char linear_red_field_position;
-  unsigned char linear_green_mask_size;
-  unsigned char linear_green_field_position;
-  unsigned char linear_blue_mask_size;
-  unsigned char linear_blue_field_position;
-  unsigned char linear_reserved_mask_size;
-  unsigned char linear_reserved_field_position;
-  unsigned long max_pixel_clock;
-
-  unsigned char reserved3[189];
-} __attribute__ ((packed));
-
-
-#undef NULL
-#define NULL         ((void *) 0)
-
-/* Error codes (descriptions are in common.c) */
-typedef enum
-{
-  ERR_NONE = 0,
-  ERR_BAD_FILENAME,
-  ERR_BAD_FILETYPE,
-  ERR_BAD_GZIP_DATA,
-  ERR_BAD_GZIP_HEADER,
-  ERR_BAD_PART_TABLE,
-  ERR_BAD_VERSION,
-  ERR_BELOW_1MB,
-  ERR_BOOT_COMMAND,
-  ERR_BOOT_FAILURE,
-  ERR_BOOT_FEATURES,
-  ERR_DEV_FORMAT,
-  ERR_DEV_VALUES,
-  ERR_EXEC_FORMAT,
-  ERR_FILELENGTH,
-  ERR_FILE_NOT_FOUND,
-  ERR_FSYS_CORRUPT,
-  ERR_FSYS_MOUNT,
-  ERR_GEOM,
-  ERR_NEED_LX_KERNEL,
-  ERR_NEED_MB_KERNEL,
-  ERR_NO_DISK,
-  ERR_NO_PART,
-  ERR_NUMBER_PARSING,
-  ERR_OUTSIDE_PART,
-  ERR_READ,
-  ERR_SYMLINK_LOOP,
-  ERR_UNRECOGNIZED,
-  ERR_WONT_FIT,
-  ERR_WRITE,
-  ERR_BAD_ARGUMENT,
-  ERR_UNALIGNED,
-  ERR_PRIVILEGED,
-  ERR_DEV_NEED_INIT,
-  ERR_NO_DISK_SPACE,
-  ERR_NUMBER_OVERFLOW,
-  ERR_BADMODADDR,
-
-  MAX_ERR_NUM
-} grub_error_t;
-
-extern unsigned long install_partition;
-extern unsigned long boot_drive;
-extern unsigned long install_second_sector;
-extern struct apm_info apm_bios_info;
-extern unsigned long boot_part_addr;
-extern int saved_entryno;
-extern unsigned char force_lba;
-extern char version_string[];
-extern char config_file[];
-extern unsigned long linux_text_len;
-extern char *linux_data_tmp_addr;
-extern char *linux_data_real_addr;
-
-#ifdef GRUB_UTIL
-/* If not using config file, this variable is set to zero,
-   otherwise non-zero.  */
-extern int use_config_file;
-/* If using the preset menu, this variable is set to non-zero,
-   otherwise zero.  */
-extern int use_preset_menu;
-/* If not using curses, this variable is set to zero, otherwise non-zero.  */
-extern int use_curses;
-/* The flag for verbose messages.  */
-extern int verbose;
-/* The flag for read-only.  */
-extern int read_only;
-/* The number of floppies to be probed.  */
-extern int floppy_disks;
-/* The map between BIOS drives and UNIX device file names.  */
-extern char **device_map;
-/* The filename which stores the information about a device map.  */
-extern char *device_map_file;
-/* The array of geometries.  */
-extern struct geometry *disks;
-/* Assign DRIVE to a device name DEVICE.  */
-extern void assign_device_name (int drive, const char *device);
-#endif
-
-#ifndef STAGE1_5
-/* GUI interface variables. */
-# define MAX_FALLBACK_ENTRIES	250
-extern int fallback_entries[MAX_FALLBACK_ENTRIES];
-extern int fallback_entryno;
-extern int default_entry;
-extern int current_entryno;
-
-// FOR THE FIX OF THE ERROR 25 - adrian15
-extern unsigned long cur_part_offset;
-
-/*
- * graphics menu stuff
- *
- * Note: gfx_data and all data referred to in it must lie within a 64k area.
- */
-typedef struct {
-  unsigned ok;			/* set while we're in graphics mode */
-  unsigned code_seg;		/* code segment of binary graphics code */
-  unsigned jmp_table[12];	/* link to graphics functions */
-  unsigned char sys_cfg[52];	/* sys_cfg[0]: identifies boot loader (grub == 2) */
-  char *cmdline;		/* command line returned by gfx_input() */
-  unsigned cmdline_len;		/* length of the above */
-  char *menu_list;		/* list of menu entries, each of fixed length (menu_entry_len) */
-  char *menu_default_entry;	/* the default entry */
-  unsigned menu_entries;	/* number of entries in menu_list */
-  unsigned menu_entry_len;	/* one entry */
-  char *args_list;		/* same structure as menu_list, menu_entries entries */
-  unsigned args_entry_len;	/* one entry */
-  unsigned timeout;		/* in seconds (0: no timeout) */
-} __attribute__ ((packed)) gfx_data_t;
-
-extern gfx_data_t *graphics_data;
-
-/* pointer to graphics image data */
-extern char graphics_file[64];
-
-int gfx_init(gfx_data_t *gfx_data);
-int gfx_done(gfx_data_t *gfx_data);
-int gfx_input(gfx_data_t *gfx_data, int *menu_entry);
-int gfx_setup_menu(gfx_data_t *gfx_data);
-
-/* The constants for password types.  */
-typedef enum
-{
-  PASSWORD_PLAIN,
-  PASSWORD_MD5,
-  PASSWORD_UNSUPPORTED
-}
-password_t;
-
-extern char *password;
-extern password_t password_type;
-extern int auth;
-extern char commands[];
-
-/* For `more'-like feature.  */
-extern int max_lines;
-extern int count_lines;
-extern int use_pager;
-extern int cat_is_on;
-#endif
-
-#ifndef NO_DECOMPRESSION
-extern int no_decompression;
-extern int compressed_file;
-#endif
-
-/* instrumentation variables */
-extern void (*disk_read_hook) (int, int, int);
-extern void (*disk_read_func) (int, int, int);
-
-#ifndef STAGE1_5
-/* The flag for debug mode.  */
-extern int debug;
-#endif /* STAGE1_5 */
-
-extern unsigned long current_drive;
-extern unsigned long current_partition;
-
-extern int fsys_type;
-
-/* The information for a disk geometry. The CHS information is only for
-   DOS/Partition table compatibility, and the real number of sectors is
-   stored in TOTAL_SECTORS.  */
-struct geometry
-{
-  /* The number of cylinders */
-  unsigned long cylinders;
-  /* The number of heads */
-  unsigned long heads;
-  /* The number of sectors */
-  unsigned long sectors;
-  /* The total number of sectors */
-  unsigned long total_sectors;
-  /* Device sector size */
-  unsigned long sector_size;
-  /* Flags */
-  unsigned long flags;
-};
-
-extern unsigned long part_start;
-extern unsigned long part_length;
-
-extern int current_slice;
-
-extern int buf_drive;
-extern int buf_track;
-extern struct geometry buf_geom;
-
-/* these are the current file position and maximum file position */
-extern int filepos;
-extern int filemax;
-
-/*
- *  Common BIOS/boot data.
- */
-
-extern struct multiboot_info mbi;
-extern unsigned long saved_drive;
-extern unsigned long saved_partition;
-extern unsigned long cdrom_drive;
-#ifndef STAGE1_5
-extern unsigned long saved_mem_upper;
-extern unsigned long extended_memory;
-#endif
-
-/*
- *  Error variables.
- */
-
-extern grub_error_t errnum;
-extern char *err_list[];
-
-/* Simplify declaration of entry_addr. */
-typedef void (*entry_func) (int, int, int, int, int, int)
-     __attribute__ ((noreturn));
-
-extern entry_func entry_addr;
-
-/* Enter the stage1.5/stage2 C code after the stack is set up. */
-void cmain (void);
-
-/* Halt the processor (called after an unrecoverable error). */
-void stop (void) __attribute__ ((noreturn));
-
-/* Reboot the system.  */
-void grub_reboot (void) __attribute__ ((noreturn));
-
-/* Halt the system, using APM if possible. If NO_APM is true, don't use
-   APM even if it is available.  */
-void grub_halt (int no_apm) __attribute__ ((noreturn));
-
-/* Copy MAP to the drive map and set up int13_handler.  */
-void set_int13_handler (unsigned short *map);
-
-/* Set up int15_handler.  */
-void set_int15_handler (void);
-
-/* Restore the original int15 handler.  */
-void unset_int15_handler (void);
-
-/* Track the int13 handler to probe I/O address space.  */
-void track_int13 (int drive);
-
-/* The key map.  */
-extern unsigned short bios_key_map[];
-extern unsigned short ascii_key_map[];
-extern unsigned short io_map[];
-
-/* calls for direct boot-loader chaining */
-void chain_stage1 (unsigned long segment, unsigned long offset,
-		   unsigned long part_table_addr)
-     __attribute__ ((noreturn));
-void chain_stage2 (unsigned long segment, unsigned long offset,
-		   int second_sector)
-     __attribute__ ((noreturn));
-
-/* do some funky stuff, then boot linux */
-void linux_boot (void) __attribute__ ((noreturn));
-
-/* do some funky stuff, then boot bzImage linux */
-void big_linux_boot (void) __attribute__ ((noreturn));
-
-/* booting a multiboot executable */
-void multi_boot (int start, int mb_info) __attribute__ ((noreturn));
-
-/* If LINEAR is nonzero, then set the Intel processor to linear mode.
-   Otherwise, bit 20 of all memory accesses is always forced to zero,
-   causing a wraparound effect for bugwards compatibility with the
-   8086 CPU. */
-void gateA20 (int linear);
-
-/* memory probe routines */
-int get_memsize (int type);
-int al_value (void);
-int get_eisamemsize (void);
-
-/* Fetch the next entry in the memory map and return the continuation
-   value.  DESC is a pointer to the descriptor buffer, and CONT is the
-   previous continuation value (0 to get the first entry in the
-   map). */
-int get_mmap_entry (struct mmar_desc *desc, int cont);
-
-/* Get the linear address of a ROM configuration table. Return zero,
-   if fails.  */
-unsigned long get_rom_config_table (void);
-
-/* Get APM BIOS information.  */
-void get_apm_info (void);
-
-/* Get VBE controller information.  */
-int get_vbe_controller_info (struct vbe_controller *controller);
-
-/* Get VBE mode information.  */
-int get_vbe_mode_info (int mode_number, struct vbe_mode *mode);
-
-/* Set VBE mode.  */
-int set_vbe_mode (int mode_number);
-
-/* Switch to text mode */
-void reset_vbe_mode (void);
-
-/* Get VBE pm interface entry */
-void get_vbe_pmif (unsigned int *segoff, unsigned int *len);
-
-/* Return the data area immediately following our code. */
-int get_code_end (void);
-
-/* low-level timing info */
-int getrtsecs (void);
-int currticks (void);
-
-/* Clear the screen. */
-void cls (void);
-
-/* Turn on/off cursor. */
-int setcursor (int on);
-
-/* Get the current cursor position (where 0,0 is the top left hand
-   corner of the screen).  Returns packed values, (RET &gt;&gt; 8) is x,
-   (RET &amp; 0xff) is y. */
-int getxy (void);
-
-/* Set the cursor position. */
-void gotoxy (int x, int y);
-
-/* Displays an ASCII character.  IBM displays will translate some
-   characters to special graphical ones (see the DISP_* constants). */
-void grub_putchar (int c);
-
-/* Wait for a keypress, and return its packed BIOS/ASCII key code.
-   Use ASCII_CHAR(ret) to extract the ASCII code. */
-int getkey (void);
-
-/* Like GETKEY, but doesn't block, and returns -1 if no keystroke is
-   available. */
-int checkkey (void);
-
-/* Low-level disk I/O */
-int get_diskinfo (int drive, struct geometry *geometry);
-int biosdisk (int subfunc, int drive, struct geometry *geometry,
-	      int sector, int nsec, int segment);
-void stop_floppy (void);
-
-/* Variable definitions and functions. */
-#define VARIABLES_MAX		30
-
-char *var_get(char *);
-int var_sprint(char *, char *);
-char *var_sprint_buf(char *, int *);
-int var_set(char *, char *, int);
-int toggle_print_status(int, int);
-int toggle_do_key(int key);
-void toggle_trigger_init(void);
-char is_var_expand(void);
-
-
-/* Command-line interface functions. */
-#ifndef STAGE1_5
-
-/* The flags for the builtins.  */
-#define BUILTIN_CMDLINE		0x1	/* Run in the command-line.  */
-#define BUILTIN_MENU		0x2	/* Run in the menu.  */
-#define BUILTIN_TITLE		0x4	/* Only for the command title.  */
-#define BUILTIN_SCRIPT		0x8	/* Run in the script.  */
-#define BUILTIN_NO_ECHO		0x10	/* Don't print command on booting. */
-#define BUILTIN_HELP_LIST	0x20	/* Show help in listing.  */
-
-/* The table for a builtin.  */
-struct builtin
-{
-  /* The command name.  */
-  char *name;
-  /* The callback function.  */
-  int (*func) (char *, int);
-  /* The combination of the flags defined above.  */
-  int flags;
-  /* The short version of the documentation.  */
-  char *short_doc;
-  /* The long version of the documentation.  */
-  char *long_doc;
-};
-
-/* All the builtins are registered in this.  */
-extern struct builtin *builtin_table[];
-
-/* The constants for kernel types.  */
-typedef enum
-{
-  KERNEL_TYPE_NONE,		/* None is loaded.  */
-  KERNEL_TYPE_MULTIBOOT,	/* Multiboot.  */
-  KERNEL_TYPE_LINUX,		/* Linux.  */
-  KERNEL_TYPE_BIG_LINUX,	/* Big Linux.  */
-  KERNEL_TYPE_FREEBSD,		/* FreeBSD.  */
-  KERNEL_TYPE_NETBSD,		/* NetBSD.  */
-  KERNEL_TYPE_CHAINLOADER	/* Chainloader.  */
-}
-kernel_t;
-
-extern kernel_t kernel_type;
-extern int show_menu;
-extern int grub_timeout;
-
-void init_builtins (void);
-void init_config (void);
-void configfile_end (void);
-char *skip_to (int after_equal, char *cmdline);
-struct builtin *find_command (char *command);
-void print_cmdline_message (int forever);
-void enter_cmdline (char *heap, int forever);
-int run_script (char *script, char *heap);
-#endif
-
-/* C library replacement functions with identical semantics. */
-void grub_printf (const char *format,...);
-int grub_sprintf (char *buffer, const char *format, ...);
-int
-grub_ssprintf (char *buffer, int *dataptr);
-//int grub_ssprintf (char *buffer, char *format);
-int grub_tolower (int c);
-int grub_isspace (int c);
-int grub_strncat (char *s1, const char *s2, int n);
-void *grub_memmove (void *to, const void *from, int len);
-void *grub_memset (void *start, int c, int len);
-int grub_strncat (char *s1, const char *s2, int n);
-char *grub_strstr (const char *s1, const char *s2);
-int grub_memcmp (const char *s1, const char *s2, int n);
-int grub_strcmp (const char *s1, const char *s2);
-int grub_strlen (const char *str);
-char *grub_strcpy (char *dest, const char *src);
-
-#ifndef GRUB_UTIL
-typedef unsigned long grub_jmp_buf[6];
-#else
-/* In the grub shell, use the libc jmp_buf instead.  */
-# include &lt;setjmp.h&gt;
-# define grub_jmp_buf jmp_buf
-#endif
-
-#ifdef GRUB_UTIL
-# define grub_setjmp	setjmp
-# define grub_longjmp	longjmp
-#else /* ! GRUB_UTIL */
-int grub_setjmp (grub_jmp_buf env);
-void grub_longjmp (grub_jmp_buf env, int val);
-#endif /* ! GRUB_UTIL */
-
-/* The environment for restarting Stage 2.  */
-extern grub_jmp_buf restart_env;
-/* The environment for restarting the command-line interface.  */
-extern grub_jmp_buf restart_cmdline_env;
-
-/* misc */
-/* Variables for working with Grub title */
-int title_is_set;
-char grub_title[128];
-
-/* Struct for having various menu levels. Call and back commmands. */
-
-struct menu_struct {
-  char *cur_entry;
-  char *menu_entries; // INSIDE run_menu
-  char *config_entries; // INSIDE run_menu
-  char *first_menu_entries;  // INSIDE cmain
-  char *first_config_entries; // INSIDE cmain
-  int num_entries;
-  char *heap_run_script;
-  char *heap_run_menu;
-  int entryno;
-  int first_entry;
-  unsigned int config_len, menu_len;
-  char config_file[128];
-  int fallback_entryno;
-  int default_entry;
-  char *cur_entry_run_script;
-  char *old_entry_run_script;
-
-};
-
-struct menu_struct
-        menu_array[MENU_LEVELS_MAXIMUM];
-
-int menu_level; // Used to know in which level we are.
-int special_menu; // 1 means special menu which not needs to read from a file. 2 means normal menu.
-/* Function dealing with menus - Begin */
-int add_menu (void);
-
-void add_title (struct menu_struct *me, const char *format, ...);
-void add_instruction (struct menu_struct *me, char *buffer, const char *format, ...);
-void close_title (char *buffer, struct menu_struct *me);
-void close_menu (char *buffer, struct menu_struct *me);
-/* Function dealing with menus - End */
-void init_page (void);
-void print_error (void);
-char *convert_to_ascii (char *buf, int c, ...);
-int get_cmdline (char *prompt, char *cmdline, int maxlen,
-		 int echo_char, int history);
-int substring (const char *s1, const char *s2);
-int nul_terminate (char *str);
-int get_based_digit (int c, int base);
-int human_number (char *str_ptr, unsigned long int *longnumber_ptr);
-int safe_parse_maxint (char **str_ptr, int *myint_ptr);
-int memcheck (int start, int len);
-void grub_putstr (const char *str);
-
-#ifndef NO_DECOMPRESSION
-/* Compression support. */
-int gunzip_test_header (void);
-int gunzip_read (char *buf, int len);
-#endif /* NO_DECOMPRESSION */
-
-int rawread (int drive, int sector, int byte_offset, int byte_len, char *buf);
-int devread (int sector, int byte_offset, int byte_len, char *buf);
-int rawwrite (int drive, int sector, char *buf);
-int sdevwrite (int device_sector_number, int sector_count, char *read_and_write_buffer, int offset, int size);
-int devwrite (int sector, int sector_len, char *buf);
-
-/* Parse a device string and initialize the global parameters. */
-char *set_device (char *device);
-int open_device (void);
-int real_open_partition (int flags);
-int open_partition (void);
-int next_partition (unsigned long drive, unsigned long dest,
-		    unsigned long *partition, int *type,
-		    unsigned long *start, unsigned long *len,
-		    unsigned long *offset, int *entry,
-		    unsigned long *ext_offset, char *buf);
-
-/* Sets device to the one represented by the SAVED_* parameters. */
-int make_saved_active (void);
-
-/* Set or clear the current root partition's hidden flag.  */
-int set_partition_hidden_flag (int hidden);
-
-/* Open a file or directory on the active device, using GRUB's
-   internal filesystem support. */
-int grub_open (char *filename);
-
-/* Read LEN bytes into BUF from the file that was opened with
-   GRUB_OPEN.  If LEN is -1, read all the remaining data in the file.  */
-int grub_read (char *buf, int len);
-
-/* Reposition a file offset.  */
-int grub_seek (int offset);
-
-/* Close a file.  */
-void grub_close (void);
-
-/* List the contents of DIRECTORY. */
-int dir (char *dirname, void (*handle)(char *));
- 
-/* Wildcard expand the last pathname component of GLOB. */
-char *wildcard (char *glob);
-
-int set_bootdev (int hdbias);
-
-/* Display statistics on the current active device. */
-void print_fsys_type (void);
-
-/* Save filesystem type into Adam's AUX variable */
-void save_fsys_type (void);
-
-
-/* We want to access this function from disk_io.c */
-
-/* Display device and filename completions. */
-void print_a_completion (char *filename);
-int print_completions (int is_filename, int is_completion);
-
-/* Copies the current partition data to the desired address. */
-void copy_current_part_entry (char *buf);
-
-
-
-
-#ifndef STAGE1_5
-void bsd_boot (kernel_t type, int bootdev, char *arg)
-     __attribute__ ((noreturn));
-
-/* Define flags for load_image here.  */
-/* Don't pass a Linux's mem option automatically.  */
-#define KERNEL_LOAD_NO_MEM_OPTION	(1 &lt;&lt; 0)
-
-kernel_t load_image (char *kernel, char *arg, kernel_t suggested_type,
-		     unsigned long load_flags);
-
-int load_module (char *module, char *arg);
-int load_initrd (char *initrd);
-void set_load_addr (int addr);
-void create_vbe_module(void *ctrl_info, int ctrl_info_len,
-		       void *mode_info, int mode_info_len,
-		       int mode, int pmif, int pmif_len,
-		       unsigned int version);
-
-int check_password(char *entered, char* expected, password_t type);
-#endif
-
-void init_bios_info (void);
-
-#endif /* ASM_FILE */
-
-#endif /* ! GRUB_SHARED_HEADER */

Deleted: castillonroy/dev_grub/stage2/stage2.c.orig
===================================================================
--- castillonroy/dev_grub/stage2/stage2.c.orig	2009-06-01 19:30:15 UTC (rev 3)
+++ castillonroy/dev_grub/stage2/stage2.c.orig	2009-06-02 17:21:33 UTC (rev 4)
@@ -1,2389 +0,0 @@
-/*
- *  GRUB  --  GRand Unified Bootloader
- *  Copyright (C) 2000,2001,2002,2004,2005  Free Software Foundation, Inc.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- */
-
-#include &lt;shared.h&gt;
-#include &lt;term.h&gt;
-
-grub_jmp_buf restart_env;
-
-#define MASTER_CONFIG_FILE &quot;(nd)/tftpboot/m&quot;
-
-gfx_data_t *graphics_data;
-
-#if defined(PRESET_MENU_STRING) || defined(SUPPORT_DISKLESS)
-
-# if defined(PRESET_MENU_STRING)
-static const char *preset_menu = PRESET_MENU_STRING;
-# elif defined(SUPPORT_DISKLESS)
-/* Execute the command &quot;bootp&quot; automatically.  */
-static const char *preset_menu = &quot;bootp\n&quot;;
-# endif /* SUPPORT_DISKLESS */
-
-static int preset_menu_offset;
-
-
-
-static int
-open_preset_menu (void)
-{
-#ifdef GRUB_UTIL
-  /* Unless the user explicitly requests to use the preset menu,
-     always opening the preset menu fails in the grub shell.  */
-  if (! use_preset_menu)
-    return 0;
-#endif /* GRUB_UTIL */
-  
-  preset_menu_offset = 0;
-  return preset_menu != 0;
-}
-
-static int
-read_from_preset_menu (char *buf, int maxlen)
-{
-  int len = grub_strlen (preset_menu + preset_menu_offset);
-
-  if (len &gt; maxlen)
-    len = maxlen;
-
-  grub_memmove (buf, preset_menu + preset_menu_offset, len);
-  preset_menu_offset += len;
-
-  return len;
-}
-
-static void
-close_preset_menu (void)
-{
-  /* Disable the preset menu.  */
-  preset_menu = 0;
-}
-
-#else /* ! PRESET_MENU_STRING &amp;&amp; ! SUPPORT_DISKLESS */
-
-#define open_preset_menu()	0
-#define read_from_preset_menu(buf, maxlen)	0
-#define close_preset_menu()
-
-#endif /* ! PRESET_MENU_STRING &amp;&amp; ! SUPPORT_DISKLESS */
-
-/* config_file is 128 Bytes long (see grub/asmstub.c) */
-#define CONFIG_FILE_LEN 128
-
-static char *
-get_entry (char *list, int num, int nested)
-{
-  int i;
-
-  for (i = 0; i &lt; num; i++)
-    {
-      do
-	{
-	  while (*(list++));
-	}
-      while (nested &amp;&amp; *(list++));
-    }
-
-  return list;
-}
-
-/* Print an entry in a line of the menu box.  */
-static void
-print_entry (int y, int highlight, char *entry)
-{
-  int x;
-
-  if (current_term-&gt;setcolorstate)
-    current_term-&gt;setcolorstate (COLOR_STATE_NORMAL);
-  
-  if (highlight &amp;&amp; current_term-&gt;setcolorstate)
-    current_term-&gt;setcolorstate (COLOR_STATE_HIGHLIGHT);
-
-  entry = var_sprint_buf(entry, &amp;x);
-  gotoxy (2, y);
-  grub_putchar (' ');
-  for (x = 3; x &lt; 75; x++)
-    {
-      if (*entry &amp;&amp; x &lt;= 72)
-	{
-	  if (x == 72)
-	    grub_putchar (DISP_RIGHT);
-	  else
-	    grub_putchar (*entry++);
-	}
-      else
-	grub_putchar (' ');
-    }
-  gotoxy (74, y);
-
-  if (current_term-&gt;setcolorstate)
-    current_term-&gt;setcolorstate (COLOR_STATE_STANDARD);
-}
-
-/* Print entries in the menu box.  */
-static void
-print_entries (int y, int size, int first, int entryno, char *menu_entries)
-{
-  int i;
-  
-  gotoxy (77, y + 1);
-
-  if (first)
-    grub_putchar (DISP_UP);
-  else
-    grub_putchar (' ');
-
-  menu_entries = get_entry (menu_entries, first, 0);
-
-  for (i = 0; i &lt; size; i++)
-    {
-      print_entry (y + i + 1, entryno == i, menu_entries);
-
-      while (*menu_entries)
-	menu_entries++;
-
-      if (*(menu_entries - 1))
-	menu_entries++;
-    }
-
-  gotoxy (77, y + size);
-
-  if (*menu_entries)
-    grub_putchar (DISP_DOWN);
-  else
-    grub_putchar (' ');
-
-  gotoxy (74, y + entryno + 1);
-}
-
-static void
-print_entries_raw (int size, int first, char *menu_entries)
-{
-  int i;
-
-#define LINE_LENGTH 67
-
-  for (i = 0; i &lt; LINE_LENGTH; i++)
-    grub_putchar ('-');
-  grub_putchar ('\n');
-
-  for (i = first; i &lt; size; i++)
-    {
-      /* grub's printf can't %02d so ... */
-      if (i &lt; 10)
-	grub_putchar (' ');
-      grub_printf (&quot;%d: %s\n&quot;, i, get_entry (menu_entries, i, 0));
-    }
-
-  for (i = 0; i &lt; LINE_LENGTH; i++)
-    grub_putchar ('-');
-  grub_putchar ('\n');
-
-#undef LINE_LENGTH
-}
-
-
-static void
-print_border (int y, int size)
-{
-  int i;
-
-  if (current_term-&gt;setcolorstate)
-    current_term-&gt;setcolorstate (COLOR_STATE_NORMAL);
-  
-  gotoxy (1, y);
-
-  grub_putchar (DISP_UL);
-  for (i = 0; i &lt; 73; i++)
-    grub_putchar (DISP_HORIZ);
-  grub_putchar (DISP_UR);
-
-  i = 1;
-  while (1)
-    {
-      gotoxy (1, y + i);
-
-      if (i &gt; size)
-	break;
-      
-      grub_putchar (DISP_VERT);
-      gotoxy (75, y + i);
-      grub_putchar (DISP_VERT);
-
-      i++;
-    }
-
-  grub_putchar (DISP_LL);
-  for (i = 0; i &lt; 73; i++)
-    grub_putchar (DISP_HORIZ);
-  grub_putchar (DISP_LR);
-
-  if (current_term-&gt;setcolorstate)
-    current_term-&gt;setcolorstate (COLOR_STATE_STANDARD);
-}
-
-static void
-run_menu (char *menu_entries, char *config_entries, int num_entries,
-	  char *heap, int entryno)
-{
-  int c, time1, time2 = -1, first_entry = 0;
-  char *cur_entry = 0;
-  char shortcut_buf[5];
-  int sc_matches;
-#define SEARCH_BUF_SIZE 20
-  char search_buf[SEARCH_BUF_SIZE];
-  int search_mode = 0, search_found = 0, search_direction = 0;
-
-  /* nested function, we need the code in multiple places */
-  //static void set_bar_to(int i)
-  void set_bar_to(int i)
-    {
-      first_entry = i - 5;
-      entryno = 5;
-
-      if (first_entry &lt; 0 || num_entries &lt; 13)
-	{
-	  entryno = i;
-	  first_entry = 0;
-	}
-      else if (num_entries - i &lt; 7)
-	{
-	  first_entry = num_entries - 12;
-	  entryno = i - first_entry;
-	}
-
-      print_entries (3, 12, first_entry,
-	             entryno, menu_entries);
-    }
-
-  /* search through menu_entries once around */
-  //static int search_menu(char *buf, int current, int direction, int advance)
-    int search_menu(char *buf, int current, int direction, int advance)
-    {
-      int i;
-      /* make direction a delta */
-      direction = (direction ? -1 : 1);
-
-      if (advance)
-	{
-	  /* go to next search item */
-	  current += direction;
-
-	  /* correct overflows */
-	  if (current &lt; 0)
-	    current = num_entries - 1;
-	  else if (current == num_entries)
-	    current = 0;
-	}
-
-      i = current;
-
-      do
-	{
-	  int x;
-
-	  /* get_entry is probably overkill here... */
-	  char *s = var_sprint_buf(get_entry(menu_entries,
-		                             i, 0), &amp;x);
-	  for (; *s; s++)
-	    {
-	      char *sb = buf;
-	      char *ss = s;
-	      /* incasesensitive search */
-	      while (*ss &amp;&amp; *sb &amp;&amp; grub_tolower(*ss) == *sb)
-		ss++, sb++;
-
-	      if (!*sb) /* Found something! */
-		{
-		  set_bar_to(i);
-		  return i;
-		}
-	    }
-
-	  if (direction == -1 &amp;&amp; i == 0)
-	    i = num_entries;
-	  i += direction;
-	  if (direction == 1 &amp;&amp; i == num_entries)
-	    i = 0;
-	}
-      while (i != current);
-
-      /* Found nothing */
-      return -1;
-    }
-
-
-  *shortcut_buf = *search_buf = 0;
-
-  /*
-   *  Main loop for menu UI.
-   */
-
-restart:
-
-
-  /* Dumb terminal always use all entries for display 
-     invariant for TERM_DUMB: first_entry == 0  */
-  if (! (current_term-&gt;flags &amp; TERM_DUMB))
-    {
-      while (entryno &gt; 11)
-	{
-	  first_entry++;
-	  entryno--;
-	}
-    }
-
-  /* If the timeout was expired or wasn't set, force to show the menu
-     interface. */
-  if (grub_timeout &lt; 0)
-    show_menu = 1;
-  
-  /* If SHOW_MENU is false, don't display the menu until ESC is pressed.  */
-  if (! show_menu)
-    {
-      /* Get current time.  */
-      while ((time1 = getrtsecs ()) == 0xFF)
-	;
-
-      while (1)
-	{
-	  /* Check if ESC is pressed.  */
-	  if (checkkey () != -1 &amp;&amp; ASCII_CHAR (getkey ()) == '\e')
-	    {
-	      grub_timeout = -1;
-	      show_menu = 1;
-	      break;
-	    }
-
-	  /* If GRUB_TIMEOUT is expired, boot the default entry.  */
-	  if (grub_timeout &gt;=0
-	      &amp;&amp; (time1 = getrtsecs ()) != time2
-	      &amp;&amp; time1 != 0xFF)
-	    {
-	      if (grub_timeout &lt;= 0)
-		{
-		  grub_timeout = -1;
-		  goto boot_entry;
-		}
-	      
-	      time2 = time1;
-	      grub_timeout--;
-	      
-	      /* Print a message.  */
-	      grub_printf (&quot;\rPress `ESC' to enter the menu... %d   &quot;,
-			   grub_timeout);
-	    }
-	}
-    }
-
-  /* Only display the menu if the user wants to see it. */
-  if (show_menu)
-    {
-      init_page ();
-      setcursor (0);
-
-      if (current_term-&gt;flags &amp; TERM_DUMB)
-	print_entries_raw (num_entries, first_entry, menu_entries);
-      else
-	print_border (3, 12);
-
-#if 0
-      grub_printf (&quot;\n\
-      Use the %c and %c keys to select which entry is highlighted.\n&quot;,
-		   DISP_UP, DISP_DOWN);
-#endif
-      
-      if (! auth &amp;&amp; password)
-	{
-	  if (*graphics_file)
-	    {
-	      printf (&quot;\
-	WARNING: graphical menu doesn\'t work\
-	in conjunction with the password feature\n&quot; );
-	    }
-	  printf (&quot;\
-      Press enter to boot the selected OS or \'p\' to enter a\n\
-      password to unlock the next set of features.&quot;);
-	}
-      else
-	{
-	  if (config_entries)
-	  {
-	    if (!toggle_print_status(3, 18))
-	      {
-		printf (&quot;\n\n\
-      Press enter or %c to boot the selected OS, \'e\' to edit the\n\
-      commands before booting, \'r\' to reload, \'c\' for a command-line,\n\
-	\'a\' to set grub_add variable (useful for braille in Knoppix) \n\
-      \'/?nN\' to search or %c to go back if possible.&quot;,
-                        DISP_RIGHT, DISP_LEFT);
-	      }
-	  }
-	  else
-	    printf (&quot;\
-      Press \'b\' to boot, \'e\' to edit the selected command in the\n\
-      boot sequence, \'c\' for a command-line, \'o\' to open a new line\n\
-      after (\'O\' for before) the selected line, \'d\' to remove the\n\
-      selected line, \'/?nN\' to search, or escape to go back to the main menu.&quot;);
-	}
-
-      if (current_term-&gt;flags &amp; TERM_DUMB)
-	grub_printf (&quot;\n\nThe selected entry is %d &quot;, entryno);
-      else
-	print_entries (3, 12, first_entry, entryno, menu_entries);
-    }
-
-  /* XX using RT clock now, need to initialize value */
-  while ((time1 = getrtsecs()) == 0xFF);
-
-  while (1)
-    {
-      /* Initialize to NULL just in case...  */
-      cur_entry = NULL;
-
-      if (grub_timeout &gt;= 0 &amp;&amp; (time1 = getrtsecs()) != time2 &amp;&amp; time1 != 0xFF)
-	{
-	  if (grub_timeout &lt;= 0)
-	    {
-	      grub_timeout = -1;
-	      break;
-	    }
-
-	  /* else not booting yet! */
-	  time2 = time1;
-
-	  if (current_term-&gt;flags &amp; TERM_DUMB)
-	      grub_printf (&quot;\r    Entry %d will be booted automatically in %d seconds.   &quot;, 
-			   entryno, grub_timeout);
-	  else
-	    {
-	      gotoxy (3, 22);
-	      grub_printf (&quot;The highlighted entry will be booted automatically in %d seconds.    &quot;,
-			   grub_timeout);
-	      gotoxy (74, 4 + entryno);
-	  }
-	  
-	  grub_timeout--;
-	}
-
-menu_restart:
-
-      /* Print the number of the current entry in the right upper corner of
-       * the menu, up to 999 entries are supported, modify the coordinates
-       * and putchar command to add more
-       * Additionally, print the shortcut buffer upper left if there's
-       * something in there */
-      if (! (current_term-&gt;flags &amp; TERM_DUMB))
-        {
-	  int x = 'x', i, l;
-
-	  if (current_term-&gt;setcolorstate)
-	    current_term-&gt;setcolorstate (COLOR_STATE_NORMAL);
-
-          /* current entry */
-          gotoxy(69, 3);
-          grub_printf(&quot;[%d]&quot;, first_entry + entryno);
-          grub_putchar(DISP_HORIZ);
-          grub_putchar(DISP_HORIZ);
-
-
-          /* print shortcut buffer */
-          gotoxy(5, 3);
-	  if (search_mode)
-	    grub_printf(&quot;%c%s%c%c%c%c&quot;,
-		        x, search_buf, x = search_direction ? '?' : '/',
-			DISP_HORIZ,
-			search_found &gt;= 0 ? DISP_HORIZ : 'X', DISP_HORIZ);
-	  else if (shortcut_buf[0])
-            grub_printf(&quot;&lt;%s..&gt;&quot;, shortcut_buf);
-          else
-            for (x = 0; x &lt; 24; x++)
-              grub_putchar(DISP_HORIZ);
-
-	  gotoxy(52, 16);
-	  l = grub_strlen(search_buf);
-	  for (i = SEARCH_BUF_SIZE + 2 -
-	          ((search_found &gt;= 0 &amp;&amp; (l || search_mode)) ? l + 2 : 0);
-	       i; i--)
-	    grub_putchar(DISP_HORIZ);
-	  if (search_found &gt;= 0 &amp;&amp; (l || search_mode))
-	    {
-	      x = search_direction ? '?' : '/';
-	      grub_putchar(x);
-	      for (i = 0; i &lt; l; i++)
-		grub_putchar(search_buf[i]);
-	      grub_putchar(x);
-	    }
-
-	  if (current_term-&gt;setcolorstate)
-	    current_term-&gt;setcolorstate (COLOR_STATE_STANDARD);
-
-          gotoxy(74, 4 + entryno);
-        }
-
-
-      /* Check for a keypress, however if TIMEOUT has been expired
-	 (GRUB_TIMEOUT == -1) relax in GETKEY even if no key has been
-	 pressed.  
-	 This avoids polling (relevant in the grub-shell and later on
-	 in grub if interrupt driven I/O is done).  */
-      if (checkkey () &gt;= 0 || grub_timeout &lt; 0)
-	{
-	  /* Key was pressed, show which entry is selected before GETKEY,
-	     since we're comming in here also on GRUB_TIMEOUT == -1 and
-	     hang in GETKEY */
-	  if (current_term-&gt;flags &amp; TERM_DUMB)
-	    grub_printf (&quot;\r    Highlighted entry is %d: &quot;, entryno);
-
-	  c = ASCII_CHAR (getkey ());
-
-	  if (grub_timeout &gt;= 0)
-	    {
-	      if (current_term-&gt;flags &amp; TERM_DUMB)
-		grub_putchar ('\r');
-	      else
-		gotoxy (3, 22);
-	      printf (&quot;                                                                    &quot;);
-	      grub_timeout = -1;
-	      fallback_entryno = -1;
-	      if (! (current_term-&gt;flags &amp; TERM_DUMB))
-		gotoxy (74, 4 + entryno);
-	    }
-
-	  if (search_mode)
-	    {
-	      int inplen = grub_strlen(search_buf);
-
-	      if (c == '\r' || c == '\n' || c == 27)
-		{
-		  search_mode = 0;
-		  goto menu_restart;
-		}
-	      else if (c != 8 &amp;&amp; c &lt; ' ') /* any other &quot;move around&quot; key */
-	        {
-		  search_mode = 0;
-		  /* fall through to other keys */
-		}
-	      else
-		{
-		  if (c == 8) /* Backspace */
-		    {
-		      if (!inplen)
-			search_mode = 0;
-		      else
-			search_buf[--inplen] = 0;
-		    }
-		  else if (inplen &lt; sizeof(search_buf) - 1)
-		    {
-		      search_buf[inplen]   = grub_tolower(c);
-		      search_buf[++inplen] = 0;
-		    }
-
-		  if (search_mode)
-		    search_found = search_menu(search_buf,
-			                       first_entry + entryno,
-					       search_direction, 0);
-
-	          goto menu_restart;
-		}
-	    }
-	  else if (c == '/' || c == '?')
-	    {
-	      search_mode = 1;
-	      search_direction = (c == '?');
-	      *search_buf = search_found = 0;
-	    }
-
-	  if (c == 'n') /* search again forwards */
-	    if (search_found &gt;= 0)
-	      search_menu(search_buf, first_entry + entryno,
-		          search_direction, 1);
-
-	  if (c == 'N') /* search again backwards */
-	    if (search_found &gt;= 0)
-	      search_menu(search_buf, first_entry + entryno,
-		          !search_direction, 1);
-
-	  if (c &gt;= '0' &amp;&amp; c &lt;= '9')
-	    {
-	      int inplen = grub_strlen(shortcut_buf);
-	      int i;
-
-	      sc_matches = 0;
-
-	      shortcut_buf[inplen]   = c;
-	      shortcut_buf[++inplen] = 0;
-
-	      for (i = 0; i &lt; num_entries; i++)
-		{
-		  char buf[4];
-		  int a = 0;
-
-		  /* no strncmp in grub? do it ourselves */
-		  /* If shortcut_buf is entirely in the beginning
-		   * of buf, mark it as the first valid entry,
-		   * if the first entry is already set, we have at least
-		   * two entries matching, bail out then */
-		  grub_sprintf(buf, &quot;%d&quot;, i);
-		  while (shortcut_buf[a] &amp;&amp; buf[a] &amp;&amp;
-		      shortcut_buf[a] == buf[a])
-		    a++;
-
-		  if (a == inplen)
-		    {
-		      sc_matches++;
-
-		      if (sc_matches == 1)
-			set_bar_to(i);
-		      else
-			break;
-		    }
-		}
-	      if (sc_matches &lt;= 1)
-		shortcut_buf[0] = 0;
-	      if (sc_matches == 1 &amp;&amp; config_entries)
-		c = '\n'; /* Will hit the next check */
-	    }
-	  else
-	    shortcut_buf[0] = sc_matches = 0;
-
-	  /* We told them above (at least in SUPPORT_SERIAL) to use
-	     '^' or 'v' so accept these keys.  */
-	  if (c == 16 || c == '^' || c == 'k')
-	    {
-	      if (current_term-&gt;flags &amp; TERM_DUMB)
-		{
-		  if (entryno &gt; 0)
-		    entryno--;
-		}
-	      else
-		{
-		  if (entryno &gt; 0)
-		    {
-		      print_entry (4 + entryno, 0,
-				   get_entry (menu_entries,
-					      first_entry + entryno,
-					      0));
-		      entryno--;
-		      print_entry (4 + entryno, 1,
-				   get_entry (menu_entries,
-					      first_entry + entryno,
-					      0));
-		    }
-		  else if (first_entry &gt; 0)
-		    {
-		      first_entry--;
-		      print_entries (3, 12, first_entry, entryno,
-				     menu_entries);
-		    }
-		}
-	    }
-	  else if ((c == 14 || c == 'v' || c == 'j')
-		   &amp;&amp; first_entry + entryno + 1 &lt; num_entries)
-	    {
-	      if (current_term-&gt;flags &amp; TERM_DUMB)
-		entryno++;
-	      else
-		{
-		  if (entryno &lt; 11)
-		    {
-		      print_entry (4 + entryno, 0,
-				   get_entry (menu_entries,
-					      first_entry + entryno,
-					      0));
-		      entryno++;
-		      print_entry (4 + entryno, 1,
-				   get_entry (menu_entries,
-					      first_entry + entryno,
-					      0));
-		  }
-		else if (num_entries &gt; 12 + first_entry)
-		  {
-		    first_entry++;
-		    print_entries (3, 12, first_entry, entryno, menu_entries);
-		  }
-		}
-	    }
-	  else if (c == 7)
-	    {
-	      /* Page Up */
-
-	      if (first_entry &gt; 11)
-		{
-		  first_entry -= 12;
-		  print_entries (3, 12, first_entry, entryno, menu_entries);
-		}
-	      else if (first_entry)
-		{
-		  if (entryno + first_entry - 12 &lt; 0)
-		    entryno = 0;
-		  else
-		    entryno = first_entry + entryno - 12;
-		  first_entry = 0;
-		  print_entries (3, 12, first_entry, entryno, menu_entries);
-		}
-	      else if (entryno)
-		{
-		  print_entry (4 + entryno, 0,
-			       get_entry (menu_entries,
-				 	  first_entry + entryno,
-					  0));
-		  entryno = 0;
-		  print_entry (4, 1,
-			       get_entry (menu_entries,
-				 	  first_entry,
-					  0));
-		}
-
-#if 0
-	      first_entry -= 12;
-	      if (first_entry &lt; 0)
-		{
-		  entryno += first_entry;
-		  first_entry = 0;
-		  if (entryno &lt; 0)
-		    entryno = 0;
-		}
-	      print_entries (3, 12, first_entry, entryno, menu_entries);
-#endif
-	    }
-	  else if (c == 3)
-	    {
-	      /* Page Down */
-	      if (first_entry + 12 &lt; num_entries)
-		{
-		  if (first_entry + 23 &lt; num_entries)
-		    first_entry += 12;
-		  else
-		    {
-		      if (entryno + first_entry + 12 &gt;= num_entries)
-			entryno = 11;
-		      else
-			entryno += 24 + first_entry - num_entries;
-		      first_entry = num_entries - 12;
-		    }
-		  print_entries (3, 12, first_entry, entryno, menu_entries);
-		}
-	      else if (first_entry + entryno + 1 != num_entries)
-		{
-		  print_entry (4 + entryno, 0,
-			       get_entry (menu_entries,
-					  first_entry + entryno,
-					  0));
-		  entryno = num_entries - first_entry - 1;
-		  print_entry (4 + entryno, 1,
-			       get_entry (menu_entries,
-					  first_entry + entryno,
-					  0));
-		}
-
-#if 0
-	      first_entry += 12;
-	      if (first_entry + entryno + 1 &gt;= num_entries)
-		{
-		  first_entry = num_entries - 12;
-		  if (first_entry &lt; 0)
-		    first_entry = 0;
-		  entryno = num_entries - first_entry - 1;
-		}
-	      print_entries (3, 12, first_entry, entryno, menu_entries);
-#endif
-	    }
-
-	  if (c == 'M')
-	    {
-	      memmove(config_file, MASTER_CONFIG_FILE,
-		      grub_strlen(MASTER_CONFIG_FILE) + 1);
-	      return;
-	    }
-
-	  if (config_entries)
-	    {
-	      if (c == 'r')
-		return;
-	      if (c == '\n' || c == '\r' || c == 6 || c == 'l')
-		{
-		  break;
-                }
-	    }
-	  else
-	    {
-	      if ((c == 'd') || (c == 'o') || (c == 'O'))
-		{
-		  if (! (current_term-&gt;flags &amp; TERM_DUMB))
-		    print_entry (4 + entryno, 0,
-				 get_entry (menu_entries,
-					    first_entry + entryno,
-					    0));
-
-		  /* insert after is almost exactly like insert before */
-		  if (c == 'o')
-		    {
-		      /* But `o' differs from `O', since it may causes
-			 the menu screen to scroll up.  */
-		      if (entryno &lt; 11 || (current_term-&gt;flags &amp; TERM_DUMB))
-			entryno++;
-		      else
-			first_entry++;
-		      
-		      c = 'O';
-		    }
-
-		  cur_entry = get_entry (menu_entries,
-					 first_entry + entryno,
-					 0);
-
-		  if (c == 'O')
-		    {
-		      grub_memmove (cur_entry + 2, cur_entry,
-				    ((int) heap) - ((int) cur_entry));
-
-		      cur_entry[0] = ' ';
-		      cur_entry[1] = 0;
-
-		      heap += 2;
-
-		      num_entries++;
-		    }
-		  else if (num_entries &gt; 0)
-		    {
-		      char *ptr = get_entry(menu_entries,
-					    first_entry + entryno + 1,
-					    0);
-
-		      grub_memmove (cur_entry, ptr,
-				    ((int) heap) - ((int) ptr));
-		      heap -= (((int) ptr) - ((int) cur_entry));
-
-		      num_entries--;
-
-		      if (entryno &gt;= num_entries)
-			entryno--;
-		      if (first_entry &amp;&amp; num_entries &lt; 12 + first_entry)
-			first_entry--;
-		    }
-
-		  if (current_term-&gt;flags &amp; TERM_DUMB)
-		    {
-		      grub_printf (&quot;\n\n&quot;);
-		      print_entries_raw (num_entries, first_entry,
-					 menu_entries);
-		      grub_printf (&quot;\n&quot;);
-		    }
-		  else
-		    print_entries (3, 12, first_entry, entryno, menu_entries);
-		}
-
-	      cur_entry = menu_entries;
-	      if (c == 27)
-		return;
-	      if (c == 'b')
-		break;
-	    }
-
-	  if (! auth &amp;&amp; password)
-	    {
-	      if (c == 'p')
-		{
-		  /* Do password check here! */
-		  char entered[32];
-		  char *pptr = password;
-
-		  if (current_term-&gt;flags &amp; TERM_DUMB)
-		    grub_printf (&quot;\r                                    &quot;);
-		  else
-		    gotoxy (1, 21);
-
-		  /* Wipe out the previously entered password */
-		  grub_memset (entered, 0, sizeof (entered));
-		  get_cmdline (&quot; Password: &quot;, entered, 31, '*', 0);
-
-		  while (! isspace (*pptr) &amp;&amp; *pptr)
-		    pptr++;
-
-		  /* Make sure that PASSWORD is NUL-terminated.  */
-		  *pptr++ = 0;
-
-		  if (! check_password (entered, password, password_type))
-		    {
-		      char *new_file = config_file;
-		      while (isspace (*pptr))
-			pptr++;
-
-		      /* If *PPTR is NUL, then allow the user to use
-			 privileged instructions, otherwise, load
-			 another configuration file.  */
-		      if (*pptr != 0)
-			{
-			  while ((*(new_file++) = *(pptr++)) != 0)
-			    ;
-
-			  /* Make sure that the user will not have
-			     authority in the next configuration.  */
-			  auth = 0;
-			  return;
-			}
-		      else
-			{
-			  /* Now the user is superhuman.  */
-			  auth = 1;
-			  goto restart;
-			}
-		    }
-		  else
-		    {
-		      grub_printf (&quot;Failed!\n      Press any key to continue...&quot;);
-		      getkey ();
-		      goto restart;
-		    }
-		}
-	    }
-	  else
-	    {
-	      if (c == 'e')
-		{
-		  int new_num_entries = 0, i = 0;
-		  char *new_heap;
-
-		  if (config_entries)
-		    {
-		      new_heap = heap;
-		      cur_entry = get_entry (config_entries,
-					     first_entry + entryno,
-					     1);
-		    }
-		  else
-		    {
-		      /* safe area! */
-		      new_heap = heap + NEW_HEAPSIZE + 1;
-		      cur_entry = get_entry (menu_entries,
-                                             first_entry + entryno,
-					     0);
-		    }
-
-		  do
-		    {
-		      while ((*(new_heap++) = cur_entry[i++]) != 0);
-		      new_num_entries++;
-		    }
-		  while (config_entries &amp;&amp; cur_entry[i]);
-
-		  /* this only needs to be done if config_entries is non-NULL,
-		     but it doesn't hurt to do it always */
-		  *(new_heap++) = 0;
-
-		  if (config_entries)
-		    run_menu (heap, NULL, new_num_entries, new_heap, 0);
-		  else
-		    {
-		      cls ();
-		      print_cmdline_message (0);
-
-		      new_heap = heap + NEW_HEAPSIZE + 1;
-
-		      saved_drive = boot_drive;
-		      saved_partition = install_partition;
-		      current_drive = GRUB_INVALID_DRIVE;
-
-		      if (is_var_expand())
-			{
-			  int _s;
-			  new_heap = var_sprint_buf(new_heap, &amp;_s);
-			}
-
-		      if (! get_cmdline (PACKAGE &quot; edit&gt; &quot;, new_heap,
-					 NEW_HEAPSIZE + 1, 0, 1))
-			{
-			  int j = 0;
-
-			  /* get length of new command */
-			  while (new_heap[j++])
-			    ;
-
-			  if (j &lt; 2)
-			    {
-			      j = 2;
-			      new_heap[0] = ' ';
-			      new_heap[1] = 0;
-			    }
-
-			  /* align rest of commands properly */
-			  grub_memmove (cur_entry + j, cur_entry + i,
-					(int) heap - ((int) cur_entry + i));
-
-			  /* copy command to correct area */
-			  grub_memmove (cur_entry, new_heap, j);
-
-			  heap += (j - i);
-			}
-		    }
-
-		  goto restart;
-		}
-	      if (c == 'a')
-		{
-
-		char *actual_command_parametre, *new_heap;
-		  if (config_entries)
-		    {
-		      new_heap = heap;
-		    }
-		  else
-		    {
-		      /* safe area! */
-		      new_heap = heap + NEW_HEAPSIZE + 1;
-		    }		
-		actual_command_parametre=new_heap;
-		/* Build the string with grub_add= */
-		 new_heap+=grub_sprintf(new_heap,&quot;grub_add=\&quot;&quot;);
-
-		/* Get data from the user */
-		  if (! get_cmdline (PACKAGE &quot; add&gt; &quot;, new_heap,
-					 NEW_HEAPSIZE + 1, 0, 1)) 
-			{
-			struct builtin *setbuiltin;
-			/* Auxiliar char pointer */
-		  	char *aux_char;
-			/* Get the end of user entered data */
-			aux_char=new_heap+grub_strlen(new_heap);
-			/* Add the ending with grub_sprintf which already closes it.&quot; */
-			grub_sprintf(aux_char,&quot;\&quot;&quot;);
-			/* And close it */
-			
-
-		  	/* Get the pointer to the set command builtin structure.  */
-		  	setbuiltin = find_command (&quot;set&quot;);
-			/* Run set command with its parametre */
-			(setbuiltin-&gt;func) (actual_command_parametre,1);
-			}		
-		
-
-			goto restart;
-		}
-
-	      if (c == 'c')
-		{
-		  enter_cmdline (heap, 0);
-		  goto restart;
-		}
-#ifdef GRUB_UTIL
-	      if (c == 'q')
-		{
-		  /* The same as ``quit''.  */
-		  stop ();
-		}
-#endif
-
-	      /* Check toggles here so that we don't &quot;overwrite&quot; existing
-	       * key binding... (user should choose another key then) */
-	      if (toggle_do_key(c))
-	        goto restart;
-	    }
-	}
-    }
-  
-  /* Attempt to boot an entry.  */
-  
- boot_entry:
-  
-  cls ();
-  setcursor (1);
-  
-  while (1)
-    {
-
-      int len;
-
-      if (config_entries)
-	printf (&quot;  Booting \'%s\'\n\n&quot;,
-		var_sprint_buf(get_entry (menu_entries, first_entry + entryno, 0), &amp;len));
-      else
-	printf (&quot;  Booting command-list\n\n&quot;);
-
-      if (! cur_entry)
-	cur_entry = get_entry (config_entries, first_entry + entryno, 1);
-
-      /* Set CURRENT_ENTRYNO for the command &quot;savedefault&quot;.  */
-
-	current_entryno = first_entry + entryno;
-
-        menu_array[menu_level].cur_entry=cur_entry;
-        menu_array[menu_level].entryno=entryno;
-        menu_array[menu_level].fallback_entryno = fallback_entryno;
-	menu_array[menu_level].menu_entries = menu_entries;
-	menu_array[menu_level].config_entries = config_entries;
-	menu_array[menu_level].heap_run_menu = heap;
-	menu_array[menu_level].num_entries = num_entries;
-	menu_array[menu_level].first_entry = first_entry;
-
-
-      
-      memmove(menu_array[menu_level].config_file,	// TO
-      config_file,					// FROM
-      128);						//SIZE
-
-      if (run_script (cur_entry, heap))
-	{
-	// The code below should allow us to return to &quot;caller&quot; menu
-	// even if the &quot;caller&quot; menu just after the back command has
-	// a command that gives an error (like a back command when
-	// menu_level is already equal to 0)
-
-	cur_entry = menu_array[menu_level].cur_entry;
-        entryno = menu_array[menu_level].entryno;
-	fallback_entryno = menu_array[menu_level].fallback_entryno;
-	menu_entries = menu_array[menu_level].menu_entries;
-	config_entries = menu_array[menu_level].config_entries;
-	heap = menu_array[menu_level].heap_run_menu;
-	num_entries = menu_array[menu_level].num_entries;
-	first_entry = menu_array[menu_level].first_entry; 
-
-	  if (fallback_entryno &gt;= 0)
-	    {
-	      cur_entry = NULL;
-	      first_entry = 0;
-	      entryno = fallback_entries[fallback_entryno];
-	      fallback_entryno++;
-	      if (fallback_entryno &gt;= MAX_FALLBACK_ENTRIES
-		  || fallback_entries[fallback_entryno] &lt; 0)
-		fallback_entryno = -1;
-	    }
-	  else
-	    break;
-	}
-      else
-	{
-	
-	cur_entry = menu_array[menu_level].cur_entry;
-        entryno = menu_array[menu_level].entryno;
-        fallback_entryno = menu_array[menu_level].fallback_entryno;
-	menu_entries = menu_array[menu_level].menu_entries;
-	config_entries = menu_array[menu_level].config_entries;
-	heap = menu_array[menu_level].heap_run_menu;
-	num_entries = menu_array[menu_level].num_entries;
-	first_entry = menu_array[menu_level].first_entry; 
-	
-      
-      memmove(config_file,				// TO
-      menu_array[menu_level].config_file,		// FROM
-      128);						//SIZE
-
-	break;
-	}
-
-    }
-
-  show_menu = 1;
-  goto restart;
-}
-
-
-
-#if 0
-/* for debugging */
-static void hexdump(unsigned char *buf, unsigned len)
-{
-  int i, j = 0;
-  char s[17];
-  unsigned addr = (unsigned) buf;
-
-  s[16] = 0;
-  while(len--) {
-    i = buf[j];
-    i = i &amp; 0xff;
-    s[j &amp; 15] = (i &gt;= 0x20 &amp;&amp; i &lt;= 0x7e) ? i : '.';
-    if(!(j &amp; 15)) {
-      printf(&quot;%x  &quot;, j + addr);
-    }
-    if(!(j &amp; 7) &amp;&amp; (j &amp; 15)) printf(&quot; &quot;);
-    /* stupid grub_printf */
-    printf(&quot;%x&quot;, (i &gt;&gt; 4) &amp; 0x0f);
-    printf(&quot;%x &quot;, i &amp; 0x0f);
-    if(!(++j &amp; 15)) {
-      printf(&quot; %s\n&quot;, s);
-    }
-  }
-
-  if(j &amp; 15) {
-    s[j &amp; 15] = 0;
-    if(!(j &amp; 8)) printf(&quot; &quot;);
-    i = 1 + 3 * (16 - (j &amp; 15));
-    while(i--) printf(&quot; &quot;);
-    printf(&quot;%s\n&quot;, s);
-  }
-}
-#endif
-
-
-/* kernel + (grub-)module options */
-#define GFX_CMD_BUF_SIZE 512
-
-/* command line separator char */
-#define GFX_CMD_SEP 1
-
-/*
- * Go through config entry and find kernel args, if any.
- * Put things into buf and return it.
- */
-static char *get_kernel_args(char *cfg, char *buf)
-{
-  int i, j;
-  char *s, *t = &quot;&quot;, *p, *t2;
-
-  *(p = buf) = 0;
-
-  for(j = 0; ; j++) {
-    s = get_entry(cfg, j, 0);
-    if(!*s) break;
-    if(
-      (!memcmp(s, &quot;kernel&quot;, 6) || !memcmp(s, &quot;module&quot;, 6)) &amp;&amp;
-      (s[6] == ' ' || s[6] == '\t')
-    ) {
-      t = skip_to(0, s);
-      t2 = s[0] == 'm' ? strstr(t, &quot;initrd&quot;) : NULL;
-      if(*t) t = skip_to(0, t);
-      if(t2 &amp;&amp; t2 &lt; t) break;	/* module is likely a normal initrd -&gt; skip */
-      i = strlen(t);
-      if(p - buf + i &gt; GFX_CMD_BUF_SIZE - 2) break;
-      *p++ = GFX_CMD_SEP;
-      strcpy(p, t);
-      p += i;
-
-      continue;
-    }
-  }
-
-  if(*buf) buf++;	/* skip initial separator char */
-
-  return buf;
-}
-
-
-/*
- * Check header and return code start offset.
- */
-static unsigned magic_ok(unsigned char *buf)
-{
-  if(
-    *(unsigned *) buf == 0x0b2d97f00 &amp;&amp;		/* magic id */
-    (buf[4] == 8)				/* version 8 */
-  ) {
-    return *(unsigned *) (buf + 8);
-  }
-
-  return 0;
-}
-
-
-/*
- * Search cpio archive for gfx file.
- */
-static unsigned find_file(unsigned char *buf, unsigned len, unsigned *gfx_file_start, unsigned *file_len)
-{
-  unsigned i, fname_len, code_start = 0;
-
-  *gfx_file_start = 0;
-
-  for(i = 0; i &lt; len;) {
-    if((len - i) &gt;= 0x1a &amp;&amp; (buf[i] + (buf[i + 1] &lt;&lt; 8)) == 0x71c7) {
-      fname_len = *(unsigned short *) (buf + i + 20);
-      *file_len = *(unsigned short *) (buf + i + 24) + (*(unsigned short *) (buf + i + 22) &lt;&lt; 16);
-      i += 26 + fname_len;
-      i = ((i + 1) &amp; ~1);
-      if((code_start = magic_ok(buf + i))) {
-        *gfx_file_start = i;
-        return code_start;
-      }
-      i += *file_len;
-      i = ((i + 1) &amp; ~1);
-    }
-    else {
-      break;
-    }
-  }
-
-  return code_start;
-}
-
-static inline unsigned char * stack_ptr(void)
-{
-  unsigned char * u;
-
-  asm(&quot;movl %%esp, %0&quot; : &quot;=r&quot; (u));
-
-  return u;
-}
-
-static void sleep(int delay)
-{
-  int tick, last_tick = currticks();
-
-  delay *= 18;
-
-  while(delay--) {
-    while((tick = currticks()) == last_tick) { }
-    last_tick = tick;
-  }
-}  
-
-static void wait_for_key()
-{
-  printf(&quot;Press a key to continue...&quot;);
-  getkey();
-  printf(&quot;\r                          \r&quot;);
-}
-
-
-static void grub_gfx_status ()
-{
-  grub_printf(&quot;grub_gfx_status begins\n&quot;);
-}
-
-static void grub_gfx_cb()
-{
-
-#define CB_TABLE_LENGTH 6
-
-int alvar = al_value ();
-
-
-
-// int TABLE_LENGTH = 6;
-int *cb_table [CB_TABLE_LENGTH];
-/*
-*(cb_table[0])=grub_gfx_status();
-*(cb_table[1])=grub_gfx_fopen();
-*(cb_table[2])=grub_cb_fread();
-*(cb_table[3])=grub_cb_getcwd();
-*(cb_table[4])=grub_cb_chdir();
-*(cb_table[5])=grub_cb_readsector();
-*/
-/*
-*(cb_table[0])=grub_gfx_status;
-*(cb_table[1])=grub_gfx_status;
-*(cb_table[2])=grub_gfx_status;
-*(cb_table[3])=grub_gfx_status;
-*(cb_table[4])=grub_gfx_status;
-*(cb_table[5])=grub_gfx_status;
-*(cb_table[6])=grub_gfx_status;
-*/
-
-grub_printf(&quot;al value detected is: %d&quot;,alvar);
-grub_gfx_status();
-
-//(*(cb_table[alvar]))();
-
-}
-
-
-
-
-/*
- * Leave that much space on the heap. Everything else goes to the graphics
- * functions.
- *
- * 0x2000 is _not_ enough
- */
-#define MIN_HEAP_SIZE	0x4000
-#define MIN_GFX_FREE	0x1000
-
-#define SC_BOOTLOADER		0
-#define SC_FAILSAFE		3
-#define SC_SYSCONFIG_SIZE	4
-#define SC_BOOTLOADER_SEG	8
-#define SC_XMEM_0		24
-#define SC_XMEM_1		26
-#define SC_XMEM_2		28
-#define SC_XMEM_3		30
-#define SC_FILE			32
-#define SC_ARCHIVE_START	36
-#define SC_ARCHIVE_END		40
-#define SC_MEM0_START		44
-#define SC_MEM0_END		48
-
-/*
- * Does normally not return.
- */
-static void
-run_graphics_menu (char *menu_entries, char *config_entries, int num_entries,
-	  char *heap, int entryno)
-{
-  unsigned char *buf, *buf_ext;
-  unsigned buf_size, buf_ext_size, code_start, file_start;
-  char *s, *t, *t2, *cfg, *new_config, *p;
-  char *saved_heap;
-  int i, j, max_len, gfx_file_size, verbose;
-  int selected_entry;
-  gfx_data_t *gfx_data;
-  char *cmd_buf;
-  unsigned mem0_start, mem0_end, file_len;
-
-  /*
-   * check gfx_data_t struct offsets for consistency; gcc will optimize away
-   * the whole block
-   */
-
-  /* dummy function to make ld fail */
-  {
-    extern void wrong_struct_size(void);
-    #define gfx_ofs_check(a) if(gfx_ofs_##a != (char *) &amp;gfx_data-&gt;a - (char *) gfx_data) wrong_struct_size();
-    gfx_ofs_check(ok);
-    gfx_ofs_check(code_seg);
-    gfx_ofs_check(jmp_table);
-    gfx_ofs_check(sys_cfg);
-    gfx_ofs_check(cmdline);
-    gfx_ofs_check(cmdline_len);
-    gfx_ofs_check(menu_list);
-    gfx_ofs_check(menu_default_entry);
-    gfx_ofs_check(menu_entries);
-    gfx_ofs_check(menu_entry_len);
-    gfx_ofs_check(args_list);
-    gfx_ofs_check(args_entry_len);
-    gfx_ofs_check(timeout);
-    #undef gfx_ofs_check
-  }
-
-  if(!num_entries) return;
-
-  graphics_data = gfx_data = (gfx_data_t *) heap;
-  heap += sizeof *gfx_data;
-  memset(gfx_data, 0, sizeof *gfx_data);
-
-  gfx_data-&gt;sys_cfg[SC_BOOTLOADER] = 2;			/* bootloader: grub */
-  gfx_data-&gt;sys_cfg[SC_SYSCONFIG_SIZE] = 52;		/* config data size */
-  *(unsigned short *) (gfx_data-&gt;sys_cfg + SC_BOOTLOADER_SEG) = (unsigned) gfx_data &gt;&gt; 4;	/* segment */
-  gfx_data-&gt;sys_cfg[SC_XMEM_0] = 0x21;			/* 1MB @ 2MB */
-  gfx_data-&gt;sys_cfg[SC_XMEM_1] = 0x41;			/* 1MB @ 4MB */
-  verbose = (*(unsigned char *) 0x417) &amp; 3 ? 1 : 0;	/* SHIFT pressed */
-  gfx_data-&gt;sys_cfg[SC_FAILSAFE] = verbose;
-  // File I/O support for gfxboot through grub
-
-
-  gfx_data-&gt;sys_cfg[6] = &amp;grub_gfx_cb ;
-
-/*
-Stefen W... suggestion.
-  gfx_data-&gt;sys_cfg[6] =  grub_gfx_cb_ptr &amp; 0xff;
-  gfx_data-&gt;sys_cfg[7] = grub_gfx_cb_ptr &gt;&gt; 8;
-*/
-  gfx_data-&gt;timeout = grub_timeout &gt;= 0 ? grub_timeout : 0;
-
-
-  /* setup command line edit buffer */
-
-  gfx_data-&gt;cmdline_len = 256;
-
-  gfx_data-&gt;cmdline = heap;
-  heap += gfx_data-&gt;cmdline_len;
-  memset(gfx_data-&gt;cmdline, 0, gfx_data-&gt;cmdline_len);
-
-  cmd_buf = heap;
-  heap += GFX_CMD_BUF_SIZE;
-
-  /* setup menu entries */
-
-  for(i = max_len = 0; i &lt; num_entries; i++) {
-    j = strlen(get_entry(menu_entries, i, 0));
-    if(j &gt; max_len) max_len = j;
-  }
-
-  if(!max_len) return;
-
-  gfx_data-&gt;menu_entry_len = max_len + 1;
-  gfx_data-&gt;menu_entries = num_entries;
-
-  gfx_data-&gt;menu_list = heap;
-  heap += gfx_data-&gt;menu_entry_len * gfx_data-&gt;menu_entries;
-
-  memset(gfx_data-&gt;menu_list, 0, gfx_data-&gt;menu_entry_len * gfx_data-&gt;menu_entries);
-
-  for(i = 0; i &lt; (int) gfx_data-&gt;menu_entries; i++) {
-    strcpy(gfx_data-&gt;menu_list + i * gfx_data-&gt;menu_entry_len, get_entry(menu_entries, i, 0));
-  }
-
-  gfx_data-&gt;menu_default_entry = gfx_data-&gt;menu_list + entryno * gfx_data-&gt;menu_entry_len;
-
-
-  /* setup list of kernel args */
-
-  for(i = max_len = 0; i &lt; num_entries; i++) {
-    s = get_kernel_args(get_entry(config_entries, i, 1), cmd_buf);
-    j = strlen(s);
-    if(j &gt; max_len) max_len = j;
-  }
-
-  gfx_data-&gt;args_entry_len = max_len + 1;
-
-  gfx_data-&gt;args_list = heap;
-  heap += gfx_data-&gt;args_entry_len * gfx_data-&gt;menu_entries;
-
-  memset(gfx_data-&gt;args_list, 0, gfx_data-&gt;args_entry_len * gfx_data-&gt;menu_entries);
-
-  for(i = 0; i &lt; (int) gfx_data-&gt;menu_entries; i++) {
-    strcpy(gfx_data-&gt;args_list + i* gfx_data-&gt;args_entry_len, get_kernel_args(get_entry(config_entries, i, 1), cmd_buf));
-  }
-
-
-  /* go back here when we no longer need the graphics data */
-  saved_heap = heap;
-
-
-  /* get memory area to be used by graphics functions */
-
-  /* use 1MB starting at 2MB as file buffer */
-  buf_ext = (unsigned char *) (2 &lt;&lt; 20);
-  buf_ext_size = 1 &lt;&lt; 20;
-
-  /* must be 16-byte aligned */
-  buf = (unsigned char *) (((unsigned) heap + 0xf) &amp; ~0xf);
-
-  buf_size = stack_ptr() - buf - MIN_HEAP_SIZE;
-  buf_size &amp;= ~0xf;
-
-  mem0_start = (unsigned) buf;
-  mem0_end = mem0_start + buf_size;
-
-  if(verbose) {
-    printf(&quot;low memory 0x%x - 0x%x (%d bytes)\n&quot;, mem0_start, mem0_end, buf_size);
-    wait_for_key();
-  }
-
-  heap += buf_size;
-
-  /* read the file */
-
-  if(!grub_open(graphics_file)) {
-    printf(&quot;%s: file not found\n&quot;, graphics_file);
-    sleep(5);
-    heap = saved_heap;
-    return;
-  }
-
-  gfx_file_size = grub_read(buf_ext, buf_ext_size);
-
-  grub_close();
-
-  if(gfx_file_size &lt;= 0) {
-    printf(&quot;%s: read error\n&quot;, graphics_file);
-    sleep(5);
-    heap = saved_heap;
-    return;
-  }
-
-  if(verbose) {
-    printf(&quot;%s: %d bytes (%d bytes left)\n&quot;, graphics_file, gfx_file_size, buf_ext_size - gfx_file_size);
-    wait_for_key();
-  }
-
-  /* locate file inside cpio archive */
-  if(!(code_start = find_file(buf_ext, gfx_file_size, &amp;file_start, &amp;file_len))) {
-    printf(&quot;%s: invalid file format\n&quot;, graphics_file);
-    sleep(5);
-    heap = saved_heap;
-    return;
-  }
-
-  if(verbose) {
-    printf(&quot;init: start 0x%x, len %d; code offset 0x%x\n&quot;, file_start, file_len, code_start);
-    wait_for_key();
-  }
-
-  if(file_len - code_start + MIN_GFX_FREE &gt; buf_size) {
-    printf(&quot;not enough free memory: %d extra bytes need\n&quot;, file_len - code_start + MIN_GFX_FREE - buf_size);
-    sleep(5);
-    heap = saved_heap;
-    return;
-  }
-
-  memcpy((void *) buf, (void *) (buf_ext + file_start + code_start), file_len - code_start);
-
-  mem0_start += file_len - code_start;
-  mem0_start = (mem0_start + 3) &amp; ~3;		/* align */
-
-  /* init interface to graphics functions */
-
-  *(unsigned *) (gfx_data-&gt;sys_cfg + SC_FILE) = (unsigned) buf_ext + file_start;
-  *(unsigned *) (gfx_data-&gt;sys_cfg + SC_ARCHIVE_START) = (unsigned) buf_ext;
-  *(unsigned *) (gfx_data-&gt;sys_cfg + SC_ARCHIVE_END) = (unsigned) buf_ext + gfx_file_size;
-  *(unsigned *) (gfx_data-&gt;sys_cfg + SC_MEM0_START) = mem0_start;
-  *(unsigned *) (gfx_data-&gt;sys_cfg + SC_MEM0_END) = mem0_end;
-
-  gfx_data-&gt;code_seg = (unsigned) buf &gt;&gt; 4;
-
-  if(verbose) {
-    printf(&quot;init 0x%x, archive 0x%x - 0x%x, low mem 0x%x - 0x%x\ncode seg 0x%x\n&quot;,
-      (unsigned) buf_ext + file_start,
-      (unsigned) buf_ext, (unsigned) buf_ext + gfx_file_size,
-      mem0_start, mem0_end, gfx_data-&gt;code_seg
-    );
-    wait_for_key();
-  }
-
-  for(i = 0; (unsigned) i &lt; sizeof gfx_data-&gt;jmp_table / sizeof *gfx_data-&gt;jmp_table; i++) {
-    gfx_data-&gt;jmp_table[i] = (gfx_data-&gt;code_seg &lt;&lt; 16) + ((unsigned short *) buf)[i];
-  }
-
-  if(verbose) {
-    for(i = 0; i &lt; 12; i++) {
-      printf(&quot;%d: 0x%x\n&quot;, i, gfx_data-&gt;jmp_table[i]);
-    }
-
-    for(i = 0; i &lt; gfx_data-&gt;menu_entries; i++) {
-      printf(&quot;\&quot;%s\&quot;  --  \&quot;%s\&quot;\n&quot;,
-        gfx_data-&gt;menu_list + i * gfx_data-&gt;menu_entry_len,
-        gfx_data-&gt;args_list + i * gfx_data-&gt;args_entry_len
-      );
-    }
-
-    printf(&quot;default: \&quot;%s\&quot;\n&quot;, gfx_data-&gt;menu_default_entry);
-    wait_for_key();
-  }
-
-  /* switch to graphics mode */
-
-  if(gfx_init(gfx_data)) {
-    printf(&quot;graphics initialization failed\n&quot;);
-    sleep(5);
-    heap = saved_heap;
-    return;
-  }
-
-  gfx_setup_menu(gfx_data);
-
-  i = gfx_input(gfx_data, &amp;selected_entry);
-
-  /* ESC -&gt; show text menu */
-  if(i == 1) {
-    gfx_done(gfx_data);
-    grub_timeout = -1;
-
-    heap = saved_heap;
-    return;
-  }
-
-  gfx_done(gfx_data);
-
-  heap = saved_heap;	/* free most of the graphics data */
-
-  // printf(&quot;cmdline: &gt;%s&lt;, entry = %d\n&quot;, gfx_data-&gt;cmdline, selected_entry);
-
-  if(selected_entry &lt; 0 || selected_entry &gt; num_entries) return;
-
-
-  /* create new config with modified kernel option */
-
-  cfg = get_entry(config_entries, selected_entry, 1);
-
-  new_config = heap;
-
-  for(p = gfx_data-&gt;cmdline, i = 0; ; i++) {
-    s = get_entry(cfg, i, 0);
-    if(!*s) {
-      if(!i) *heap++ = 0;
-      *heap++ = 0;
-      break;
-    }
-    /* note: must match get_kernel_args() */
-    if(
-      (!memcmp(s, &quot;kernel&quot;, 6) || !memcmp(s, &quot;module&quot;, 6)) &amp;&amp;
-      (s[6] == ' ' || s[6] == '\t')
-    ) {
-      t = skip_to(0, s);
-      t2 = s[0] == 'm' ? strstr(t, &quot;initrd&quot;) : NULL;
-      if(*t) t = skip_to(0, t);
-      if(t2 &amp;&amp; t2 &lt; t) {	/* module is likely a normal initrd -&gt; skip */
-        strcpy(heap, s);
-        heap += strlen(s) + 1;
-        continue;
-      }
-      memmove(heap, s, t - s);
-      heap += t - s;
-      *heap++ = ' ';
-      while(*p &amp;&amp; *p != GFX_CMD_SEP) *heap++ = *p++;
-      *heap++ = 0;
-      if(*p == GFX_CMD_SEP) p++;
-    }
-    else {
-      strcpy(heap, s);
-      heap += strlen(s) + 1;
-    }
-  }
-
-  *heap++ = 0;
-
-  // hexdump(new_config, heap - new_config);
-  // getkey();
-
-  run_script(new_config, heap);
-}
-
-
-static int
-get_line_from_config (char *cmdline, int maxlen, int read_from_file)
-{
-  int pos = 0, literal = 0, comment = 0;
-  char c;  /* since we're loading it a byte at a time! */
-  
-  while (1)
-    {
-      if (read_from_file)
-	{
-	  if (! grub_read (&amp;c, 1))
-	    break;
-	}
-      else
-	{
-	  if (! read_from_preset_menu (&amp;c, 1))
-	    break;
-	}
-
-      /* Skip all carriage returns.  */
-      if (c == '\r')
-	continue;
-
-      /* Replace tabs with spaces.  */
-      if (c == '\t')
-	c = ' ';
-
-      /* The previous is a backslash, then...  */
-      if (literal)
-	{
-	  /* If it is a newline, replace it with a space and continue.  */
-	  if (c == '\n')
-	    {
-	      c = ' ';
-	      
-	      /* Go back to overwrite a backslash.  */
-	      if (pos &gt; 0)
-		pos--;
-	    }
-	    
-	  literal = 0;
-	}
-	  
-      /* translate characters first! */
-      if (c == '\\' &amp;&amp; ! literal)
-	literal = 1;
-
-      if (comment)
-	{
-	  if (c == '\n')
-	    comment = 0;
-	}
-      else if (! pos)
-	{
-	  if (c == '#')
-	    comment = 1;
-	  else if ((c != ' ') &amp;&amp; (c != '\n'))
-	    cmdline[pos++] = c;
-	}
-      else
-	{
-	  if (c == '\n')
-	    break;
-
-	  if (pos &lt; maxlen)
-	    cmdline[pos++] = c;
-	}
-    }
-
-  cmdline[pos] = 0;
-
-  return pos;
-}
-
-
-char *wildcard_prefix, *wildcard_suffix;
-char wildcard_matches[1024], *end_wildcard_matches;
-
-static void wildcard_handler(char *name);
-
-/* Match one directory entry against the current wildcard. If the entry
-   matches, store it in WILDCARD_MATCHES. Silently ignore entries that
-   don't fit into WILDCARD_MATCHES anymore. */
-static void
-wildcard_handler(char *name)
-{
-  char *n = name, *p = wildcard_prefix;
-
-  while (*p &amp;&amp; *p == *n)
-    {
-      p++;
-      n++;
-    }
-  if (*p)
-    return; /* prefix mismatch */
-
-  p = name + grub_strlen (name) - grub_strlen (wildcard_suffix);
-  /* [n .. p) is the part matching the asterisk */
-
-  if (p &lt;= n || grub_strcmp (p, wildcard_suffix) != 0)
-    return; /* zero-length match or suffix mismatch */
-
-  /* store this match */
-  if (p - n + 2 &gt; sizeof (wildcard_matches) -
-		  (end_wildcard_matches - wildcard_matches))
-    return; /* out of space */
-  while (n &lt; p)
-    *end_wildcard_matches++ = *n++;
-  *end_wildcard_matches++ = 0;
-}
-
-/* Wildcard expand the GLOB argument. Return NULL upon failure, or
-   a list of 0-terminated expansions, terminated by a zero-length string. */
-char *
-wildcard (char *glob)
-{
-  char path[128], *p;
-  int ret;
-
-  end_wildcard_matches = wildcard_matches;
-  if (grub_strlen (glob) + 1 &gt; sizeof (path)) {
-    errnum = ERR_FILELENGTH;
-    return NULL;  /* cannot handle pathnames this long */
-  }
-  grub_strcpy (path, glob);
-  p = path;
-  while (*p)
-    p++;
-  wildcard_suffix = p;
-  while (p &gt; path &amp;&amp; *p != '/')
-    p--;
-  if (*p != '/')
-    {
-      errnum = ERR_BAD_FILETYPE;
-      return NULL; /* Cannot wildcard device names */
-    }
-  *(++p) = 0;
-  wildcard_prefix = glob + (p - path);
-  for (p = wildcard_prefix;; p++)
-    {
-      if (*p == 0)
-	{
-	  /* We cannot do exact matches: this cannot be represented in the
-	     result list. */
-	  return NULL;
-	}
-      else if (*p == '*')
-	{
-	  *p++ = 0;
-	  wildcard_suffix = p;
-	  break;
-	}
-    }
-
-  ret = dir (path, wildcard_handler);
-  /* restore original argument */
-  wildcard_prefix[grub_strlen (wildcard_prefix)] = '*';
-  if (!ret)
-    return NULL;
-  *end_wildcard_matches++ = 0;
-  return wildcard_matches;
-}
-
-#define skip(str) ((str) + grub_strlen (str) + 1)
-
-static void inplace_sort (char *str);
-
-static void
-inplace_sort (char *str)
-{
-  int m, n = 0;
-  char *s, *t, *x;
-
-  for (s = str; *s; s = skip (s))
-    n++;
-  
-  /* we use x as temporary storage */
-  x = s + 1;
-
-  for (; n &gt;= 2; n--)
-    {
-      s = str;
-      t = skip (s);
-
-      for (m = n; m &gt;= 2; m--)
-	{
-	  if (grub_strcmp (s, t) &gt; 0)
-	    {
-	      int ls = skip (s) - s;
-	      int lt = skip (t) - t;
-
-	      memcpy (x, s, ls);
-	      grub_memmove (s + ls, s + lt, t - (s + ls));
-	      memcpy (s, t, lt);
-	      t = t + lt - ls;
-	      memcpy (t, x, ls);
-	    }
-	  s = t;
-	  t = skip (t);
-	}
-    }
-}
-
-static int this_config_len (const char *config);
-static int
-this_config_len (const char *config)
-{
-  const char *c = config;
-  while (*c)
-    {
-      while (*c)
-	c++;
-      c++;
-    }
-  c++;
-  return c - config;
-}
-
-static const char * expand_asterisks (const char *str, int *len,
-				      const char *subst);
-
-/* Expand all asterisks (*) in a menu entry or commands section with its
-   substitution. Use a backslash as escape character. */
-static const char *
-expand_asterisks (const char *str, int *len, const char *subst)
-{
-  static char buffer[1024];
-  char *b = buffer, escaped = 0;
-  const char *end = str + *len;
-
-  while (str &lt; end)
-    {
-      if (*str == '*' &amp;&amp; !escaped)
-        {
-	  if (b - buffer + grub_strlen (subst) &gt; sizeof (buffer))
-	    {
-	      errnum = ERR_FILELENGTH;
-	      return NULL;
-	    }
-	  grub_strcpy (b, subst);
-	  b += grub_strlen (subst);
-	}
-      else if (*str == '\\' &amp;&amp; !escaped)
-	escaped = 1;
-      else
-        {
-	  escaped = 0;
-	  if (b - buffer + 1 &gt; sizeof (buffer))
-	    {
-	      errnum = ERR_FILELENGTH;
-	      return NULL;
-	    }
-	  *b++ = *str;
-	}
-      str++;
-    }
-    *len = b - buffer;
-
-    return buffer;
-}
-
-/* This is the starting function in C.  */
-void
-cmain (void)
-{
-  int config_len, menu_len, num_entries;
-  char *config_entries, *menu_entries;
-  char *kill_buf = (char *) KILL_BUF;
-  // Default config_entries and menu_entries
-  config_entries = (char *) mbi.drives_addr + mbi.drives_length;
-  menu_entries = (char *) MENU_BUF;
-  // We copy them to the first place on menu_array.
-  menu_array[0].first_menu_entries=menu_entries;
-  menu_array[0].first_config_entries=config_entries;
-
-
-  menu_level = 0;
-  special_menu = 0; // We want to read the file.
-
-  auto void reset (void);
-  void reset (void)
-    {
-      count_lines = -1;
-      config_len = 0;
-      menu_len = 0;
-      num_entries = 0;
-      // Load the current menu_entries and config_entries
-      menu_entries=(char *) MENU_BUF;
-      config_entries=menu_array[menu_level].first_config_entries;
-      init_config ();
-    }
-
-  auto void expand_wildcard_entries (void);
-  void expand_wildcard_entries (void)
-    {
-      char *config_entry = config_entries;
-      char *menu_entry = menu_entries;
-
-      while (*menu_entry)
-        {
-	  char *command = config_entry;
-
-	  do
-	    {
-	      char *c = command;
-	      const char *w = &quot;wildcard&quot;;
-
-	      while (*w &amp;&amp; *c == *w)
-		{
-		  c++;
-		  w++;
-		}
-	      if (*w == 0 &amp;&amp; (*c == ' ' || *c == '\t' || *c == '='))
-		{
-		  int len;
-
-		  /* This is a wildcard command. Advance to the argument. */
-		  while (*c == ' ' || *c == '\t' || *c == '=')
-		    c++;
-
-		  /* Expand wildcard entry. */
-		  w = wildcard (c);
-		  if (w)
-		    inplace_sort (w);
-
-		  /* Remove the wildcard command from the command section;
-		     it has no meaning beyond the wildcard expansion just
-		     performed. */
-		  len = grub_strlen (command) + 1;
-		  grub_memmove (command, command + len,
-		  		config_len - (command - config_entries));
-		  config_len -= len;
-
-		  while (w &amp;&amp; *w)
-		    {
-		      /* Insert expansion before the wildcard entry in the
-		         list of entry names. */
-		      len = grub_strlen (menu_entry) + 1;
-		      const char *x = expand_asterisks (menu_entry, &amp;len, w);
-		      grub_memmove (menu_entry + len, menu_entry,
-		      		    menu_len - (menu_entry - menu_entries));
-		      memcpy (menu_entry, x, len);
-		      menu_entry += len;
-		      menu_len += len;
-		      
-		      /* Insert expansion before the wildcard command section
-		         in the list of command sections. */
-		      len = this_config_len (config_entry);
-		      x = expand_asterisks (config_entry, &amp;len, w);
-		      grub_memmove (config_entry + len, config_entry,
-		      		    config_len - (config_entry -
-				    		  config_entries));
-		      memcpy (config_entry, x, len);
-		      config_entry += len;
-		      config_len += len;
-
-		      num_entries++;
-		      w += grub_strlen (w) + 1;
-		    }
-
-		  /* Remove the wildcard command section; it has just
-		     been expanded. */
-		  len = grub_strlen (menu_entry) + 1;
-		  grub_memmove (menu_entry, menu_entry + len,
-		  		menu_len - (menu_entry - menu_entries));
-		  menu_len -= len;
-
-		  len = this_config_len(config_entry);
-		  grub_memmove (config_entry, config_entry + len,
-		  		config_len - (config_entry - config_entries));
-		  config_len -= len;
-
-		  num_entries--;
-		}
-	      command += grub_strlen (command) + 1;
-	    }
-	  while (*command);
-	  menu_entry += grub_strlen (menu_entry) + 1;
-	  config_entry += this_config_len(config_entry);
-	}
-    }
-
-
-  
-  /* Initialize the environment for restarting Stage 2.  */
-  grub_setjmp (restart_env);
-
-
-  /* Init toggle triggers. */
-//  toggle_trigger_init();
-  
-  /* Initialize the kill buffer.  */
-  *kill_buf = 0;
-
-//grub_printf(&quot;Test before running any menu\n&quot;); menu_array_status(); getkey();
-	  if (special_menu)
-   		{
-		reset ();
-
-		run_menu (menu_array[menu_level].first_menu_entries, menu_array[menu_level].first_config_entries, menu_array[menu_level].num_entries, menu_array[menu_level].first_menu_entries + menu_array[menu_level].menu_len, 1);	// Default entry 1 (Second one);
-		}
-  /* Never return.  */
-  for (;;)
-    {
-      int is_opened, is_preset;
-
-      reset ();
-      
-      /* Here load the configuration file.  */
-      
-#ifdef GRUB_UTIL
-      if (use_config_file)
-#endif /* GRUB_UTIL */
-	{
-	  int i;
-	  
-	  /* Get a saved default entry if possible.  */
-	  /* And only if not netbooting */
-	  saved_entryno = 0;
-	  if (config_file[0] != '('
-	      || config_file[1] != 'n'
-	      || config_file[2] != 'd'
-	      || config_file[3] != ')')
-	    {
-	      char *default_file = (char *) DEFAULT_FILE_BUF;
-
-	      *default_file = 0;
-	      grub_strncat (default_file, config_file, DEFAULT_FILE_BUFLEN);
-	      for (i = grub_strlen(default_file); i &gt;= 0; i--)
-		if (default_file[i] == '/')
-		  {
-		    i++;
-		    break;
-		  }
-	      default_file[i] = 0;
-	      grub_strncat (default_file + i, &quot;default&quot;, DEFAULT_FILE_BUFLEN - i);
-	      if (grub_open (default_file))
-		{
-		  char buf[10]; /* This is good enough.  */
-		  char *p = buf;
-		  int len;
-		  
-		  len = grub_read (buf, sizeof (buf));
-		  if (len &gt; 0)
-		    {
-		      buf[sizeof (buf) - 1] = 0;
-		      safe_parse_maxint (&amp;p, &amp;saved_entryno);
-		    }
-
-		  grub_close ();
-		}
-	    }
-	  errnum = ERR_NONE;
-	  
-	  do
-	    {
-	      /* STATE 0:  Before any title command.
-		 STATE 1:  In a title command.
-		 STATE &gt;1: In a entry after a title command.  */
-	      int state = 0, prev_config_len = 0, prev_menu_len = 0;
-	      char *cmdline;
-
-	      /* Try the preset menu first. This will succeed at most once,
-		 because close_preset_menu disables the preset menu.  */
-	      is_opened = is_preset = open_preset_menu ();
-	      if (! is_opened)
-		{
-		  is_opened = grub_open (config_file);
-		  errnum = ERR_NONE;
-		}
-
-	      if (! is_opened)
-		break;
-
-	      /* This is necessary, because the menu must be overrided.  */
-	      reset ();
-	      
-	      cmdline = (char *) CMDLINE_BUF;
-	      while (get_line_from_config (cmdline, NEW_HEAPSIZE,
-					   ! is_preset))
-		{
-		  struct builtin *builtin;
-		  
-		  /* Get the pointer to the builtin structure.  */
-		  builtin = find_command (cmdline);
-		  errnum = 0;
-		  if (! builtin)
-		    /* Unknown command. Just skip now.  */
-		    continue;
-		  
-		  if (builtin-&gt;flags &amp; BUILTIN_TITLE)
-		    {
-		      char *ptr;
-		      
-		      /* the command &quot;title&quot; is specially treated.  */
-		      if (state &gt; 1)
-			{
-			  /* The next title is found.  */
-			  num_entries++;
-			  config_entries[config_len++] = 0;
-			  prev_menu_len = menu_len;
-			  prev_config_len = config_len;
-			}
-		      else
-			{
-			  /* The first title is found.  */
-			  menu_len = prev_menu_len;
-			  config_len = prev_config_len;
-			}
-		      
-		      /* Reset the state.  */
-		      state = 1;
-		      
-		      /* Copy title into menu area.  */
-		      ptr = skip_to (1, cmdline);
-		      while ((menu_entries[menu_len++] = *(ptr++)) != 0)
-			;
-		    }
-		  else if (! state)
-		    {
-		      /* Run a command found is possible.  */
-		      if (builtin-&gt;flags &amp; BUILTIN_MENU)
-			{
-			  char *arg = skip_to (1, cmdline);
-			  int _xx; // This is supposedly a dummy variable
-			  int aux_filepos = filepos;
-			  arg = var_sprint_buf(arg, &amp;_xx);
-			  (builtin-&gt;func) (arg, BUILTIN_MENU);
-			  is_opened = grub_open (config_file); // Will this stupid trick work?
-			  filepos = aux_filepos; // Will this stupid trick work?
-			  errnum = 0; 
-			}
-		      else
-			/* Ignored.  */
-			continue;
-		    }
-		  else
-		    {
-		      char *ptr = cmdline;
-		      
-		      state++;
-		      /* Copy config file data to config area.  */
-		      while ((config_entries[config_len++] = *ptr++) != 0)
-			;
-		    }
-		}
-	      
-	      if (state &gt; 1)
-		{
-		  /* Finish the last entry.  */
-		  num_entries++;
-		  config_entries[config_len++] = 0;
-		}
-	      else
-		{
-		  menu_len = prev_menu_len;
-		  config_len = prev_config_len;
-		}
-	      
-	      if (is_preset)
-		close_preset_menu ();
-	      else
-		grub_close ();
-	      
-	      menu_entries[menu_len++] = 0;
-	      config_entries[config_len++] = 0;
-
-	      expand_wildcard_entries();
-
-	      grub_memmove (config_entries + config_len, menu_entries,
-			    menu_len);
-	      menu_entries = config_entries + config_len;
-		menu_array[menu_level].menu_len=menu_len;
-		menu_array[menu_level].config_len=config_len;
-		menu_array[menu_level].first_menu_entries=menu_entries;
-	      /* Make sure that all fallback entries are valid.  */
-	      if (fallback_entryno &gt;= 0)
-		{
-		  for (i = 0; i &lt; MAX_FALLBACK_ENTRIES; i++)
-		    {
-		      if (fallback_entries[i] &lt; 0)
-			break;
-		      if (fallback_entries[i] &gt;= num_entries)
-			{
-			  grub_memmove (fallback_entries + i,
-					fallback_entries + i + 1,
-					((MAX_FALLBACK_ENTRIES - i - 1)
-					 * sizeof (int)));
-			  i--;
-			}
-		    }
-
-		  if (fallback_entries[0] &lt; 0)
-		    fallback_entryno = -1;
-		}
-	      /* Check if the default entry is present. Otherwise reset
-		 it to fallback if fallback is valid, or to DEFAULT_ENTRY 
-		 if not.  */
-	      if (default_entry &gt;= num_entries)
-		{
-		  if (fallback_entryno &gt;= 0)
-		    {
-		      default_entry = fallback_entries[0];
-		      fallback_entryno++;
-		      if (fallback_entryno &gt;= MAX_FALLBACK_ENTRIES
-			  || fallback_entries[fallback_entryno] &lt; 0)
-			fallback_entryno = -1;
-		    }
-		  else
-		    default_entry = 0;
-		}
-	    }
-	  while (is_preset);
-	}
-
-      if (! num_entries)
-	{
-	  /* If no acceptable config file, goto command-line, starting
-	     heap from where the config entries would have been stored
-	     if there were any.  */
-	  enter_cmdline (config_entries, 1);
-	}
-      else
-	{
-	  /* Run menu interface.  */
-
-	menu_array[menu_level].menu_len=menu_len;
-	menu_array[menu_level].config_len=config_len;
-	menu_array[menu_level].num_entries=num_entries;
-	menu_array[menu_level].default_entry=default_entry;
-        //menu_array[menu_level].menu_entries=menu_entries;
-	//menu_array[menu_level].config_entries=config_entries;	
-	
-	  if (*graphics_file &amp;&amp; !password &amp;&amp; show_menu &amp;&amp; grub_timeout)
-	    {
-	      run_graphics_menu(menu_entries, config_entries, num_entries,menu_entries + menu_len, default_entry);
-	    }
-
-	
-	    /* Run menu interface.  */
-            run_menu (menu_entries, config_entries, num_entries, menu_entries + menu_len, default_entry);
-
-	//config_entries=menu_array[menu_level].config_entries;	
-	//menu_entries=menu_array[menu_level].menu_entries;
-	menu_len=menu_array[menu_level].menu_len;
-	config_len=menu_array[menu_level].config_len;
-	num_entries=menu_array[menu_level].num_entries;
-	default_entry=menu_array[menu_level].default_entry;
-
-	}
-    }
-
-}
-


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000004.html">[sgd-en] Mailing Liat
</A></li>
	<LI>Next message: <A HREF="000006.html">[sgd-en] which SCM to use?
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#5">[ date ]</a>
              <a href="thread.html#5">[ thread ]</a>
              <a href="subject.html#5">[ subject ]</a>
              <a href="author.html#5">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/supergrub-english">More information about the Supergrub-english
mailing list</a><br>
</body></html>
